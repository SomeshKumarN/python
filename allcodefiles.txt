//main.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:provider/provider.dart';

import 'pages/favorites_page.dart';
// Pages
import 'pages/home_page.dart';
import 'pages/library_page.dart';
import 'pages/profile_page.dart';
import 'pages/songs_page.dart';
import 'providers/favorites_provider.dart';
import 'providers/language_provider.dart';
// Providers
import 'providers/theme_provider.dart';
import 'providers/user_provider.dart';
import 'services/notification_service.dart';
// Services
import 'services/preferences_service.dart';
// Utils
import 'utils/constants.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize services
  await PreferencesService.init();
  await NotificationService.init();

  // Set preferred orientations
  await SystemChrome.setPreferredOrientations([
    DeviceOrientation.portraitUp,
    DeviceOrientation.portraitDown,
  ]);

  runApp(const AyyappaDevotionalApp());
}

class AyyappaDevotionalApp extends StatelessWidget {
  const AyyappaDevotionalApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => ThemeProvider()),
        ChangeNotifierProvider(create: (_) => LanguageProvider()),
        ChangeNotifierProvider(create: (_) => FavoritesProvider()),
        ChangeNotifierProvider(create: (_) => UserProvider()),
      ],
      child: Consumer<ThemeProvider>(
        builder: (context, themeProvider, child) {
          return MaterialApp(
            title: 'Ayyappa Devotional',
            debugShowCheckedModeBanner: false,

            // Theme Configuration
            theme: _buildLightTheme(),
            darkTheme: _buildDarkTheme(),
            themeMode: themeProvider.themeMode,

            // Home Page
            home: const MainNavigationPage(),

            // Route Configuration
            routes: {
              '/home': (context) => const MainNavigationPage(),
            },
          );
        },
      ),
    );
  }

  ThemeData _buildLightTheme() {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      colorScheme: ColorScheme.fromSeed(
        seedColor: AppColors.primary,
        brightness: Brightness.light,
      ),
      textTheme: GoogleFonts.poppinsTextTheme(),
      appBarTheme: const AppBarTheme(
        centerTitle: true,
        elevation: 0,
        scrolledUnderElevation: 0,
      ),
      cardTheme: CardTheme(
        elevation: 8,
        shadowColor: AppColors.primary.withOpacity(0.2),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),
      bottomNavigationBarTheme: const BottomNavigationBarTheme(
        elevation: 10,
        selectedItemColor: AppColors.primary,
        unselectedItemColor: AppColors.textSecondary,
        showUnselectedLabels: true,
        type: BottomNavigationBarType.fixed,
      ),
    );
  }

  ThemeData _buildDarkTheme() {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      colorScheme: ColorScheme.fromSeed(
        seedColor: AppColors.primary,
        brightness: Brightness.dark,
      ),
      textTheme: GoogleFonts.poppinsTextTheme(ThemeData.dark().textTheme),
      appBarTheme: const AppBarTheme(
        centerTitle: true,
        elevation: 0,
        scrolledUnderElevation: 0,
      ),
      cardTheme: CardTheme(
        elevation: 8,
        shadowColor: AppColors.primary.withOpacity(0.3),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),
      bottomNavigationBarTheme: const BottomNavigationBarTheme(
        elevation: 10,
        selectedItemColor: AppColors.accent,
        unselectedItemColor: AppColors.textSecondary,
        showUnselectedLabels: true,
        type: BottomNavigationBarType.fixed,
      ),
    );
  }
}

class MainNavigationPage extends StatefulWidget {
  const MainNavigationPage({super.key});

  @override
  State<MainNavigationPage> createState() => _MainNavigationPageState();
}

class _MainNavigationPageState extends State<MainNavigationPage>
    with TickerProviderStateMixin {
  int _currentIndex = 0;
  late PageController _pageController;
  late AnimationController _fabAnimationController;

  final List<Widget> _pages = [
    const HomePage(),
    const SongsPage(),
    const LibraryPage(),
    const FavoritesPage(),
    const ProfilePage(),
  ];

  final List<NavigationItem> _navigationItems = [
    NavigationItem(
      icon: Icons.home_outlined,
      activeIcon: Icons.home,
      label: 'Home',
    ),
    NavigationItem(
      icon: Icons.music_note_outlined,
      activeIcon: Icons.music_note,
      label: 'Songs',
    ),
    NavigationItem(
      icon: Icons.library_books_outlined,
      activeIcon: Icons.library_books,
      label: 'Library',
    ),
    NavigationItem(
      icon: Icons.favorite_outline,
      activeIcon: Icons.favorite,
      label: 'Favorites',
    ),
    NavigationItem(
      icon: Icons.person_outline,
      activeIcon: Icons.person,
      label: 'Profile',
    ),
  ];

  @override
  void initState() {
    super.initState();
    _pageController = PageController();
    _fabAnimationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
  }

  @override
  void dispose() {
    _pageController.dispose();
    _fabAnimationController.dispose();
    super.dispose();
  }

  void _onItemTapped(int index) {
    setState(() {
      _currentIndex = index;
    });

    _pageController.animateToPage(
      index,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );

    // Animate FAB based on current page
    if (index == 1) {
      // Songs page
      _fabAnimationController.forward();
    } else {
      _fabAnimationController.reverse();
    }

    // Haptic feedback
    HapticFeedback.lightImpact();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      extendBody: true,
      body: PageView(
        controller: _pageController,
        children: _pages,
        onPageChanged: (index) {
          setState(() {
            _currentIndex = index;
          });
        },
      ),

      // Bottom Navigation Bar
      bottomNavigationBar: Container(
        decoration: BoxDecoration(
          boxShadow: [
            BoxShadow(
              color: Theme.of(context).shadowColor.withOpacity(0.1),
              blurRadius: 20,
              offset: const Offset(0, -5),
            ),
          ],
        ),
        child: ClipRRect(
          borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
          child: BottomNavigationBar(
            currentIndex: _currentIndex,
            onTap: _onItemTapped,
            type: BottomNavigationBarType.fixed,
            backgroundColor: Theme.of(context).colorScheme.surface,
            selectedItemColor: AppColors.primary,
            unselectedItemColor: AppColors.textSecondary,
            selectedLabelStyle: const TextStyle(
              fontWeight: FontWeight.w600,
              fontSize: 12,
            ),
            unselectedLabelStyle: const TextStyle(
              fontWeight: FontWeight.w500,
              fontSize: 11,
            ),
            items: _navigationItems.map((item) {
              final index = _navigationItems.indexOf(item);
              return BottomNavigationBarItem(
                icon: AnimatedSwitcher(
                  duration: const Duration(milliseconds: 200),
                  child: Icon(
                    _currentIndex == index ? item.activeIcon : item.icon,
                    key: ValueKey(_currentIndex == index),
                  ),
                ),
                label: item.label,
              );
            }).toList(),
          ),
        ),
      ),

      // Floating Action Button (Context-aware)
      floatingActionButton: _buildContextualFAB(),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
    );
  }

  Widget? _buildContextualFAB() {
    switch (_currentIndex) {
      case 1: // Songs page
        return ScaleTransition(
          scale: _fabAnimationController,
          child: FloatingActionButton(
            onPressed: () {
              // TODO: Implement random song selection
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('ðŸŽµ Random song coming soon!'),
                  duration: Duration(seconds: 2),
                ),
              );
            },
            backgroundColor: AppColors.primary,
            foregroundColor: Colors.white,
            child: const Icon(Icons.shuffle),
          ),
        );

      case 3: // Favorites page
        return ScaleTransition(
          scale: _fabAnimationController,
          child: FloatingActionButton(
            onPressed: () {
              // TODO: Implement create playlist
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('ðŸ“ Create playlist coming soon!'),
                  duration: Duration(seconds: 2),
                ),
              );
            },
            backgroundColor: AppColors.accent,
            foregroundColor: Colors.white,
            child: const Icon(Icons.playlist_add),
          ),
        );

      default:
        return null;
    }
  }
}

class NavigationItem {
  final IconData icon;
  final IconData activeIcon;
  final String label;

  NavigationItem({
    required this.icon,
    required this.activeIcon,
    required this.label,
  });
}
//pubspec_yaml.txt
name: ayyappa_devotional_app
description: A premium multilingual devotional Flutter app dedicated to Lord Ayyappa
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: '>=3.0.0 <4.0.0'

dependencies:
  flutter:
    sdk: flutter
  
  # State Management
  provider: ^6.0.5
  
  # Local Storage & Preferences
  shared_preferences: ^2.2.2
  sqflite: ^2.3.0
  path_provider: ^2.1.1
  
  # UI & Design
  google_fonts: ^6.1.0
  cached_network_image: ^3.3.0
  flutter_staggered_grid_view: ^0.7.0
  animations: ^2.0.8
  carousel_slider: ^4.2.1
  flutter_svg: ^2.0.9
  
  # Audio & Media
  audioplayers: ^5.2.1
  
  # Notifications & Sharing
  flutter_local_notifications: ^16.3.0
  share_plus: ^7.2.1
  permission_handler: ^11.1.0
  
  # Utilities
  intl: ^0.18.1
  
  # Icons
  cupertino_icons: ^1.0.2

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0

flutter:
  uses-material-design: true

  # Custom Assets
  assets:
    # Images
    - assets/images/ayyappa/deity_images/
    - assets/images/ayyappa/temple_images/
    - assets/images/ayyappa/festival_images/
    - assets/images/icons/
    - assets/images/backgrounds/gradient_patterns/
    - assets/images/backgrounds/texture_overlays/
    
    # Data Files
    - assets/data/songs.json
    - assets/data/rituals.json
    - assets/data/history.json
    - assets/data/festivals.json
    
    # Audio Files (for future use)
    - assets/audio/mantras/

  # Custom Fonts
  fonts:
    - family: TamilFont
      fonts:
        - asset: assets/fonts/tamil_font.ttf
    - family: TeluguFont
      fonts:
        - asset: assets/fonts/telugu_font.ttf
    
    # Add Google Fonts for English content
    - family: Poppins
      fonts:
        - asset: assets/fonts/Poppins-Regular.ttf
        - asset: assets/fonts/Poppins-Medium.ttf
          weight: 500
        - asset: assets/fonts/Poppins-SemiBold.ttf
          weight: 600
        - asset: assets/fonts/Poppins-Bold.ttf
          weight: 700

flutter_intl:
  enabled: true
  class_name: S
  main_locale: en
  arb_dir: lib/l10n
  output_dir: lib/generated
//l10n/app_en_json.json
{
  "appTitle": "Lord Ayyappa Devotional",
  "appSubtitle": "Your Spiritual Companion",
  
  "common": {
    "ok": "OK",
    "cancel": "Cancel",
    "yes": "Yes",
    "no": "No",
    "save": "Save",
    "share": "Share",
    "favorite": "Favorite",
    "unfavorite": "Remove from Favorites",
    "loading": "Loading...",
    "error": "Error",
    "retry": "Retry",
    "search": "Search",
    "filter": "Filter",
    "sort": "Sort",
    "settings": "Settings",
    "close": "Close",
    "done": "Done",
    "next": "Next",
    "previous": "Previous",
    "play": "Play",
    "pause": "Pause",
    "stop": "Stop"
  },

  "navigation": {
    "home": "Home",
    "songs": "Songs",
    "library": "Library",
    "favorites": "Favorites",
    "profile": "Profile"
  },

  "home": {
    "welcomeMessage": "Welcome to Lord Ayyappa Devotional",
    "goodMorning": "Good Morning",
    "goodAfternoon": "Good Afternoon", 
    "goodEvening": "Good Evening",
    "goodNight": "Good Night",
    "dailyMantra": "Daily Mantra",
    "quoteOfTheDay": "Quote of the Day",
    "popularSongs": "Popular Songs",
    "photoGallery": "Photo Gallery",
    "ayyappaHistory": "Lord Ayyappa History",
    "viewAll": "View All",
    "exploreMore": "Explore More",
    "blessings": "May Lord Ayyappa bless you",
    "devotionalGreeting": "Ayyappa Swamy Saranam!",
    "todaysSpecial": "Today's Special",
    "featuredContent": "Featured Content",
    "quickAccess": "Quick Access",
    "recentlyPlayed": "Recently Played"
  },

  "songs": {
    "allSongs": "All Songs",
    "searchSongs": "Search songs, singers, writers...",
    "noSongsFound": "No songs found",
    "sortBy": "Sort by",
    "sortByTitle": "Title",
    "sortBySinger": "Singer", 
    "sortByWriter": "Writer",
    "ascending": "A to Z",
    "descending": "Z to A",
    "filterBy": "Filter by",
    "allLanguages": "All Languages",
    "tamil": "Tamil",
    "telugu": "Telugu",
    "englishTamil": "English (Tamil)",
    "englishTelugu": "English (Telugu)",
    "singer": "Singer",
    "writer": "Writer",
    "duration": "Duration",
    "addedToFavorites": "Added to favorites",
    "removedFromFavorites": "Removed from favorites",
    "nowPlaying": "Now Playing",
    "songDetails": "Song Details"
  },

  "songView": {
    "lyrics": "Lyrics",
    "fontSize": "Font Size",
    "small": "Small",
    "medium": "Medium", 
    "large": "Large",
    "extraLarge": "Extra Large",
    "language": "Language",
    "autoScroll": "Auto Scroll",
    "fullScreen": "Full Screen",
    "exitFullScreen": "Exit Full Screen",
    "shareThis": "Share This",
    "addToPlaylist": "Add to Playlist",
    "downloadOffline": "Download for Offline",
    "audioControls": "Audio Controls",
    "repeat": "Repeat",
    "shuffle": "Shuffle",
    "lyricsView": "Lyrics View",
    "audioPlayer": "Audio Player"
  },

  "library": {
    "sacredTexts": "Sacred Texts",
    "ritualGuide": "Ritual Guide", 
    "photoGallery": "Photo Gallery",
    "mantrasCollection": "Mantras Collection",
    "festivalCalendar": "Festival Calendar",
    "ayyappaHistory": "Ayyappa History",
    "devotionalStories": "Devotional Stories",
    "templeGuide": "Temple Guide",
    "sabarimalaPreparation": "Sabarimala Preparation",
    "dailyWorship": "Daily Worship",
    "vrataRules": "Vrata Rules",
    "poojaVidhi": "Pooja Vidhi",
    "birthStory": "Birth Story",
    "puliPaalLegend": "Puli Paal Legend",
    "sabarimalaImportance": "Sabarimala Importance",
    "miracleStories": "Miracle Stories",
    "upcomingFestivals": "Upcoming Festivals",
    "auspiciousDates": "Auspicious Dates",
    "festivalDetails": "Festival Details"
  },

  "favorites": {
    "myFavorites": "My Favorites",
    "favoriteSongs": "Favorite Songs",
    "favoriteMantas": "Favorite Mantras",
    "favoriteQuotes": "Favorite Quotes",
    "favoriteStories": "Favorite Stories",
    "recentlyAdded": "Recently Added",
    "mostPlayed": "Most Played",
    "createPlaylist": "Create Playlist",
    "managePlaylists": "Manage Playlists",
    "smartCollections": "Smart Collections",
    "offlineContent": "Offline Content",
    "noFavorites": "No favorites yet",
    "startExploring": "Start exploring to add favorites",
    "playAll": "Play All",
    "shufflePlay": "Shuffle Play",
    "downloadAll": "Download All",
    "shareCollection": "Share Collection"
  },

  "profile": {
    "myProfile": "My Profile",
    "devotionalJourney": "Devotional Journey",
    "streakDays": "Streak Days",
    "songsLearned": "Songs Learned",
    "mantrasChanted": "Mantras Chanted",
    "achievementBadges": "Achievement Badges",
    "preferences": "Preferences",
    "notifications": "Notifications",
    "language": "Language",
    "theme": "Theme",
    "fontSize": "Font Size",
    "about": "About",
    "version": "Version",
    "rateApp": "Rate App",
    "shareApp": "Share App",
    "contactUs": "Contact Us",
    "privacyPolicy": "Privacy Policy",
    "termsOfService": "Terms of Service",
    "statistics": "Statistics",
    "progress": "Progress",
    "milestones": "Milestones"
  },

  "settings": {
    "appSettings": "App Settings",
    "displaySettings": "Display Settings",
    "audioSettings": "Audio Settings",
    "notificationSettings": "Notification Settings",
    "dataSettings": "Data Settings",
    "darkMode": "Dark Mode",
    "lightMode": "Light Mode",
    "sepiaMode": "Sepia Mode",
    "systemDefault": "System Default",
    "dailyReminder": "Daily Reminder",
    "festivalAlerts": "Festival Alerts",
    "newContentNotification": "New Content Notification",
    "autoDownload": "Auto Download",
    "wifiOnly": "WiFi Only",
    "clearCache": "Clear Cache",
    "resetSettings": "Reset Settings",
    "backup": "Backup",
    "restore": "Restore"
  },

  "themes": {
    "light": "Light",
    "dark": "Dark",
    "sepia": "Sepia",
    "system": "System Default",
    "devotional": "Devotional",
    "golden": "Golden",
    "spiritual": "Spiritual"
  },

  "languages": {
    "english": "English",
    "tamil": "Tamil",
    "telugu": "Telugu",
    "englishTamilPhonetic": "English (Tamil Phonetic)",
    "englishTeluguPhonetic": "English (Telugu Phonetic)",
    "selectLanguage": "Select Language",
    "primaryLanguage": "Primary Language",
    "secondaryLanguage": "Secondary Language"
  },

  "sharing": {
    "shareApp": "Share App",
    "shareSong": "Share Song",
    "shareMantra": "Share Mantra",
    "shareQuote": "Share Quote",
    "shareProgress": "Share Progress",
    "shareWith": "Share with...",
    "copyLink": "Copy Link",
    "shareVia": "Share via",
    "sharedSuccessfully": "Shared successfully",
    "shareFailedTryAgain": "Share failed, try again"
  },

  "audio": {
    "nowPlaying": "Now Playing",
    "queue": "Queue",
    "volume": "Volume",
    "speed": "Playback Speed",
    "equalizer": "Equalizer",
    "sleepTimer": "Sleep Timer",
    "loopSong": "Loop Song",
    "loopPlaylist": "Loop Playlist",
    "shuffleMode": "Shuffle Mode",
    "audioQuality": "Audio Quality",
    "high": "High",
    "medium": "Medium",
    "low": "Low"
  },

  "search": {
    "searchHint": "Search songs, mantras, stories...",
    "recentSearches": "Recent Searches",
    "clearHistory": "Clear History",
    "noResults": "No results found",
    "searchResults": "Search Results",
    "suggestions": "Suggestions",
    "popularSearches": "Popular Searches"
  },

  "notifications": {
    "dailyMantraTitle": "Daily Mantra",
    "dailyMantraBody": "Start your day with Lord Ayyappa's blessings",
    "festivalReminderTitle": "Festival Reminder",
    "festivalReminderBody": "Don't miss today's auspicious occasion",
    "newContentTitle": "New Content Available",
    "newContentBody": "Explore new devotional content",
    "streakReminderTitle": "Maintain Your Streak",
    "streakReminderBody": "Continue your devotional journey",
    "meditationTimeTitle": "Meditation Time",
    "meditationTimeBody": "Take a moment for spiritual reflection"
  },

  "errors": {
    "networkError": "Network connection error",
    "loadingError": "Error loading content",
    "audioError": "Audio playback error",
    "downloadError": "Download failed",
    "shareError": "Sharing failed",
    "saveError": "Save failed",
    "genericError": "Something went wrong",
    "tryAgain": "Please try again",
    "checkConnection": "Check your internet connection",
    "contactSupport": "Contact support if problem persists"
  },

  "achievements": {
    "firstSong": "First Song Learned",
    "weeklyStreak": "Weekly Devotee",
    "monthlyStreak": "Monthly Devotee",
    "yearlyStreak": "Yearly Devotee",
    "songMaster": "Song Master",
    "mantraChanter": "Mantra Chanter",
    "storyTeller": "Story Keeper",
    "devotionalGuide": "Devotional Guide",
    "pilgrim": "Virtual Pilgrim",
    "blessed": "Blessed Devotee"
  },

  "rituals": {
    "mandalaVratam": "Mandala Vratam",
    "dailyPooja": "Daily Pooja",
    "fasting": "Fasting Guidelines",
    "pilgrimage": "Pilgrimage Preparation",
    "offerings": "Sacred Offerings",
    "chanting": "Chanting Rules",
    "meditation": "Meditation Practice",
    "seva": "Seva Activities",
    "vrataPreparation": "Vrata Preparation",
    "templeVisit": "Temple Visit Guide"
  },

  "festivals": {
    "makarsankranti": "Makar Sankranti",
    "ayyappaJayanti": "Ayyappa Jayanti", 
    "sabarimalaSeasonOpen": "Sabarimala Season Opening",
    "sabarimalaSeasonClose": "Sabarimala Season Closing",
    "panguni": "Panguni Festival",
    "chitrapournami": "Chitra Pournami",
    "kartigai": "Kartigai Deepam",
    "shivaratri": "Maha Shivaratri",
    "navaratri": "Navaratri",
    "diwali": "Diwali"
  },

  "mantras": {
    "ayyappaMantras": "Ayyappa Mantras",
    "swamiyeSaranam": "Swamiye Saranam",
    "ashtottaram": "Ashtottara Shatanamavali",
    "sahasranamam": "Sahasranamam",
    "harivarasanam": "Harivarasanam",
    "suprabhatam": "Suprabhatam",
    "aarti": "Aarti",
    "stotram": "Stotram",
    "gayatri": "Ayyappa Gayatri",
    "moola": "Moola Mantra"
  },

  "quotes": {
    "devotionalWisdom": "Devotional Wisdom",
    "spiritualGuidance": "Spiritual Guidance",
    "dailyInspiration": "Daily Inspiration",
    "sacredThoughts": "Sacred Thoughts",
    "divineMessages": "Divine Messages"
  }
}
//l10n/app_ta_json.json
{
  "appTitle": "à®à®¯à®ªà¯à®ªà®©à¯ à®ªà®•à¯à®¤à®¿",
  "navigation": {
    "home": "à®®à¯à®•à®ªà¯à®ªà¯",
    "songs": "à®ªà®¾à®Ÿà®²à¯à®•à®³à¯",
    "library": "à®¨à¯‚à®²à®•à®®à¯",
    "favorites": "à®µà®¿à®°à¯à®ªà¯à®ªà®™à¯à®•à®³à¯",
    "profile": "à®šà¯à®¯à®µà®¿à®µà®°à®®à¯"
  },
  "home": {
    "dailyMantra": "à®¤à®¿à®©à®šà®°à®¿ à®®à®¨à¯à®¤à®¿à®°à®®à¯",
    "quoteOfDay": "à®‡à®©à¯à®±à¯ˆà®¯ à®®à¯‡à®±à¯à®•à¯‹à®³à¯",
    "popularSongs": "à®ªà®¿à®°à®ªà®²à®®à®¾à®© à®ªà®¾à®Ÿà®²à¯à®•à®³à¯",
    "photoGallery": "à®ªà¯à®•à¯ˆà®ªà¯à®ªà®Ÿ à®¤à®¿à®°à®Ÿà¯à®Ÿà¯",
    "ayyappaHistory": "à®à®¯à®ªà¯à®ªà®©à¯ à®µà®°à®²à®¾à®±à¯",
    "goodMorning": "à®•à®¾à®²à¯ˆ à®µà®£à®•à¯à®•à®®à¯",
    "goodAfternoon": "à®®à®¤à®¿à®¯ à®µà®£à®•à¯à®•à®®à¯",
    "goodEvening": "à®®à®¾à®²à¯ˆ à®µà®£à®•à¯à®•à®®à¯",
    "goodNight": "à®‡à®°à®µà¯ à®µà®£à®•à¯à®•à®®à¯",
    "blessedDay": "à®†à®šà¯€à®°à¯à®µà®¤à®¿à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿ à®¨à®¾à®³à¯",
    "settings": "à®…à®®à¯ˆà®ªà¯à®ªà¯à®•à®³à¯"
  },
  "songs": {
    "searchHint": "à®ªà®¾à®Ÿà®²à¯à®•à®³à¯, à®ªà®¾à®Ÿà®•à®°à¯à®•à®³à¯ à®…à®²à¯à®²à®¤à¯ à®Žà®´à¯à®¤à¯à®¤à®¾à®³à®°à¯à®•à®³à¯ˆà®¤à¯ à®¤à¯‡à®Ÿà¯à®™à¯à®•à®³à¯",
    "sortBy": "à®µà®°à®¿à®šà¯ˆà®ªà¯à®ªà®Ÿà¯à®¤à¯à®¤à¯",
    "sortTitle": "à®¤à®²à¯ˆà®ªà¯à®ªà¯",
    "sortSinger": "à®ªà®¾à®Ÿà®•à®°à¯",
    "sortWriter": "à®Žà®´à¯à®¤à¯à®¤à®¾à®³à®°à¯",
    "ascending": "à®à®±à¯à®µà®°à®¿à®šà¯ˆ",
    "descending": "à®‡à®±à®™à¯à®•à¯à®µà®°à®¿à®šà¯ˆ",
    "noSongsFound": "à®ªà®¾à®Ÿà®²à¯à®•à®³à¯ à®Žà®¤à¯à®µà¯à®®à¯ à®•à®¿à®Ÿà¯ˆà®•à¯à®•à®µà®¿à®²à¯à®²à¯ˆ",
    "singer": "à®ªà®¾à®Ÿà®•à®°à¯",
    "writer": "à®Žà®´à¯à®¤à¯à®¤à®¾à®³à®°à¯",
    "clearFilters": "à®µà®Ÿà®¿à®•à®Ÿà¯à®Ÿà®¿à®•à®³à¯ˆ à®…à®´à®¿à®•à¯à®•à®µà¯à®®à¯"
  },
  "songView": {
    "tamil": "à®¤à®®à®¿à®´à¯",
    "telugu": "à°¤à±†à°²à±à°—à±",
    "englishTamil": "à®†à®™à¯à®•à®¿à®² à®¤à®®à®¿à®´à¯",
    "englishTelugu": "à°†à°‚à°—à±à°² à°¤à±†à°²à±à°—à±",
    "fontSize": "à®Žà®´à¯à®¤à¯à®¤à¯ à®…à®³à®µà¯",
    "playAudio": "à®†à®Ÿà®¿à®¯à¯‹ à®‡à®¯à®•à¯à®•à®µà¯à®®à¯",
    "pauseAudio": "à®†à®Ÿà®¿à®¯à¯‹ à®‡à®Ÿà¯ˆà®¨à®¿à®±à¯à®¤à¯à®¤à®µà¯à®®à¯",
    "stopAudio": "à®†à®Ÿà®¿à®¯à¯‹ à®¨à®¿à®±à¯à®¤à¯à®¤à®µà¯à®®à¯",
    "share": "à®ªà®•à®¿à®°à¯à®¨à¯à®¤à¯ à®•à¯Šà®³à¯à®³à¯à®™à¯à®•à®³à¯",
    "addToFavorites": "à®µà®¿à®°à¯à®ªà¯à®ªà®™à¯à®•à®³à®¿à®²à¯ à®šà¯‡à®°à¯à®•à¯à®•à®µà¯à®®à¯",
    "removeFromFavorites": "à®µà®¿à®°à¯à®ªà¯à®ªà®™à¯à®•à®³à®¿à®²à®¿à®°à¯à®¨à¯à®¤à¯ à®…à®•à®±à¯à®±à®µà¯à®®à¯"
  },
  "library": {
    "sacredTexts": "à®ªà¯à®©à®¿à®¤ à®¨à¯‚à®²à¯à®•à®³à¯",
    "ritualGuide": "à®šà®Ÿà®™à¯à®•à¯ à®µà®´à®¿à®•à®¾à®Ÿà¯à®Ÿà®¿",
    "photoGallery": "à®ªà¯à®•à¯ˆà®ªà¯à®ªà®Ÿ à®¤à®¿à®°à®Ÿà¯à®Ÿà¯",
    "mantrasCollection": "à®®à®¨à¯à®¤à®¿à®° à®¤à¯Šà®•à¯à®ªà¯à®ªà¯",
    "festivalCalendar": "à®ªà®£à¯à®Ÿà®¿à®•à¯ˆ à®¨à®¾à®Ÿà¯à®•à®¾à®Ÿà¯à®Ÿà®¿",
    "ayyappaMahatmyam": "à®à®¯à®ªà¯à®ª à®®à®¹à®¾à®¤à¯à®®à®¿à®¯à®®à¯",
    "birthStory": "à®ªà®¿à®±à®ªà¯à®ªà¯ à®•à®¤à¯ˆ",
    "puliPaal": "à®ªà¯à®²à®¿ à®ªà®¾à®²à¯",
    "sabarimalaHistory": "à®šà®ªà®°à®¿à®®à®²à¯ˆ à®µà®°à®²à®¾à®±à¯",
    "dailyWorship": "à®¤à®¿à®©à®šà®°à®¿ à®µà®´à®¿à®ªà®¾à®Ÿà¯",
    "sabarimalaPreparation": "à®šà®ªà®°à®¿à®®à®²à¯ˆ à®¤à®¯à®¾à®°à®¿à®ªà¯à®ªà¯",
    "vrataRules": "à®µà®¿à®°à®¤ à®µà®¿à®¤à®¿à®•à®³à¯",
    "templeFestivals": "à®•à¯‹à®µà®¿à®²à¯ à®ªà®£à¯à®Ÿà®¿à®•à¯ˆà®•à®³à¯",
    "deityImages": "à®¤à¯†à®¯à¯à®µ à®ªà®Ÿà®™à¯à®•à®³à¯",
    "devoteePhotos": "à®ªà®•à¯à®¤à®°à¯ à®ªà¯à®•à¯ˆà®ªà¯à®ªà®Ÿà®™à¯à®•à®³à¯",
    "dailyMantras": "à®¤à®¿à®©à®šà®°à®¿ à®®à®¨à¯à®¤à®¿à®°à®™à¯à®•à®³à¯",
    "specialMantras": "à®šà®¿à®±à®ªà¯à®ªà¯ à®®à®¨à¯à®¤à®¿à®°à®™à¯à®•à®³à¯",
    "ayyappaFestivals": "à®à®¯à®ªà¯à®ªà®©à¯ à®ªà®£à¯à®Ÿà®¿à®•à¯ˆà®•à®³à¯",
    "auspiciousDates": "à®¨à®²à¯à®² à®¨à®¾à®Ÿà¯à®•à®³à¯"
  },
  "favorites": {
    "recentlyPlayed": "à®šà®®à¯€à®ªà®¤à¯à®¤à®¿à®²à¯ à®‡à®¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®µà¯ˆ",
    "customPlaylists": "à®¤à®©à®¿à®ªà¯à®ªà®¯à®©à¯ à®ªà®Ÿà¯à®Ÿà®¿à®¯à®²à¯à®•à®³à¯",
    "offlineDownloads": "à®†à®ƒà®ªà¯à®²à¯ˆà®©à¯ à®ªà®¤à®¿à®µà®¿à®±à®•à¯à®•à®™à¯à®•à®³à¯",
    "noFavorites": "à®µà®¿à®°à¯à®ªà¯à®ªà®®à®¾à®© à®‰à®°à¯à®ªà¯à®ªà®Ÿà®¿à®•à®³à¯ à®Žà®¤à¯à®µà¯à®®à¯ à®‡à®²à¯à®²à¯ˆ",
    "createPlaylist": "à®ªà®Ÿà¯à®Ÿà®¿à®¯à®²à¯ à®‰à®°à¯à®µà®¾à®•à¯à®•à®µà¯à®®à¯",
    "playlistName": "à®ªà®Ÿà¯à®Ÿà®¿à®¯à®²à¯ à®ªà¯†à®¯à®°à¯",
    "create": "à®‰à®°à¯à®µà®¾à®•à¯à®•à¯",
    "cancel": "à®°à®¤à¯à®¤à¯ à®šà¯†à®¯à¯",
    "addToPlaylist": "à®ªà®Ÿà¯à®Ÿà®¿à®¯à®²à®¿à®²à¯ à®šà¯‡à®°à¯à®•à¯à®•à®µà¯à®®à¯",
    "removeFromPlaylist": "à®ªà®Ÿà¯à®Ÿà®¿à®¯à®²à®¿à®²à®¿à®°à¯à®¨à¯à®¤à¯ à®…à®•à®±à¯à®±à®µà¯à®®à¯",
    "deletePlaylist": "à®ªà®Ÿà¯à®Ÿà®¿à®¯à®²à¯ˆ à®¨à¯€à®•à¯à®•à®µà¯à®®à¯",
    "shareVerse": "à®µà®šà®©à®¤à¯à®¤à¯ˆà®ªà¯ à®ªà®•à®¿à®°à¯à®¨à¯à®¤à¯ à®•à¯Šà®³à¯à®³à¯à®™à¯à®•à®³à¯"
  },
  "profile": {
    "devotionalJourney": "à®ªà®•à¯à®¤à®¿ à®ªà®¯à®£à®®à¯",
    "daysActive": "à®šà¯†à®¯à®²à®¿à®²à¯ à®‰à®³à¯à®³ à®¨à®¾à®Ÿà¯à®•à®³à¯",
    "songsLearned": "à®•à®±à¯à®±à¯à®•à¯à®•à¯Šà®£à¯à®Ÿ à®ªà®¾à®Ÿà®²à¯à®•à®³à¯",
    "achievements": "à®šà®¾à®¤à®©à¯ˆà®•à®³à¯",
    "statistics": "à®ªà¯à®³à¯à®³à®¿à®µà®¿à®µà®°à®™à¯à®•à®³à¯",
    "settings": "à®…à®®à¯ˆà®ªà¯à®ªà¯à®•à®³à¯",
    "language": "à®®à¯Šà®´à®¿",
    "theme": "à®¤à¯€à®®à¯",
    "notifications": "à®…à®±à®¿à®µà®¿à®ªà¯à®ªà¯à®•à®³à¯",
    "about": "à®ªà®±à¯à®±à®¿",
    "version": "à®ªà®¤à®¿à®ªà¯à®ªà¯",
    "developer": "à®‰à®°à¯à®µà®¾à®•à¯à®•à¯à®©à®°à¯",
    "feedback": "à®•à®°à¯à®¤à¯à®¤à¯",
    "rate": "à®®à®¤à®¿à®ªà¯à®ªà®¿à®Ÿà¯",
    "share": "à®ªà®•à®¿à®°à¯à®¨à¯à®¤à¯ à®•à¯Šà®³à¯à®³à¯à®™à¯à®•à®³à¯",
    "privacy": "à®¤à®©à®¿à®¯à¯à®°à®¿à®®à¯ˆ",
    "terms": "à®µà®¿à®¤à®¿à®®à¯à®±à¯ˆà®•à®³à¯",
    "firstSong": "à®®à¯à®¤à®²à¯ à®ªà®¾à®Ÿà®²à¯",
    "weekStreak": "à®µà®¾à®° à®¤à¯Šà®Ÿà®°à¯à®šà¯à®šà®¿",
    "monthlyGoal": "à®®à®¾à®¤à®¾à®¨à¯à®¤à®¿à®° à®‡à®²à®•à¯à®•à¯",
    "devotedLearner": "à®…à®°à¯à®ªà¯à®ªà®£à®¿à®ªà¯à®ªà¯à®³à¯à®³ à®®à®¾à®£à®µà®°à¯",
    "songMaster": "à®ªà®¾à®Ÿà®²à¯ à®®à®¾à®¸à¯à®Ÿà®°à¯"
  },
  "themes": {
    "light": "à®’à®³à®¿",
    "dark": "à®‡à®°à¯à®³à¯",
    "sepia": "à®šà¯†à®ªà®¿à®¯à®¾"
  },
  "languages": {
    "tamil": "à®¤à®®à®¿à®´à¯",
    "telugu": "à°¤à±†à°²à±à°—à±",
    "english": "English"
  },
  "common": {
    "loading": "à®à®±à¯à®±à¯à®•à®¿à®±à®¤à¯...",
    "error": "à®ªà®¿à®´à¯ˆ",
    "retry": "à®®à¯€à®£à¯à®Ÿà¯à®®à¯ à®®à¯à®¯à®±à¯à®šà®¿à®•à¯à®•à®µà¯à®®à¯",
    "ok": "à®šà®°à®¿",
    "cancel": "à®°à®¤à¯à®¤à¯ à®šà¯†à®¯à¯",
    "save": "à®šà¯‡à®®à®¿",
    "delete": "à®¨à¯€à®•à¯à®•à¯",
    "edit": "à®¤à®¿à®°à¯à®¤à¯à®¤à¯",
    "share": "à®ªà®•à®¿à®°à¯à®¨à¯à®¤à¯ à®•à¯Šà®³à¯à®³à¯à®™à¯à®•à®³à¯",
    "search": "à®¤à¯‡à®Ÿà¯",
    "filter": "à®µà®Ÿà®¿à®•à®Ÿà¯à®Ÿà®¿",
    "sort": "à®µà®°à®¿à®šà¯ˆà®ªà¯à®ªà®Ÿà¯à®¤à¯à®¤à¯",
    "today": "à®‡à®©à¯à®±à¯",
    "yesterday": "à®¨à¯‡à®±à¯à®±à¯",
    "thisWeek": "à®‡à®¨à¯à®¤ à®µà®¾à®°à®®à¯",
    "thisMonth": "à®‡à®¨à¯à®¤ à®®à®¾à®¤à®®à¯",
    "all": "à®…à®©à¯ˆà®¤à¯à®¤à¯à®®à¯",
    "none": "à®Žà®¤à¯à®µà¯à®®à¯ à®‡à®²à¯à®²à¯ˆ",
    "yes": "à®†à®®à¯",
    "no": "à®‡à®²à¯à®²à¯ˆ",
    "on": "à®‡à®¯à®•à¯à®•à¯",
    "off": "à®¨à®¿à®±à¯à®¤à¯à®¤à¯",
    "enable": "à®šà¯†à®¯à®²à¯à®ªà®Ÿà¯à®¤à¯à®¤à¯",
    "disable": "à®®à¯à®Ÿà®•à¯à®•à¯"
  },
  "quotes": [
    "à®“à®®à¯ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®¾",
    "à®¨à¯€ à®‡à®²à¯à®²à®¾à®®à®²à¯ à®¨à®¾à®™à¯à®•à®³à¯ à®Žà®¤à¯à®µà¯à®®à¯ à®‡à®²à¯à®²à¯ˆ, à®à®¯à®ªà¯à®ªà®¾",
    "à®‰à®©à¯ à®…à®°à¯à®³à®¾à®²à¯ à®…à®©à¯ˆà®¤à¯à®¤à¯à®®à¯ à®šà®¾à®¤à¯à®¤à®¿à®¯à®®à¯, à®¸à¯à®µà®¾à®®à®¿ à®à®¯à®ªà¯à®ªà®¾",
    "à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®¾ - à®¨à¯€ à®¤à®¾à®©à¯ à®Žà®™à¯à®•à®³à¯ à®ªà®¾à®¤à¯à®•à®¾à®ªà¯à®ªà¯",
    "à®à®¯à®ªà¯à®ªà®©à®¿à®©à¯ à®…à®°à¯à®³à®¾à®²à¯ à®…à®©à¯ˆà®¤à¯à®¤à¯ à®¤à®Ÿà¯ˆà®•à®³à¯à®®à¯ à®¨à¯€à®™à¯à®•à¯à®®à¯"
  ],
  "mantras": [
    "à®“à®®à¯ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®¾",
    "à®šà¯à®µà®¾à®®à®¿ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®¾",
    "à®šà®¿à®µ à®šà®•à¯à®¤à®¿ à®à®•à¯à®•à®¿à®¯à®¤à¯à®¤à®¿à®©à¯ à®ªà¯à®¤à¯à®¤à®¿à®°à®¾ à®¨à®®à®¹",
    "à®•à®²à®¿à®¯à¯à®• à®µà®°à®¤à®¾ à®à®¯à®ªà¯à®ªà®¾ à®šà®°à®£à®®à¯",
    "à®¹à®°à®¿à®¹à®° à®ªà¯à®¤à¯à®¤à®¿à®°à®¾ à®à®¯à®ªà¯à®ªà®¾ à®¨à®®à®¹"
  ]
}
//l10n/app_te_json.json
{
  "appTitle": "à°…à°¯à±à°¯à°ªà±à°ª à°­à°•à±à°¤à°¿",
  "navigation": {
    "home": "à°¹à±‹à°®à±",
    "songs": "à°ªà°¾à°Ÿà°²à±",
    "library": "à°²à±ˆà°¬à±à°°à°°à±€",
    "favorites": "à°‡à°·à±à°Ÿà°®à±ˆà°¨à°µà°¿",
    "profile": "à°ªà±à°°à±Šà°«à±ˆà°²à±"
  },
  "home": {
    "dailyMantra": "à°°à±‹à°œà±à°µà°¾à°°à±€ à°®à°‚à°¤à±à°°à°‚",
    "quoteOfDay": "à°¨à±‡à°Ÿà°¿ à°¸à°‚à°¦à±‡à°¶à°‚",
    "popularSongs": "à°ªà±à°°à°¸à°¿à°¦à±à°§ à°ªà°¾à°Ÿà°²à±",
    "photoGallery": "à°«à±‹à°Ÿà±‹ à°—à±à°¯à°¾à°²à°°à±€",
    "ayyappaHistory": "à°…à°¯à±à°¯à°ªà±à°ª à°šà°°à°¿à°¤à±à°°",
    "goodMorning": "à°¶à±à°­à±‹à°¦à°¯à°‚",
    "goodAfternoon": "à°¶à±à°­à°®à°§à±à°¯à°¾à°¹à±à°¨à°‚",
    "goodEvening": "à°¶à±à°­à°¸à°¾à°¯à°‚à°¤à±à°°à°‚",
    "goodNight": "à°¶à±à°­à°°à°¾à°¤à±à°°à°¿",
    "blessedDay": "à°†à°¶à±€à°°à±à°µà°¦à°¿à°¤ à°¦à°¿à°¨à°‚",
    "settings": "à°¸à±†à°Ÿà±à°Ÿà°¿à°‚à°—à±à°¸à±"
  },
  "songs": {
    "searchHint": "à°ªà°¾à°Ÿà°²à±, à°—à°¾à°¯à°•à±à°²à± à°²à±‡à°¦à°¾ à°°à°šà°¯à°¿à°¤à°²à°¨à± à°µà±†à°¤à°•à°‚à°¡à°¿",
    "sortBy": "à°•à±à°°à°®à°¬à°¦à±à°§à±€à°•à°°à°£",
    "sortTitle": "à°Ÿà±ˆà°Ÿà°¿à°²à±",
    "sortSinger": "à°—à°¾à°¯à°•à±à°¡à±",
    "sortWriter": "à°°à°šà°¯à°¿à°¤",
    "ascending": "à°†à°°à±‹à°¹à°£",
    "descending": "à°…à°µà°°à±‹à°¹à°£",
    "noSongsFound": "à°ªà°¾à°Ÿà°²à± à°•à°¨à±à°—à±Šà°¨à°¬à°¡à°²à±‡à°¦à±",
    "singer": "à°—à°¾à°¯à°•à±à°¡à±",
    "writer": "à°°à°šà°¯à°¿à°¤",
    "clearFilters": "à°«à°¿à°²à±à°Ÿà°°à±à°²à°¨à± à°•à±à°²à°¿à°¯à°°à± à°šà±‡à°¯à°‚à°¡à°¿"
  },
  "songView": {
    "tamil": "à®¤à®®à®¿à®´à¯",
    "telugu": "à°¤à±†à°²à±à°—à±",
    "englishTamil": "à°‡à°‚à°—à±à°²à±€à°·à± à°¤à°®à°¿à°³à°‚",
    "englishTelugu": "à°‡à°‚à°—à±à°²à±€à°·à± à°¤à±†à°²à±à°—à±",
    "fontSize": "à°…à°•à±à°·à°° à°ªà°°à°¿à°®à°¾à°£à°‚",
    "playAudio": "à°†à°¡à°¿à°¯à±‹ à°ªà±à°²à±‡ à°šà±‡à°¯à°‚à°¡à°¿",
    "pauseAudio": "à°†à°¡à°¿à°¯à±‹ à°ªà°¾à°œà± à°šà±‡à°¯à°‚à°¡à°¿",
    "stopAudio": "à°†à°¡à°¿à°¯à±‹ à°†à°ªà°‚à°¡à°¿",
    "share": "à°·à±‡à°°à± à°šà±‡à°¯à°‚à°¡à°¿",
    "addToFavorites": "à°‡à°·à±à°Ÿà°®à±ˆà°¨à°µà°¾à°Ÿà°¿à°•à°¿ à°œà±‹à°¡à°¿à°‚à°šà°‚à°¡à°¿",
    "removeFromFavorites": "à°‡à°·à±à°Ÿà°®à±ˆà°¨à°µà°¾à°Ÿà°¿ à°¨à±à°‚à°¡à°¿ à°¤à±€à°¸à°¿à°µà±‡à°¯à°‚à°¡à°¿"
  },
  "library": {
    "sacredTexts": "à°ªà°µà°¿à°¤à±à°° à°—à±à°°à°‚à°¥à°¾à°²à±",
    "ritualGuide": "à°•à°°à±à°®à°•à°¾à°‚à°¡ à°—à±ˆà°¡à±",
    "photoGallery": "à°«à±‹à°Ÿà±‹ à°—à±à°¯à°¾à°²à°°à±€",
    "mantrasCollection": "à°®à°‚à°¤à±à°° à°¸à°‚à°•à°²à°¨à°‚",
    "festivalCalendar": "à°ªà°‚à°¡à±à°— à°•à±à°¯à°¾à°²à±†à°‚à°¡à°°à±",
    "ayyappaMahatmyam": "à°…à°¯à±à°¯à°ªà±à°ª à°®à°¹à°¾à°¤à±à°®à±à°¯à°‚",
    "birthStory": "à°œà°¨à±à°® à°•à°¥",
    "puliPaal": "à°ªà±à°²à°¿ à°ªà°¾à°²à±",
    "sabarimalaHistory": "à°¶à°¬à°°à°¿à°®à°² à°šà°°à°¿à°¤à±à°°",
    "dailyWorship": "à°°à±‹à°œà±à°µà°¾à°°à±€ à°ªà±‚à°œ",
    "sabarimalaPreparation": "à°¶à°¬à°°à°¿à°®à°² à°¤à°¯à°¾à°°à±€",
    "vrataRules": "à°µà±à°°à°¤ à°¨à°¿à°¯à°®à°¾à°²à±",
    "templeFestivals": "à°¦à±‡à°µà°¾à°²à°¯ à°ªà°‚à°¡à±à°—à°²à±",
    "deityImages": "à°¦à±ˆà°µ à°šà°¿à°¤à±à°°à°¾à°²à±",
    "devoteePhotos": "à°­à°•à±à°¤à±à°² à°«à±‹à°Ÿà±‹à°²à±",
    "dailyMantras": "à°°à±‹à°œà±à°µà°¾à°°à±€ à°®à°‚à°¤à±à°°à°¾à°²à±",
    "specialMantras": "à°ªà±à°°à°¤à±à°¯à±‡à°• à°®à°‚à°¤à±à°°à°¾à°²à±",
    "ayyappaFestivals": "à°…à°¯à±à°¯à°ªà±à°ª à°ªà°‚à°¡à±à°—à°²à±",
    "auspiciousDates": "à°¶à±à°­ à°¤à±‡à°¦à±€à°²à±"
  },
  "favorites": {
    "recentlyPlayed": "à°‡à°Ÿà±€à°µà°² à°ªà±à°²à±‡ à°šà±‡à°¸à°¿à°¨à°µà°¿",
    "customPlaylists": "à°•à°¸à±à°Ÿà°®à± à°ªà±à°²à±‡à°²à°¿à°¸à±à°Ÿà±à°²à±",
    "offlineDownloads": "à°†à°«à±à°²à±ˆà°¨à± à°¡à±Œà°¨à±à°²à±‹à°¡à±à°²à±",
    "noFavorites": "à°‡à°·à±à°Ÿà°®à±ˆà°¨ à°…à°‚à°¶à°¾à°²à± à°²à±‡à°µà±",
    "createPlaylist": "à°ªà±à°²à±‡à°²à°¿à°¸à±à°Ÿà± à°¸à±ƒà°·à±à°Ÿà°¿à°‚à°šà°‚à°¡à°¿",
    "playlistName": "à°ªà±à°²à±‡à°²à°¿à°¸à±à°Ÿà± à°ªà±‡à°°à±",
    "create": "à°¸à±ƒà°·à±à°Ÿà°¿à°‚à°šà±",
    "cancel": "à°°à°¦à±à°¦à± à°šà±‡à°¯à°¿",
    "addToPlaylist": "à°ªà±à°²à±‡à°²à°¿à°¸à±à°Ÿà±à°•à± à°œà±‹à°¡à°¿à°‚à°šà°‚à°¡à°¿",
    "removeFromPlaylist": "à°ªà±à°²à±‡à°²à°¿à°¸à±à°Ÿà± à°¨à±à°‚à°¡à°¿ à°¤à±€à°¸à°¿à°µà±‡à°¯à°‚à°¡à°¿",
    "deletePlaylist": "à°ªà±à°²à±‡à°²à°¿à°¸à±à°Ÿà± à°¤à±Šà°²à°—à°¿à°‚à°šà°‚à°¡à°¿",
    "shareVerse": "à°¶à±à°²à±‹à°•à°‚ à°·à±‡à°°à± à°šà±‡à°¯à°‚à°¡à°¿"
  },
  "profile": {
    "devotionalJourney": "à°­à°•à±à°¤à°¿ à°¯à°¾à°¤à±à°°",
    "daysActive": "à°•à±à°°à°¿à°¯à°¾à°¶à±€à°² à°°à±‹à°œà±à°²à±",
    "songsLearned": "à°¨à±‡à°°à±à°šà±à°•à±à°¨à±à°¨ à°ªà°¾à°Ÿà°²à±",
    "achievements": "à°µà°¿à°œà°¯à°¾à°²à±",
    "statistics": "à°—à°£à°¾à°‚à°•à°¾à°²à±",
    "settings": "à°¸à±†à°Ÿà±à°Ÿà°¿à°‚à°—à±à°¸à±",
    "language": "à°­à°¾à°·",
    "theme": "à°¥à±€à°®à±",
    "notifications": "à°¨à±‹à°Ÿà°¿à°«à°¿à°•à±‡à°·à°¨à±à°²à±",
    "about": "à°—à±à°°à°¿à°‚à°šà°¿",
    "version": "à°µà±†à°°à±à°·à°¨à±",
    "developer": "à°¡à±†à°µà°²à°ªà°°à±",
    "feedback": "à°«à±€à°¡à±à°¬à±à°¯à°¾à°•à±",
    "rate": "à°°à±‡à°Ÿà± à°šà±‡à°¯à°‚à°¡à°¿",
    "share": "à°·à±‡à°°à± à°šà±‡à°¯à°‚à°¡à°¿",
    "privacy": "à°—à±‹à°ªà±à°¯à°¤",
    "terms": "à°¨à°¿à°¯à°®à°¾à°²à±",
    "firstSong": "à°®à±Šà°¦à°Ÿà°¿ à°ªà°¾à°Ÿ",
    "weekStreak": "à°µà°¾à°°à°ªà± à°¶à±à°°à±‡à°£à°¿",
    "monthlyGoal": "à°¨à±†à°²à°µà°¾à°°à±€ à°²à°•à±à°·à±à°¯à°‚",
    "devotedLearner": "à°…à°‚à°•à°¿à°¤ à°µà°¿à°¦à±à°¯à°¾à°°à±à°¥à°¿",
    "songMaster": "à°ªà°¾à°Ÿà°² à°®à°¾à°¸à±à°Ÿà°°à±"
  },
  "themes": {
    "light": "à°²à±ˆà°Ÿà±",
    "dark": "à°¡à°¾à°°à±à°•à±",
    "sepia": "à°¸à±†à°ªà°¿à°¯à°¾"
  },
  "languages": {
    "tamil": "à®¤à®®à®¿à®´à¯",
    "telugu": "à°¤à±†à°²à±à°—à±",
    "english": "English"
  },
  "common": {
    "loading": "à°²à±‹à°¡à°µà±à°¤à±‹à°‚à°¦à°¿...",
    "error": "à°¦à±‹à°·à°‚",
    "retry": "à°®à°³à±à°²à±€ à°ªà±à°°à°¯à°¤à±à°¨à°¿à°‚à°šà°‚à°¡à°¿",
    "ok": "à°¸à°°à±‡",
    "cancel": "à°°à°¦à±à°¦à± à°šà±‡à°¯à°¿",
    "save": "à°¸à±‡à°µà±",
    "delete": "à°¤à±Šà°²à°—à°¿à°‚à°šà±",
    "edit": "à°Žà°¡à°¿à°Ÿà±",
    "share": "à°·à±‡à°°à± à°šà±‡à°¯à°‚à°¡à°¿",
    "search": "à°µà±†à°¤à°•à°‚à°¡à°¿",
    "filter": "à°«à°¿à°²à±à°Ÿà°°à±",
    "sort": "à°•à±à°°à°®à°¬à°¦à±à°§à±€à°•à°°à°£",
    "today": "à°ˆà°°à±‹à°œà±",
    "yesterday": "à°¨à°¿à°¨à±à°¨",
    "thisWeek": "à°ˆ à°µà°¾à°°à°‚",
    "thisMonth": "à°ˆ à°¨à±†à°²",
    "all": "à°…à°¨à±à°¨à±€",
    "none": "à°à°¦à±€ à°²à±‡à°¦à±",
    "yes": "à°…à°µà±à°¨à±",
    "no": "à°²à±‡à°¦à±",
    "on": "à°†à°¨à±",
    "off": "à°†à°«à±",
    "enable": "à°šà±‡à°¤à°¨à°ªà°°à°šà±",
    "disable": "à°…à°šà±‡à°¤à°¨à°ªà°°à°šà±"
  },
  "quotes": [
    "à°“à°‚ à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ªà°¾",
    "à°¨à±€à°µà± à°²à±‡à°•à±à°‚à°¡à°¾ à°®à±‡à°®à± à°à°®à±€ à°²à±‡à°®à±, à°…à°¯à±à°¯à°ªà±à°ªà°¾",
    "à°¨à±€ à°…à°¨à±à°—à±à°°à°¹à°‚à°¤à±‹ à°…à°¨à±à°¨à±€ à°¸à°¾à°§à±à°¯à°‚, à°¸à±à°µà°¾à°®à°¿ à°…à°¯à±à°¯à°ªà±à°ªà°¾",
    "à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ªà°¾ - à°¨à±€à°µà±‡ à°®à°¾ à°°à°•à±à°·à°£",
    "à°…à°¯à±à°¯à°ªà±à°ª à°…à°¨à±à°—à±à°°à°¹à°‚à°¤à±‹ à°…à°¨à±à°¨à°¿ à°…à°¡à±à°¡à°‚à°•à±à°²à± à°¤à±Šà°²à°—à°¿à°ªà±‹à°¤à°¾à°¯à°¿"
  ],
  "mantras": [
    "à°“à°‚ à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ªà°¾",
    "à°¸à±à°µà°¾à°®à°¿ à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ªà°¾",
    "à°¶à°¿à°µ à°¶à°•à±à°¤à°¿ à°à°•à±à°¯à°¤à°¾ à°ªà±à°¤à±à°°à°¾ à°¨à°®à°ƒ",
    "à°•à°²à°¿à°¯à±à°— à°µà°°à°¦à°¾ à°…à°¯à±à°¯à°ªà±à°ªà°¾ à°¶à°°à°£à°‚",
    "à°¹à°°à°¿à°¹à°° à°ªà±à°¤à±à°°à°¾ à°…à°¯à±à°¯à°ªà±à°ªà°¾ à°¨à°®à°ƒ"
  ]
}
//models/devotional_content.dart
/// Model classes for devotional content including mantras, quotes, history,
/// and other spiritual content for the Lord Ayyappa devotional app.
/// 
/// This comprehensive model system handles various forms of devotional content
/// with multilingual support, categorization, and rich metadata.

/// Base class for all devotional content
abstract class DevotionalContent {
  final String id;
  final String title;
  final String content;
  final ContentType type;
  final Map<String, String> translations;
  final List<String> tags;
  final DateTime createdAt;
  final DateTime? updatedAt;
  final bool isFeatured;
  final bool isPremium;
  final int orderIndex;

  const DevotionalContent({
    required this.id,
    required this.title,
    required this.content,
    required this.type,
    this.translations = const {},
    this.tags = const [],
    required this.createdAt,
    this.updatedAt,
    this.isFeatured = false,
    this.isPremium = false,
    this.orderIndex = 0,
  });

  /// Gets translated content for the given language code
  String getTranslatedContent(String languageCode) {
    return translations['${languageCode}_content'] ?? content;
  }

  /// Gets translated title for the given language code
  String getTranslatedTitle(String languageCode) {
    return translations['${languageCode}_title'] ?? title;
  }

  /// Checks if content matches search query
  bool matchesSearch(String query) {
    final searchQuery = query.toLowerCase();
    return title.toLowerCase().contains(searchQuery) ||
           content.toLowerCase().contains(searchQuery) ||
           tags.any((tag) => tag.toLowerCase().contains(searchQuery));
  }

  Map<String, dynamic> toBaseJson() {
    return {
      'id': id,
      'title': title,
      'content': content,
      'type': type.name,
      'translations': translations,
      'tags': tags,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt?.toIso8601String(),
      'isFeatured': isFeatured,
      'isPremium': isPremium,
      'orderIndex': orderIndex,
    };
  }
}

/// Model for mantras and sacred chants
class MantraModel extends DevotionalContent {
  final String? deityName;
  final MantraCategory category;
  final MantrapowerLevel powerLevel;
  final Duration? recommendedDuration;
  final int recommendedRepetitions;
  final List<String> benefits;
  final String? pronunciation;
  final String? meaning;
  final String? audioUrl;
  final MantraTimming bestTime;
  final List<String> prerequisites;

  const MantraModel({
    required super.id,
    required super.title,
    required super.content,
    super.translations = const {},
    super.tags = const [],
    required super.createdAt,
    super.updatedAt,
    super.isFeatured = false,
    super.isPremium = false,
    super.orderIndex = 0,
    this.deityName,
    this.category = MantraCategory.general,
    this.powerLevel = MantrapowerLevel.beginner,
    this.recommendedDuration,
    this.recommendedRepetitions = 108,
    this.benefits = const [],
    this.pronunciation,
    this.meaning,
    this.audioUrl,
    this.bestTime = MantraTimming.anytime,
    this.prerequisites = const [],
  }) : super(type: ContentType.mantra);

  factory MantraModel.fromJson(Map<String, dynamic> json) {
    return MantraModel(
      id: json['id'] as String,
      title: json['title'] as String,
      content: json['content'] as String,
      translations: Map<String, String>.from(json['translations'] ?? {}),
      tags: List<String>.from(json['tags'] ?? []),
      createdAt: DateTime.parse(json['createdAt']),
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt']) : null,
      isFeatured: json['isFeatured'] ?? false,
      isPremium: json['isPremium'] ?? false,
      orderIndex: json['orderIndex'] ?? 0,
      deityName: json['deityName'] as String?,
      category: MantraCategory.values.firstWhere(
        (e) => e.name == json['category'],
        orElse: () => MantraCategory.general,
      ),
      powerLevel: MantrapowerLevel.values.firstWhere(
        (e) => e.name == json['powerLevel'],
        orElse: () => MantrapowerLevel.beginner,
      ),
      recommendedDuration: json['recommendedDurationMinutes'] != null
          ? Duration(minutes: json['recommendedDurationMinutes'])
          : null,
      recommendedRepetitions: json['recommendedRepetitions'] ?? 108,
      benefits: List<String>.from(json['benefits'] ?? []),
      pronunciation: json['pronunciation'] as String?,
      meaning: json['meaning'] as String?,
      audioUrl: json['audioUrl'] as String?,
      bestTime: MantraTimming.values.firstWhere(
        (e) => e.name == json['bestTime'],
        orElse: () => MantraTimming.anytime,
      ),
      prerequisites: List<String>.from(json['prerequisites'] ?? []),
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final baseJson = toBaseJson();
    baseJson.addAll({
      'deityName': deityName,
      'category': category.name,
      'powerLevel': powerLevel.name,
      'recommendedDurationMinutes': recommendedDuration?.inMinutes,
      'recommendedRepetitions': recommendedRepetitions,
      'benefits': benefits,
      'pronunciation': pronunciation,
      'meaning': meaning,
      'audioUrl': audioUrl,
      'bestTime': bestTime.name,
      'prerequisites': prerequisites,
    });
    return baseJson;
  }

  /// Gets the formatted repetitions text
  String get repetitionsText {
    if (recommendedRepetitions == 108) return '1 Mala (108)';
    if (recommendedRepetitions == 1008) return '10 Malas (1008)';
    return '$recommendedRepetitions times';
  }
}

/// Model for inspirational quotes and teachings
class QuoteModel extends DevotionalContent {
  final String? author;
  final String? source;
  final QuoteCategory category;
  final String? contextualInfo;
  final List<String> relatedConcepts;
  final String? imageUrl;

  const QuoteModel({
    required super.id,
    required super.title,
    required super.content,
    super.translations = const {},
    super.tags = const [],
    required super.createdAt,
    super.updatedAt,
    super.isFeatured = false,
    super.isPremium = false,
    super.orderIndex = 0,
    this.author,
    this.source,
    this.category = QuoteCategory.inspirational,
    this.contextualInfo,
    this.relatedConcepts = const [],
    this.imageUrl,
  }) : super(type: ContentType.quote);

  factory QuoteModel.fromJson(Map<String, dynamic> json) {
    return QuoteModel(
      id: json['id'] as String,
      title: json['title'] as String,
      content: json['content'] as String,
      translations: Map<String, String>.from(json['translations'] ?? {}),
      tags: List<String>.from(json['tags'] ?? []),
      createdAt: DateTime.parse(json['createdAt']),
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt']) : null,
      isFeatured: json['isFeatured'] ?? false,
      isPremium: json['isPremium'] ?? false,
      orderIndex: json['orderIndex'] ?? 0,
      author: json['author'] as String?,
      source: json['source'] as String?,
      category: QuoteCategory.values.firstWhere(
        (e) => e.name == json['category'],
        orElse: () => QuoteCategory.inspirational,
      ),
      contextualInfo: json['contextualInfo'] as String?,
      relatedConcepts: List<String>.from(json['relatedConcepts'] ?? []),
      imageUrl: json['imageUrl'] as String?,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final baseJson = toBaseJson();
    baseJson.addAll({
      'author': author,
      'source': source,
      'category': category.name,
      'contextualInfo': contextualInfo,
      'relatedConcepts': relatedConcepts,
      'imageUrl': imageUrl,
    });
    return baseJson;
  }
}

/// Model for historical content and stories
class HistoryModel extends DevotionalContent {
  final HistoryCategory category;
  final HistoryPeriod period;
  final List<String> keyFigures;
  final List<String> locations;
  final String? summary;
  final List<String> sources;
  final List<String> imageUrls;
  final Map<String, String> additionalInfo;

  const HistoryModel({
    required super.id,
    required super.title,
    required super.content,
    super.translations = const {},
    super.tags = const [],
    required super.createdAt,
    super.updatedAt,
    super.isFeatured = false,
    super.isPremium = false,
    super.orderIndex = 0,
    this.category = HistoryCategory.mythology,
    this.period = HistoryPeriod.ancient,
    this.keyFigures = const [],
    this.locations = const [],
    this.summary,
    this.sources = const [],
    this.imageUrls = const [],
    this.additionalInfo = const {},
  }) : super(type: ContentType.history);

  factory HistoryModel.fromJson(Map<String, dynamic> json) {
    return HistoryModel(
      id: json['id'] as String,
      title: json['title'] as String,
      content: json['content'] as String,
      translations: Map<String, String>.from(json['translations'] ?? {}),
      tags: List<String>.from(json['tags'] ?? []),
      createdAt: DateTime.parse(json['createdAt']),
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt']) : null,
      isFeatured: json['isFeatured'] ?? false,
      isPremium: json['isPremium'] ?? false,
      orderIndex: json['orderIndex'] ?? 0,
      category: HistoryCategory.values.firstWhere(
        (e) => e.name == json['category'],
        orElse: () => HistoryCategory.mythology,
      ),
      period: HistoryPeriod.values.firstWhere(
        (e) => e.name == json['period'],
        orElse: () => HistoryPeriod.ancient,
      ),
      keyFigures: List<String>.from(json['keyFigures'] ?? []),
      locations: List<String>.from(json['locations'] ?? []),
      summary: json['summary'] as String?,
      sources: List<String>.from(json['sources'] ?? []),
      imageUrls: List<String>.from(json['imageUrls'] ?? []),
      additionalInfo: Map<String, String>.from(json['additionalInfo'] ?? {}),
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final baseJson = toBaseJson();
    baseJson.addAll({
      'category': category.name,
      'period': period.name,
      'keyFigures': keyFigures,
      'locations': locations,
      'summary': summary,
      'sources': sources,
      'imageUrls': imageUrls,
      'additionalInfo': additionalInfo,
    });
    return baseJson;
  }
}

/// Model for photo gallery content
class PhotoModel extends DevotionalContent {
  final String imageUrl;
  final String? thumbnailUrl;
  final PhotoCategory category;
  final String? photographer;
  final String? location;
  final DateTime? dateTaken;
  final String? description;
  final List<String> keywords;
  final ImageDimensions? dimensions;
  final String? copyright;

  const PhotoModel({
    required super.id,
    required super.title,
    required super.content,
    super.translations = const {},
    super.tags = const [],
    required super.createdAt,
    super.updatedAt,
    super.isFeatured = false,
    super.isPremium = false,
    super.orderIndex = 0,
    required this.imageUrl,
    this.thumbnailUrl,
    this.category = PhotoCategory.temple,
    this.photographer,
    this.location,
    this.dateTaken,
    this.description,
    this.keywords = const [],
    this.dimensions,
    this.copyright,
  }) : super(type: ContentType.photo);

  factory PhotoModel.fromJson(Map<String, dynamic> json) {
    return PhotoModel(
      id: json['id'] as String,
      title: json['title'] as String,
      content: json['content'] as String,
      translations: Map<String, String>.from(json['translations'] ?? {}),
      tags: List<String>.from(json['tags'] ?? []),
      createdAt: DateTime.parse(json['createdAt']),
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt']) : null,
      isFeatured: json['isFeatured'] ?? false,
      isPremium: json['isPremium'] ?? false,
      orderIndex: json['orderIndex'] ?? 0,
      imageUrl: json['imageUrl'] as String,
      thumbnailUrl: json['thumbnailUrl'] as String?,
      category: PhotoCategory.values.firstWhere(
        (e) => e.name == json['category'],
        orElse: () => PhotoCategory.temple,
      ),
      photographer: json['photographer'] as String?,
      location: json['location'] as String?,
      dateTaken: json['dateTaken'] != null ? DateTime.parse(json['dateTaken']) : null,
      description: json['description'] as String?,
      keywords: List<String>.from(json['keywords'] ?? []),
      dimensions: json['dimensions'] != null 
          ? ImageDimensions.fromJson(json['dimensions'])
          : null,
      copyright: json['copyright'] as String?,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final baseJson = toBaseJson();
    baseJson.addAll({
      'imageUrl': imageUrl,
      'thumbnailUrl': thumbnailUrl,
      'category': category.name,
      'photographer': photographer,
      'location': location,
      'dateTaken': dateTaken?.toIso8601String(),
      'description': description,
      'keywords': keywords,
      'dimensions': dimensions?.toJson(),
      'copyright': copyright,
    });
    return baseJson;
  }
}

/// Model for daily devotional content
class DailyDevotionalModel extends DevotionalContent {
  final DateTime date;
  final String? mantraOfDay;
  final String? quoteOfDay;
  final String? thoughtOfDay;
  final String? ritualSuggestion;
  final List<String> auspiciousTimes;
  final String? festival;
  final String? specialSignificance;
  final WeatherGreeting? weatherGreeting;

  const DailyDevotionalModel({
    required super.id,
    required super.title,
    required super.content,
    super.translations = const {},
    super.tags = const [],
    required super.createdAt,
    super.updatedAt,
    super.isFeatured = false,
    super.isPremium = false,
    super.orderIndex = 0,
    required this.date,
    this.mantraOfDay,
    this.quoteOfDay,
    this.thoughtOfDay,
    this.ritualSuggestion,
    this.auspiciousTimes = const [],
    this.festival,
    this.specialSignificance,
    this.weatherGreeting,
  }) : super(type: ContentType.daily);

  factory DailyDevotionalModel.fromJson(Map<String, dynamic> json) {
    return DailyDevotionalModel(
      id: json['id'] as String,
      title: json['title'] as String,
      content: json['content'] as String,
      translations: Map<String, String>.from(json['translations'] ?? {}),
      tags: List<String>.from(json['tags'] ?? []),
      createdAt: DateTime.parse(json['createdAt']),
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt']) : null,
      isFeatured: json['isFeatured'] ?? false,
      isPremium: json['isPremium'] ?? false,
      orderIndex: json['orderIndex'] ?? 0,
      date: DateTime.parse(json['date']),
      mantraOfDay: json['mantraOfDay'] as String?,
      quoteOfDay: json['quoteOfDay'] as String?,
      thoughtOfDay: json['thoughtOfDay'] as String?,
      ritualSuggestion: json['ritualSuggestion'] as String?,
      auspiciousTimes: List<String>.from(json['auspiciousTimes'] ?? []),
      festival: json['festival'] as String?,
      specialSignificance: json['specialSignificance'] as String?,
      weatherGreeting: json['weatherGreeting'] != null 
          ? WeatherGreeting.fromJson(json['weatherGreeting'])
          : null,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final baseJson = toBaseJson();
    baseJson.addAll({
      'date': date.toIso8601String(),
      'mantraOfDay': mantraOfDay,
      'quoteOfDay': quoteOfDay,
      'thoughtOfDay': thoughtOfDay,
      'ritualSuggestion': ritualSuggestion,
      'auspiciousTimes': auspiciousTimes,
      'festival': festival,
      'specialSignificance': specialSignificance,
      'weatherGreeting': weatherGreeting?.toJson(),
    });
    return baseJson;
  }

  /// Checks if this devotional is for today
  bool get isToday {
    final now = DateTime.now();
    return date.year == now.year && 
           date.month == now.month && 
           date.day == now.day;
  }
}

/// Supporting classes and enums

class ImageDimensions {
  final int width;
  final int height;

  const ImageDimensions({required this.width, required this.height});

  factory ImageDimensions.fromJson(Map<String, dynamic> json) {
    return ImageDimensions(
      width: json['width'] as int,
      height: json['height'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    return {'width': width, 'height': height};
  }

  double get aspectRatio => width / height;
}

class WeatherGreeting {
  final String greeting;
  final String weatherCondition;
  final String? spiritualMessage;

  const WeatherGreeting({
    required this.greeting,
    required this.weatherCondition,
    this.spiritualMessage,
  });

  factory WeatherGreeting.fromJson(Map<String, dynamic> json) {
    return WeatherGreeting(
      greeting: json['greeting'] as String,
      weatherCondition: json['weatherCondition'] as String,
      spiritualMessage: json['spiritualMessage'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'greeting': greeting,
      'weatherCondition': weatherCondition,
      'spiritualMessage': spiritualMessage,
    };
  }
}

/// Enums for content categorization

enum ContentType { mantra, quote, history, photo, daily, general }

enum MantraCategory { 
  ayyappa, 
  ganesha, 
  shiva, 
  universal, 
  protection, 
  prosperity, 
  peace, 
  healing, 
  general 
}

enum MantrapowerLevel { beginner, intermediate, advanced, master }

enum MantraTimming { 
  morning, 
  noon, 
  evening, 
  night, 
  dawn, 
  dusk, 
  anytime, 
  special 
}

enum QuoteCategory { 
  inspirational, 
  wisdom, 
  devotional, 
  teaching, 
  philosophical, 
  motivational 
}

enum HistoryCategory { 
  mythology, 
  temple, 
  tradition, 
  festival, 
  biography, 
  philosophy 
}

enum HistoryPeriod { 
  ancient, 
  classical, 
  medieval, 
  modern, 
  contemporary, 
  timeless 
}

enum PhotoCategory { 
  temple, 
  deity, 
  festival, 
  ritual, 
  nature, 
  devotee, 
  art, 
  architecture 
}

/// Extensions for better user experience

extension ContentTypeExtension on ContentType {
  String get displayName {
    switch (this) {
      case ContentType.mantra:
        return 'Mantras';
      case ContentType.quote:
        return 'Quotes';
      case ContentType.history:
        return 'History';
      case ContentType.photo:
        return 'Photos';
      case ContentType.daily:
        return 'Daily Devotional';
      case ContentType.general:
        return 'General';
    }
  }

  String get iconName {
    switch (this) {
      case ContentType.mantra:
        return 'mantra';
      case ContentType.quote:
        return 'quote';
      case ContentType.history:
        return 'history';
      case ContentType.photo:
        return 'photo';
      case ContentType.daily:
        return 'calendar';
      case ContentType.general:
        return 'content';
    }
  }
}

extension MantraCategoryExtension on MantraCategory {
  String get displayName {
    switch (this) {
      case MantraCategory.ayyappa:
        return 'Lord Ayyappa';
      case MantraCategory.ganesha:
        return 'Lord Ganesha';
      case MantraCategory.shiva:
        return 'Lord Shiva';
      case MantraCategory.universal:
        return 'Universal';
      case MantraCategory.protection:
        return 'Protection';
      case MantraCategory.prosperity:
        return 'Prosperity';
      case MantraCategory.peace:
        return 'Peace';
      case MantraCategory.healing:
        return 'Healing';
      case MantraCategory.general:
        return 'General';
    }
  }
}

/// Utility class for content filtering and management
class ContentFilter {
  final List<ContentType>? types;
  final List<String>? categories;
  final bool? isFeatured;
  final bool? isPremium;
  final String? searchQuery;
  final DateTime? dateFrom;
  final DateTime? dateTo;

  const ContentFilter({
    this.types,
    this.categories,
    this.isFeatured,
    this.isPremium,
    this.searchQuery,
    this.dateFrom,
    this.dateTo,
  });

  /// Applies filter to a list of devotional content
  List<T> apply<T extends DevotionalContent>(List<T> content) {
    return content.where((item) {
      // Type filter
      if (types != null && !types!.contains(item.type)) return false;

      // Featured filter
      if (isFeatured != null && item.isFeatured != isFeatured) return false;

      // Premium filter
      if (isPremium != null && item.isPremium != isPremium) return false;

      // Search query filter
      if (searchQuery != null && searchQuery!.isNotEmpty) {
        if (!item.matchesSearch(searchQuery!)) return false;
      }

      // Date range filter
      if (dateFrom != null && item.createdAt.isBefore(dateFrom!)) return false;
      if (dateTo != null && item.createdAt.isAfter(dateTo!)) return false;

      return true;
    }).toList();
  }
}
//models/festival_model.dart
/// Festival and auspicious dates model for Lord Ayyappa devotional app

class Festival {
  final String id;
  final String name;
  final String description;
  final DateTime date;
  final FestivalType type;
  final FestivalImportance importance;
  final String? location; // Sabarimala, Pandalam, etc.
  final List<String> rituals;
  final List<String> traditions;
  final Map<String, String> localizedNames; // language -> name
  final Map<String, String> localizedDescriptions; // language -> description
  final String? imageUrl;
  final List<String> relatedSongs;
  final bool isRecurring;
  final String? recurrencePattern; // for recurring festivals
  final Duration? duration; // multi-day festivals
  final List<String> observances;
  final String significance;

  const Festival({
    required this.id,
    required this.name,
    required this.description,
    required this.date,
    required this.type,
    this.importance = FestivalImportance.medium,
    this.location,
    this.rituals = const [],
    this.traditions = const [],
    this.localizedNames = const {},
    this.localizedDescriptions = const {},
    this.imageUrl,
    this.relatedSongs = const [],
    this.isRecurring = true,
    this.recurrencePattern,
    this.duration,
    this.observances = const [],
    this.significance = '',
  });

  /// Creates Festival from JSON
  factory Festival.fromJson(Map<String, dynamic> json) {
    try {
      return Festival(
        id: json['id']?.toString() ?? '',
        name: json['name']?.toString() ?? '',
        description: json['description']?.toString() ?? '',
        date: DateTime.parse(json['date']),
        type: FestivalType.values.firstWhere(
          (type) => type.name == json['type'],
          orElse: () => FestivalType.festival,
        ),
        importance: FestivalImportance.values.firstWhere(
          (imp) => imp.name == json['importance'],
          orElse: () => FestivalImportance.medium,
        ),
        location: json['location']?.toString(),
        rituals: _parseStringList(json['rituals']),
        traditions: _parseStringList(json['traditions']),
        localizedNames: _parseStringMap(json['localizedNames']),
        localizedDescriptions: _parseStringMap(json['localizedDescriptions']),
        imageUrl: json['imageUrl']?.toString(),
        relatedSongs: _parseStringList(json['relatedSongs']),
        isRecurring: json['isRecurring']?.toBool() ?? true,
        recurrencePattern: json['recurrencePattern']?.toString(),
        duration: json['duration'] != null 
            ? Duration(days: json['duration'].toInt())
            : null,
        observances: _parseStringList(json['observances']),
        significance: json['significance']?.toString() ?? '',
      );
    } catch (e) {
      throw FormatException('Invalid festival JSON format: $e');
    }
  }

  /// Converts Festival to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'date': date.toIso8601String(),
      'type': type.name,
      'importance': importance.name,
      'location': location,
      'rituals': rituals,
      'traditions': traditions,
      'localizedNames': localizedNames,
      'localizedDescriptions': localizedDescriptions,
      'imageUrl': imageUrl,
      'relatedSongs': relatedSongs,
      'isRecurring': isRecurring,
      'recurrencePattern': recurrencePattern,
      'duration': duration?.inDays,
      'observances': observances,
      'significance': significance,
    };
  }

  /// Creates a copy with updated properties
  Festival copyWith({
    String? id,
    String? name,
    String? description,
    DateTime? date,
    FestivalType? type,
    FestivalImportance? importance,
    String? location,
    List<String>? rituals,
    List<String>? traditions,
    Map<String, String>? localizedNames,
    Map<String, String>? localizedDescriptions,
    String? imageUrl,
    List<String>? relatedSongs,
    bool? isRecurring,
    String? recurrencePattern,
    Duration? duration,
    List<String>? observances,
    String? significance,
  }) {
    return Festival(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      date: date ?? this.date,
      type: type ?? this.type,
      importance: importance ?? this.importance,
      location: location ?? this.location,
      rituals: rituals ?? this.rituals,
      traditions: traditions ?? this.traditions,
      localizedNames: localizedNames ?? this.localizedNames,
      localizedDescriptions: localizedDescriptions ?? this.localizedDescriptions,
      imageUrl: imageUrl ?? this.imageUrl,
      relatedSongs: relatedSongs ?? this.relatedSongs,
      isRecurring: isRecurring ?? this.isRecurring,
      recurrencePattern: recurrencePattern ?? this.recurrencePattern,
      duration: duration ?? this.duration,
      observances: observances ?? this.observances,
      significance: significance ?? this.significance,
    );
  }

  /// Gets localized name for given language
  String getLocalizedName(String language) {
    return localizedNames[language] ?? name;
  }

  /// Gets localized description for given language
  String getLocalizedDescription(String language) {
    return localizedDescriptions[language] ?? description;
  }

  /// Checks if festival is today
  bool get isToday {
    final now = DateTime.now();
    return date.year == now.year && 
           date.month == now.month && 
           date.day == now.day;
  }

  /// Checks if festival is upcoming (within next 30 days)
  bool get isUpcoming {
    final now = DateTime.now();
    final difference = date.difference(now).inDays;
    return difference >= 0 && difference <= 30;
  }

  /// Gets days until festival
  int get daysUntil {
    final now = DateTime.now();
    return date.difference(now).inDays;
  }

  /// Gets festival status
  FestivalStatus get status {
    final now = DateTime.now();
    final difference = date.difference(now).inDays;
    
    if (difference < 0) return FestivalStatus.past;
    if (difference == 0) return FestivalStatus.today;
    if (difference <= 7) return FestivalStatus.thisWeek;
    if (difference <= 30) return FestivalStatus.thisMonth;
    return FestivalStatus.future;
  }

  /// Gets formatted date string
  String get formattedDate {
    return '${date.day}/${date.month}/${date.year}';
  }

  /// Gets formatted date with day name
  String get formattedDateWithDay {
    final weekdays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    final months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    
    return '${weekdays[date.weekday - 1]}, ${date.day} ${months[date.month - 1]} ${date.year}';
  }

  /// Checks if festival matches search query
  bool matchesSearch(String query) {
    if (query.isEmpty) return true;
    
    final searchQuery = query.toLowerCase();
    
    // Search in name, description, location
    if (name.toLowerCase().contains(searchQuery) ||
        description.toLowerCase().contains(searchQuery) ||
        (location?.toLowerCase().contains(searchQuery) ?? false)) {
      return true;
    }

    // Search in localized names and descriptions
    for (final localizedName in localizedNames.values) {
      if (localizedName.toLowerCase().contains(searchQuery)) {
        return true;
      }
    }

    for (final localizedDesc in localizedDescriptions.values) {
      if (localizedDesc.toLowerCase().contains(searchQuery)) {
        return true;
      }
    }

    // Search in rituals and traditions
    for (final ritual in rituals) {
      if (ritual.toLowerCase().contains(searchQuery)) {
        return true;
      }
    }

    for (final tradition in traditions) {
      if (tradition.toLowerCase().contains(searchQuery)) {
        return true;
      }
    }

    return false;
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Festival && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() {
    return 'Festival(id: $id, name: $name, date: $formattedDate)';
  }

  /// Helper methods for JSON parsing
  static List<String> _parseStringList(dynamic data) {
    if (data is List) {
      return data.map((item) => item.toString()).toList();
    }
    return [];
  }

  static Map<String, String> _parseStringMap(dynamic data) {
    if (data is Map<String, dynamic>) {
      return data.map((key, value) => MapEntry(key, value.toString()));
    }
    return {};
  }
}

/// Types of festivals and religious events
enum FestivalType {
  festival,     // Major festivals
  vratha,       // Fasting days
  pournami,     // Full moon days
  amavasya,     // New moon days
  ekadashi,     // Eleventh day of lunar cycle
  sankranti,    // Solar transitions
  jayanti,      // Birth anniversaries
  special,      // Special occasions
  pilgrimage,   // Pilgrimage related
}

/// Importance levels of festivals
enum FestivalImportance {
  low,
  medium,
  high,
  critical,
}

/// Status of festivals relative to current date
enum FestivalStatus {
  past,
  today,
  thisWeek,
  thisMonth,
  future,
}

/// Extensions for festival lists
extension FestivalListExtension on List<Festival> {
  /// Gets upcoming festivals
  List<Festival> getUpcoming() {
    final now = DateTime.now();
    return where((festival) => festival.date.isAfter(now))
        .toList()
        ..sort((a, b) => a.date.compareTo(b.date));
  }

  /// Gets today's festivals
  List<Festival> getToday() {
    return where((festival) => festival.isToday).toList();
  }

  /// Gets festivals this month
  List<Festival> getThisMonth() {
    final now = DateTime.now();
    return where((festival) => 
        festival.date.year == now.year && 
        festival.date.month == now.month
    ).toList();
  }

  /// Gets festivals by type
  List<Festival> getByType(FestivalType type) {
    return where((festival) => festival.type == type).toList();
  }

  /// Gets festivals by importance
  List<Festival> getByImportance(FestivalImportance importance) {
    return where((festival) => festival.importance == importance).toList();
  }

  /// Gets festivals by location
  List<Festival> getByLocation(String location) {
    return where((festival) => 
        festival.location?.toLowerCase() == location.toLowerCase()
    ).toList();
  }

  /// Filters festivals by search query
  List<Festival> filterBySearch(String query) {
    if (query.isEmpty) return this;
    return where((festival) => festival.matchesSearch(query)).toList();
  }

  /// Sorts festivals by date
  List<Festival> sortByDate({bool ascending = true}) {
    final sorted = List<Festival>.from(this);
    sorted.sort((a, b) => ascending 
        ? a.date.compareTo(b.date)
        : b.date.compareTo(a.date));
    return sorted;
  }

  /// Sorts festivals by importance
  List<Festival> sortByImportance() {
    final sorted = List<Festival>.from(this);
    sorted.sort((a, b) => b.importance.index.compareTo(a.importance.index));
    return sorted;
  }
}

/// Auspicious time model for daily timings
class AuspiciousTime {
  final String name;
  final String description;
  final DateTime startTime;
  final DateTime endTime;
  final AuspiciousTimeType type;
  final bool isGood; // true for auspicious, false for inauspicious

  const AuspiciousTime({
    required this.name,
    required this.description,
    required this.startTime,
    required this.endTime,
    required this.type,
    this.isGood = true,
  });

  /// Gets duration of the auspicious time
  Duration get duration => endTime.difference(startTime);

  /// Gets formatted time range
  String get timeRange {
    final startHour = startTime.hour.toString().padLeft(2, '0');
    final startMinute = startTime.minute.toString().padLeft(2, '0');
    final endHour = endTime.hour.toString().padLeft(2, '0');
    final endMinute = endTime.minute.toString().padLeft(2, '0');
    
    return '$startHour:$startMinute - $endHour:$endMinute';
  }

  /// Checks if current time is within this auspicious period
  bool get isActive {
    final now = DateTime.now();
    return now.isAfter(startTime) && now.isBefore(endTime);
  }
}

/// Types of auspicious times
enum AuspiciousTimeType {
  brahmamurhta,  // Early morning auspicious time
  sunrise,       // Sunrise time
  sunset,        // Sunset time
  noon,          // Noon time
  pradosham,     // Evening prayer time
  rahukalam,     // Inauspicious time
  yamagandam,    // Inauspicious time
  gulikai,       // Inauspicious time
}

/// Lunar calendar information
class LunarDay {
  final DateTime date;
  final String tithiName;
  final int tithiNumber; // 1-15 for each half of lunar month
  final LunarPhase phase;
  final String nakshatram; // Star constellation
  final bool isAuspicious;
  final List<String> specialObservances;

  const LunarDay({
    required this.date,
    required this.tithiName,
    required this.tithiNumber,
    required this.phase,
    required this.nakshatram,
    this.isAuspicious = true,
    this.specialObservances = const [],
  });

  /// Gets formatted tithi information
  String get formattedTithi => '$tithiName ($tithiNumber)';
}

/// Lunar phases
enum LunarPhase {
  newMoon,
  waxingCrescent,
  firstQuarter,
  waxingGibbous,
  fullMoon,
  waningGibbous,
  lastQuarter,
  waningCrescent,
}
//models/ritual_model.dart
/// Model class for Lord Ayyappa rituals and customs
/// 
/// This model represents various rituals, customs, and preparation guides
/// for Ayyappa devotion including Sabarimala pilgrimage preparations,
/// daily worship practices, and festival observances.

class RitualModel {
  final String id;
  final String title;
  final String description;
  final RitualCategory category;
  final RitualDifficulty difficulty;
  final Duration estimatedDuration;
  final List<String> steps;
  final List<String> materials;
  final List<String> mantras;
  final Map<String, String> translations; // language code -> translated content
  final String? imageUrl;
  final List<String> tips;
  final List<String> benefits;
  final bool isPopular;
  final bool isPremium;
  final DateTime? festivalDate;
  final List<String> tags;
  final int orderIndex;

  const RitualModel({
    required this.id,
    required this.title,
    required this.description,
    required this.category,
    this.difficulty = RitualDifficulty.beginner,
    this.estimatedDuration = const Duration(minutes: 30),
    this.steps = const [],
    this.materials = const [],
    this.mantras = const [],
    this.translations = const {},
    this.imageUrl,
    this.tips = const [],
    this.benefits = const [],
    this.isPopular = false,
    this.isPremium = false,
    this.festivalDate,
    this.tags = const [],
    this.orderIndex = 0,
  });

  /// Creates a RitualModel from JSON data
  factory RitualModel.fromJson(Map<String, dynamic> json) {
    return RitualModel(
      id: json['id'] as String,
      title: json['title'] as String,
      description: json['description'] as String,
      category: RitualCategory.values.firstWhere(
        (e) => e.name == json['category'],
        orElse: () => RitualCategory.daily,
      ),
      difficulty: RitualDifficulty.values.firstWhere(
        (e) => e.name == json['difficulty'],
        orElse: () => RitualDifficulty.beginner,
      ),
      estimatedDuration: Duration(minutes: json['estimatedDurationMinutes'] ?? 30),
      steps: List<String>.from(json['steps'] ?? []),
      materials: List<String>.from(json['materials'] ?? []),
      mantras: List<String>.from(json['mantras'] ?? []),
      translations: Map<String, String>.from(json['translations'] ?? {}),
      imageUrl: json['imageUrl'] as String?,
      tips: List<String>.from(json['tips'] ?? []),
      benefits: List<String>.from(json['benefits'] ?? []),
      isPopular: json['isPopular'] ?? false,
      isPremium: json['isPremium'] ?? false,
      festivalDate: json['festivalDate'] != null 
          ? DateTime.parse(json['festivalDate']) 
          : null,
      tags: List<String>.from(json['tags'] ?? []),
      orderIndex: json['orderIndex'] ?? 0,
    );
  }

  /// Converts RitualModel to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'description': description,
      'category': category.name,
      'difficulty': difficulty.name,
      'estimatedDurationMinutes': estimatedDuration.inMinutes,
      'steps': steps,
      'materials': materials,
      'mantras': mantras,
      'translations': translations,
      'imageUrl': imageUrl,
      'tips': tips,
      'benefits': benefits,
      'isPopular': isPopular,
      'isPremium': isPremium,
      'festivalDate': festivalDate?.toIso8601String(),
      'tags': tags,
      'orderIndex': orderIndex,
    };
  }

  /// Creates a copy of this ritual with updated fields
  RitualModel copyWith({
    String? id,
    String? title,
    String? description,
    RitualCategory? category,
    RitualDifficulty? difficulty,
    Duration? estimatedDuration,
    List<String>? steps,
    List<String>? materials,
    List<String>? mantras,
    Map<String, String>? translations,
    String? imageUrl,
    List<String>? tips,
    List<String>? benefits,
    bool? isPopular,
    bool? isPremium,
    DateTime? festivalDate,
    List<String>? tags,
    int? orderIndex,
  }) {
    return RitualModel(
      id: id ?? this.id,
      title: title ?? this.title,
      description: description ?? this.description,
      category: category ?? this.category,
      difficulty: difficulty ?? this.difficulty,
      estimatedDuration: estimatedDuration ?? this.estimatedDuration,
      steps: steps ?? this.steps,
      materials: materials ?? this.materials,
      mantras: mantras ?? this.mantras,
      translations: translations ?? this.translations,
      imageUrl: imageUrl ?? this.imageUrl,
      tips: tips ?? this.tips,
      benefits: benefits ?? this.benefits,
      isPopular: isPopular ?? this.isPopular,
      isPremium: isPremium ?? this.isPremium,
      festivalDate: festivalDate ?? this.festivalDate,
      tags: tags ?? this.tags,
      orderIndex: orderIndex ?? this.orderIndex,
    );
  }

  /// Gets the translated title for the given language code
  String getTranslatedTitle(String languageCode) {
    return translations['${languageCode}_title'] ?? title;
  }

  /// Gets the translated description for the given language code
  String getTranslatedDescription(String languageCode) {
    return translations['${languageCode}_description'] ?? description;
  }

  /// Gets the translated steps for the given language code
  List<String> getTranslatedSteps(String languageCode) {
    final translatedStepsJson = translations['${languageCode}_steps'];
    if (translatedStepsJson != null) {
      try {
        final List<dynamic> decoded = List<dynamic>.from(
          Uri.decodeComponent(translatedStepsJson).split('|')
        );
        return decoded.map((e) => e.toString()).toList();
      } catch (e) {
        return steps;
      }
    }
    return steps;
  }

  /// Gets the formatted duration string
  String get durationText {
    if (estimatedDuration.inHours > 0) {
      return '${estimatedDuration.inHours}h ${estimatedDuration.inMinutes % 60}m';
    }
    return '${estimatedDuration.inMinutes}m';
  }

  /// Gets the difficulty display text
  String get difficultyText {
    switch (difficulty) {
      case RitualDifficulty.beginner:
        return 'Beginner';
      case RitualDifficulty.intermediate:
        return 'Intermediate';
      case RitualDifficulty.advanced:
        return 'Advanced';
      case RitualDifficulty.expert:
        return 'Expert';
    }
  }

  /// Gets the category display text
  String get categoryText {
    switch (category) {
      case RitualCategory.daily:
        return 'Daily Worship';
      case RitualCategory.sabarimala:
        return 'Sabarimala Pilgrimage';
      case RitualCategory.festival:
        return 'Festival Observance';
      case RitualCategory.special:
        return 'Special Occasions';
      case RitualCategory.preparation:
        return 'Preparation';
      case RitualCategory.meditation:
        return 'Meditation & Prayer';
    }
  }

  /// Checks if this ritual matches the search query
  bool matchesSearch(String query) {
    final searchQuery = query.toLowerCase();
    return title.toLowerCase().contains(searchQuery) ||
           description.toLowerCase().contains(searchQuery) ||
           tags.any((tag) => tag.toLowerCase().contains(searchQuery)) ||
           categoryText.toLowerCase().contains(searchQuery) ||
           steps.any((step) => step.toLowerCase().contains(searchQuery));
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is RitualModel && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() {
    return 'RitualModel(id: $id, title: $title, category: $category)';
  }
}

/// Enum for ritual categories
enum RitualCategory {
  daily,        // Daily worship practices
  sabarimala,   // Sabarimala pilgrimage specific
  festival,     // Festival observances
  special,      // Special occasions
  preparation,  // Preparation rituals
  meditation,   // Meditation and prayer practices
}

/// Enum for ritual difficulty levels
enum RitualDifficulty {
  beginner,     // Simple, basic rituals
  intermediate, // Moderate complexity
  advanced,     // Complex rituals requiring experience
  expert,       // Highly complex, traditional rituals
}

/// Extension to get user-friendly names for categories
extension RitualCategoryExtension on RitualCategory {
  String get displayName {
    switch (this) {
      case RitualCategory.daily:
        return 'Daily Worship';
      case RitualCategory.sabarimala:
        return 'Sabarimala Pilgrimage';
      case RitualCategory.festival:
        return 'Festival Observance';
      case RitualCategory.special:
        return 'Special Occasions';
      case RitualCategory.preparation:
        return 'Preparation Rituals';
      case RitualCategory.meditation:
        return 'Meditation & Prayer';
    }
  }

  String get iconName {
    switch (this) {
      case RitualCategory.daily:
        return 'daily_worship';
      case RitualCategory.sabarimala:
        return 'temple';
      case RitualCategory.festival:
        return 'festival';
      case RitualCategory.special:
        return 'special_event';
      case RitualCategory.preparation:
        return 'preparation';
      case RitualCategory.meditation:
        return 'meditation';
    }
  }
}

/// Extension to get user-friendly names for difficulties
extension RitualDifficultyExtension on RitualDifficulty {
  String get displayName {
    switch (this) {
      case RitualDifficulty.beginner:
        return 'Beginner';
      case RitualDifficulty.intermediate:
        return 'Intermediate';
      case RitualDifficulty.advanced:
        return 'Advanced';
      case RitualDifficulty.expert:
        return 'Expert';
    }
  }

  String get description {
    switch (this) {
      case RitualDifficulty.beginner:
        return 'Simple practices for new devotees';
      case RitualDifficulty.intermediate:
        return 'Moderate complexity, some experience helpful';
      case RitualDifficulty.advanced:
        return 'Complex rituals requiring dedication';
      case RitualDifficulty.expert:
        return 'Traditional practices for experienced devotees';
    }
  }
}

/// Helper class for ritual filtering and sorting
class RitualFilter {
  final List<RitualCategory>? categories;
  final List<RitualDifficulty>? difficulties;
  final bool? isPopular;
  final bool? isPremium;
  final String? searchQuery;
  final RitualSortBy sortBy;
  final bool ascending;

  const RitualFilter({
    this.categories,
    this.difficulties,
    this.isPopular,
    this.isPremium,
    this.searchQuery,
    this.sortBy = RitualSortBy.order,
    this.ascending = true,
  });

  /// Applies the filter to a list of rituals
  List<RitualModel> apply(List<RitualModel> rituals) {
    var filtered = rituals.where((ritual) {
      // Category filter
      if (categories != null && categories!.isNotEmpty) {
        if (!categories!.contains(ritual.category)) return false;
      }

      // Difficulty filter
      if (difficulties != null && difficulties!.isNotEmpty) {
        if (!difficulties!.contains(ritual.difficulty)) return false;
      }

      // Popular filter
      if (isPopular != null && ritual.isPopular != isPopular) return false;

      // Premium filter
      if (isPremium != null && ritual.isPremium != isPremium) return false;

      // Search query filter
      if (searchQuery != null && searchQuery!.isNotEmpty) {
        if (!ritual.matchesSearch(searchQuery!)) return false;
      }

      return true;
    }).toList();

    // Apply sorting
    filtered.sort((a, b) {
      int comparison;
      switch (sortBy) {
        case RitualSortBy.title:
          comparison = a.title.compareTo(b.title);
          break;
        case RitualSortBy.category:
          comparison = a.category.index.compareTo(b.category.index);
          break;
        case RitualSortBy.difficulty:
          comparison = a.difficulty.index.compareTo(b.difficulty.index);
          break;
        case RitualSortBy.duration:
          comparison = a.estimatedDuration.compareTo(b.estimatedDuration);
          break;
        case RitualSortBy.order:
        default:
          comparison = a.orderIndex.compareTo(b.orderIndex);
          break;
      }
      return ascending ? comparison : -comparison;
    });

    return filtered;
  }
}

/// Enum for ritual sorting options
enum RitualSortBy {
  title,
  category,
  difficulty,
  duration,
  order,
}
//models/song_model.dart
/// Song data model for Lord Ayyappa devotional songs
/// Supports multilingual lyrics and metadata

class Song {
  final String id;
  final String title;
  final String singer;
  final String writer;
  final String iconType; // 'music' or 'god'
  final Map<String, List<String>> lyrics; // language -> list of lines
  final String? audioUrl;
  final String? description;
  final int duration; // in seconds
  final String category; // 'devotional', 'aarti', 'bhajan', etc.
  final List<String> tags;
  final DateTime createdAt;
  final bool isPopular;
  final int playCount;
  final double rating;

  const Song({
    required this.id,
    required this.title,
    required this.singer,
    required this.writer,
    required this.iconType,
    required this.lyrics,
    this.audioUrl,
    this.description,
    this.duration = 0,
    this.category = 'devotional',
    this.tags = const [],
    required this.createdAt,
    this.isPopular = false,
    this.playCount = 0,
    this.rating = 0.0,
  });

  /// Creates a Song from JSON data
  factory Song.fromJson(Map<String, dynamic> json) {
    try {
      return Song(
        id: json['id']?.toString() ?? '',
        title: json['title']?.toString() ?? '',
        singer: json['singer']?.toString() ?? '',
        writer: json['writer']?.toString() ?? '',
        iconType: json['iconType']?.toString() ?? 'music',
        lyrics: _parseLyrics(json['lyrics']),
        audioUrl: json['audioUrl']?.toString(),
        description: json['description']?.toString(),
        duration: json['duration']?.toInt() ?? 0,
        category: json['category']?.toString() ?? 'devotional',
        tags: _parseTags(json['tags']),
        createdAt: json['createdAt'] != null 
            ? DateTime.tryParse(json['createdAt'].toString()) ?? DateTime.now()
            : DateTime.now(),
        isPopular: json['isPopular']?.toBool() ?? false,
        playCount: json['playCount']?.toInt() ?? 0,
        rating: json['rating']?.toDouble() ?? 0.0,
      );
    } catch (e) {
      throw FormatException('Invalid song JSON format: $e');
    }
  }

  /// Converts Song to JSON format
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'singer': singer,
      'writer': writer,
      'iconType': iconType,
      'lyrics': lyrics,
      'audioUrl': audioUrl,
      'description': description,
      'duration': duration,
      'category': category,
      'tags': tags,
      'createdAt': createdAt.toIso8601String(),
      'isPopular': isPopular,
      'playCount': playCount,
      'rating': rating,
    };
  }

  /// Creates a copy of the song with updated properties
  Song copyWith({
    String? id,
    String? title,
    String? singer,
    String? writer,
    String? iconType,
    Map<String, List<String>>? lyrics,
    String? audioUrl,
    String? description,
    int? duration,
    String? category,
    List<String>? tags,
    DateTime? createdAt,
    bool? isPopular,
    int? playCount,
    double? rating,
  }) {
    return Song(
      id: id ?? this.id,
      title: title ?? this.title,
      singer: singer ?? this.singer,
      writer: writer ?? this.writer,
      iconType: iconType ?? this.iconType,
      lyrics: lyrics ?? this.lyrics,
      audioUrl: audioUrl ?? this.audioUrl,
      description: description ?? this.description,
      duration: duration ?? this.duration,
      category: category ?? this.category,
      tags: tags ?? this.tags,
      createdAt: createdAt ?? this.createdAt,
      isPopular: isPopular ?? this.isPopular,
      playCount: playCount ?? this.playCount,
      rating: rating ?? this.rating,
    );
  }

  /// Gets lyrics for a specific language
  List<String> getLyricsForLanguage(String language) {
    return lyrics[language] ?? [];
  }

  /// Gets available languages for this song
  List<String> getAvailableLanguages() {
    return lyrics.keys.toList();
  }

  /// Checks if song has lyrics in given language
  bool hasLanguage(String language) {
    return lyrics.containsKey(language) && lyrics[language]!.isNotEmpty;
  }

  /// Gets formatted duration string (mm:ss)
  String get formattedDuration {
    if (duration <= 0) return '--:--';
    final minutes = duration ~/ 60;
    final seconds = duration % 60;
    return '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
  }

  /// Checks if song matches search query
  bool matchesSearch(String query) {
    if (query.isEmpty) return true;
    
    final searchQuery = query.toLowerCase();
    
    // Search in title, singer, writer
    if (title.toLowerCase().contains(searchQuery) ||
        singer.toLowerCase().contains(searchQuery) ||
        writer.toLowerCase().contains(searchQuery)) {
      return true;
    }

    // Search in lyrics (all languages)
    for (final lyricsLines in lyrics.values) {
      for (final line in lyricsLines) {
        if (line.toLowerCase().contains(searchQuery)) {
          return true;
        }
      }
    }

    // Search in tags and category
    if (category.toLowerCase().contains(searchQuery)) {
      return true;
    }

    for (final tag in tags) {
      if (tag.toLowerCase().contains(searchQuery)) {
        return true;
      }
    }

    return false;
  }

  /// Gets search highlight matches
  List<String> getSearchMatches(String query) {
    final matches = <String>[];
    if (query.isEmpty) return matches;

    final searchQuery = query.toLowerCase();

    if (title.toLowerCase().contains(searchQuery)) {
      matches.add('Title: $title');
    }
    if (singer.toLowerCase().contains(searchQuery)) {
      matches.add('Singer: $singer');
    }
    if (writer.toLowerCase().contains(searchQuery)) {
      matches.add('Writer: $writer');
    }

    return matches;
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Song && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() {
    return 'Song(id: $id, title: $title, singer: $singer)';
  }

  /// Helper method to parse lyrics from JSON
  static Map<String, List<String>> _parseLyrics(dynamic lyricsData) {
    final Map<String, List<String>> result = {};
    
    if (lyricsData is Map<String, dynamic>) {
      lyricsData.forEach((language, lines) {
        if (lines is List) {
          result[language] = lines.map((line) => line.toString()).toList();
        } else if (lines is String) {
          result[language] = lines.split('\n').where((line) => line.trim().isNotEmpty).toList();
        }
      });
    }
    
    return result;
  }

  /// Helper method to parse tags from JSON
  static List<String> _parseTags(dynamic tagsData) {
    if (tagsData is List) {
      return tagsData.map((tag) => tag.toString()).toList();
    } else if (tagsData is String) {
      return tagsData.split(',').map((tag) => tag.trim()).where((tag) => tag.isNotEmpty).toList();
    }
    return [];
  }
}

/// Enum for sort options
enum SongSortBy {
  title,
  singer,
  writer,
  duration,
  rating,
  playCount,
  createdAt,
}

/// Enum for sort order
enum SortOrder {
  ascending,
  descending,
}

/// Extension for sort functionality
extension SongListExtension on List<Song> {
  /// Sorts the song list by given criteria
  List<Song> sortBy(SongSortBy sortBy, SortOrder order) {
    final sortedList = List<Song>.from(this);
    
    switch (sortBy) {
      case SongSortBy.title:
        sortedList.sort((a, b) => a.title.compareTo(b.title));
        break;
      case SongSortBy.singer:
        sortedList.sort((a, b) => a.singer.compareTo(b.singer));
        break;
      case SongSortBy.writer:
        sortedList.sort((a, b) => a.writer.compareTo(b.writer));
        break;
      case SongSortBy.duration:
        sortedList.sort((a, b) => a.duration.compareTo(b.duration));
        break;
      case SongSortBy.rating:
        sortedList.sort((a, b) => a.rating.compareTo(b.rating));
        break;
      case SongSortBy.playCount:
        sortedList.sort((a, b) => a.playCount.compareTo(b.playCount));
        break;
      case SongSortBy.createdAt:
        sortedList.sort((a, b) => a.createdAt.compareTo(b.createdAt));
        break;
    }

    if (order == SortOrder.descending) {
      return sortedList.reversed.toList();
    }
    
    return sortedList;
  }

  /// Filters songs by search query
  List<Song> filterBySearch(String query) {
    if (query.isEmpty) return this;
    return where((song) => song.matchesSearch(query)).toList();
  }

  /// Filters songs by category
  List<Song> filterByCategory(String category) {
    if (category.isEmpty || category.toLowerCase() == 'all') return this;
    return where((song) => song.category.toLowerCase() == category.toLowerCase()).toList();
  }

  /// Gets popular songs
  List<Song> getPopular() {
    return where((song) => song.isPopular).toList();
  }

  /// Gets recently played songs (by play count)
  List<Song> getRecentlyPlayed() {
    return where((song) => song.playCount > 0)
        .toList()
        ..sort((a, b) => b.playCount.compareTo(a.playCount));
  }
}
//models/user_model.dart
import 'package:flutter/material.dart';

/// Model class for user profile and devotional journey tracking
///
/// This model represents the user's spiritual journey, preferences, achievements,
/// and progress in the Lord Ayyappa devotional app. It includes personalization
/// settings, learning progress, and devotional milestones.

class UserModel {
  final String id;
  final String name;
  final String? email;
  final String? profileImageUrl;
  final DateTime createdAt;
  final DateTime lastActiveAt;
  final UserPreferences preferences;
  final DevotionalJourney journey;
  final List<Achievement> achievements;
  final UserStats stats;
  final List<String> favoriteContentIds;
  final Map<String, dynamic> customData;

  const UserModel({
    required this.id,
    required this.name,
    this.email,
    this.profileImageUrl,
    required this.createdAt,
    required this.lastActiveAt,
    required this.preferences,
    required this.journey,
    this.achievements = const [],
    required this.stats,
    this.favoriteContentIds = const [],
    this.customData = const {},
  });

  /// Creates a UserModel from JSON data
  factory UserModel.fromJson(Map<String, dynamic> json) {
    return UserModel(
      id: json['id'] as String,
      name: json['name'] as String,
      email: json['email'] as String?,
      profileImageUrl: json['profileImageUrl'] as String?,
      createdAt: DateTime.parse(json['createdAt']),
      lastActiveAt: DateTime.parse(json['lastActiveAt']),
      preferences: UserPreferences.fromJson(json['preferences'] ?? {}),
      journey: DevotionalJourney.fromJson(json['journey'] ?? {}),
      achievements: (json['achievements'] as List<dynamic>?)
              ?.map((e) => Achievement.fromJson(e))
              .toList() ??
          [],
      stats: UserStats.fromJson(json['stats'] ?? {}),
      favoriteContentIds: List<String>.from(json['favoriteContentIds'] ?? []),
      customData: Map<String, dynamic>.from(json['customData'] ?? {}),
    );
  }

  /// Converts UserModel to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'email': email,
      'profileImageUrl': profileImageUrl,
      'createdAt': createdAt.toIso8601String(),
      'lastActiveAt': lastActiveAt.toIso8601String(),
      'preferences': preferences.toJson(),
      'journey': journey.toJson(),
      'achievements': achievements.map((e) => e.toJson()).toList(),
      'stats': stats.toJson(),
      'favoriteContentIds': favoriteContentIds,
      'customData': customData,
    };
  }

  /// Creates a copy of this user with updated fields
  UserModel copyWith({
    String? id,
    String? name,
    String? email,
    String? profileImageUrl,
    DateTime? createdAt,
    DateTime? lastActiveAt,
    UserPreferences? preferences,
    DevotionalJourney? journey,
    List<Achievement>? achievements,
    UserStats? stats,
    List<String>? favoriteContentIds,
    Map<String, dynamic>? customData,
  }) {
    return UserModel(
      id: id ?? this.id,
      name: name ?? this.name,
      email: email ?? this.email,
      profileImageUrl: profileImageUrl ?? this.profileImageUrl,
      createdAt: createdAt ?? this.createdAt,
      lastActiveAt: lastActiveAt ?? this.lastActiveAt,
      preferences: preferences ?? this.preferences,
      journey: journey ?? this.journey,
      achievements: achievements ?? this.achievements,
      stats: stats ?? this.stats,
      favoriteContentIds: favoriteContentIds ?? this.favoriteContentIds,
      customData: customData ?? this.customData,
    );
  }

  /// Gets the user's current devotional level based on progress
  DevotionalLevel get currentLevel {
    final totalDays = journey.totalDaysActive;
    if (totalDays >= 365) return DevotionalLevel.master;
    if (totalDays >= 180) return DevotionalLevel.advanced;
    if (totalDays >= 60) return DevotionalLevel.intermediate;
    if (totalDays >= 15) return DevotionalLevel.novice;
    return DevotionalLevel.beginner;
  }

  /// Checks if the user has a specific achievement
  bool hasAchievement(String achievementId) {
    return achievements.any((achievement) => achievement.id == achievementId);
  }

  /// Gets the user's streak information
  StreakInfo get currentStreak {
    return journey.currentStreak;
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is UserModel && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() {
    return 'UserModel(id: $id, name: $name, level: ${currentLevel.name})';
  }
}

/// User preferences and settings
class UserPreferences {
  final String preferredLanguage;
  final AppTheme theme;
  final ReadingMode readingMode;
  final double fontSize;
  final bool notificationsEnabled;
  final bool dailyReminderEnabled;
  final TimeOfDay? dailyReminderTime;
  final bool festivalNotificationsEnabled;
  final bool soundEnabled;
  final bool autoPlayEnabled;
  final bool offlineDownloadsEnabled;
  final Map<String, bool> contentTypePreferences;

  const UserPreferences({
    this.preferredLanguage = 'en',
    this.theme = AppTheme.system,
    this.readingMode = ReadingMode.normal,
    this.fontSize = 16.0,
    this.notificationsEnabled = true,
    this.dailyReminderEnabled = true,
    this.dailyReminderTime,
    this.festivalNotificationsEnabled = true,
    this.soundEnabled = true,
    this.autoPlayEnabled = false,
    this.offlineDownloadsEnabled = true,
    this.contentTypePreferences = const {},
  });

  factory UserPreferences.fromJson(Map<String, dynamic> json) {
    return UserPreferences(
      preferredLanguage: json['preferredLanguage'] ?? 'en',
      theme: AppTheme.values.firstWhere(
        (e) => e.name == json['theme'],
        orElse: () => AppTheme.system,
      ),
      readingMode: ReadingMode.values.firstWhere(
        (e) => e.name == json['readingMode'],
        orElse: () => ReadingMode.normal,
      ),
      fontSize: (json['fontSize'] ?? 16.0).toDouble(),
      notificationsEnabled: json['notificationsEnabled'] ?? true,
      dailyReminderEnabled: json['dailyReminderEnabled'] ?? true,
      dailyReminderTime: json['dailyReminderTime'] != null
          ? TimeOfDayFromJson.fromJson(json['dailyReminderTime'])
          : null,
      festivalNotificationsEnabled:
          json['festivalNotificationsEnabled'] ?? true,
      soundEnabled: json['soundEnabled'] ?? true,
      autoPlayEnabled: json['autoPlayEnabled'] ?? false,
      offlineDownloadsEnabled: json['offlineDownloadsEnabled'] ?? true,
      contentTypePreferences:
          Map<String, bool>.from(json['contentTypePreferences'] ?? {}),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'preferredLanguage': preferredLanguage,
      'theme': theme.name,
      'readingMode': readingMode.name,
      'fontSize': fontSize,
      'notificationsEnabled': notificationsEnabled,
      'dailyReminderEnabled': dailyReminderEnabled,
      'dailyReminderTime': dailyReminderTime?.toJson(),
      'festivalNotificationsEnabled': festivalNotificationsEnabled,
      'soundEnabled': soundEnabled,
      'autoPlayEnabled': autoPlayEnabled,
      'offlineDownloadsEnabled': offlineDownloadsEnabled,
      'contentTypePreferences': contentTypePreferences,
    };
  }

  UserPreferences copyWith({
    String? preferredLanguage,
    AppTheme? theme,
    ReadingMode? readingMode,
    double? fontSize,
    bool? notificationsEnabled,
    bool? dailyReminderEnabled,
    TimeOfDay? dailyReminderTime,
    bool? festivalNotificationsEnabled,
    bool? soundEnabled,
    bool? autoPlayEnabled,
    bool? offlineDownloadsEnabled,
    Map<String, bool>? contentTypePreferences,
  }) {
    return UserPreferences(
      preferredLanguage: preferredLanguage ?? this.preferredLanguage,
      theme: theme ?? this.theme,
      readingMode: readingMode ?? this.readingMode,
      fontSize: fontSize ?? this.fontSize,
      notificationsEnabled: notificationsEnabled ?? this.notificationsEnabled,
      dailyReminderEnabled: dailyReminderEnabled ?? this.dailyReminderEnabled,
      dailyReminderTime: dailyReminderTime ?? this.dailyReminderTime,
      festivalNotificationsEnabled:
          festivalNotificationsEnabled ?? this.festivalNotificationsEnabled,
      soundEnabled: soundEnabled ?? this.soundEnabled,
      autoPlayEnabled: autoPlayEnabled ?? this.autoPlayEnabled,
      offlineDownloadsEnabled:
          offlineDownloadsEnabled ?? this.offlineDownloadsEnabled,
      contentTypePreferences:
          contentTypePreferences ?? this.contentTypePreferences,
    );
  }
}

/// User's devotional journey tracking
class DevotionalJourney {
  final DateTime startDate;
  final int totalDaysActive;
  final int consecutiveDaysStreak;
  final int longestStreak;
  final StreakInfo currentStreak;
  final Map<String, int> activityCounts;
  final List<String> completedRituals;
  final List<String> learnedSongs;
  final Map<String, DateTime> milestones;
  final double progressPercentage;

  const DevotionalJourney({
    required this.startDate,
    this.totalDaysActive = 0,
    this.consecutiveDaysStreak = 0,
    this.longestStreak = 0,
    required this.currentStreak,
    this.activityCounts = const {},
    this.completedRituals = const [],
    this.learnedSongs = const [],
    this.milestones = const {},
    this.progressPercentage = 0.0,
  });

  factory DevotionalJourney.fromJson(Map<String, dynamic> json) {
    return DevotionalJourney(
      startDate:
          DateTime.parse(json['startDate'] ?? DateTime.now().toIso8601String()),
      totalDaysActive: json['totalDaysActive'] ?? 0,
      consecutiveDaysStreak: json['consecutiveDaysStreak'] ?? 0,
      longestStreak: json['longestStreak'] ?? 0,
      currentStreak: StreakInfo.fromJson(json['currentStreak'] ?? {}),
      activityCounts: Map<String, int>.from(json['activityCounts'] ?? {}),
      completedRituals: List<String>.from(json['completedRituals'] ?? []),
      learnedSongs: List<String>.from(json['learnedSongs'] ?? []),
      milestones: Map<String, DateTime>.from((json['milestones'] ?? {})
          .map((k, v) => MapEntry(k, DateTime.parse(v)))),
      progressPercentage: (json['progressPercentage'] ?? 0.0).toDouble(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'startDate': startDate.toIso8601String(),
      'totalDaysActive': totalDaysActive,
      'consecutiveDaysStreak': consecutiveDaysStreak,
      'longestStreak': longestStreak,
      'currentStreak': currentStreak.toJson(),
      'activityCounts': activityCounts,
      'completedRituals': completedRituals,
      'learnedSongs': learnedSongs,
      'milestones': milestones.map((k, v) => MapEntry(k, v.toIso8601String())),
      'progressPercentage': progressPercentage,
    };
  }

  /// Gets the number of days since the journey started
  int get daysSinceStart {
    return DateTime.now().difference(startDate).inDays;
  }

  /// Checks if the user was active today
  bool get isActiveToday {
    return currentStreak.lastActiveDate.isToday;
  }
}

/// Streak information tracking
class StreakInfo {
  final int count;
  final DateTime startDate;
  final DateTime lastActiveDate;
  final bool isActive;

  const StreakInfo({
    this.count = 0,
    required this.startDate,
    required this.lastActiveDate,
    this.isActive = false,
  });

  factory StreakInfo.fromJson(Map<String, dynamic> json) {
    return StreakInfo(
      count: json['count'] ?? 0,
      startDate:
          DateTime.parse(json['startDate'] ?? DateTime.now().toIso8601String()),
      lastActiveDate: DateTime.parse(
          json['lastActiveDate'] ?? DateTime.now().toIso8601String()),
      isActive: json['isActive'] ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'count': count,
      'startDate': startDate.toIso8601String(),
      'lastActiveDate': lastActiveDate.toIso8601String(),
      'isActive': isActive,
    };
  }

  /// Gets the streak duration in days
  int get durationInDays {
    return lastActiveDate.difference(startDate).inDays + 1;
  }
}

/// User achievement system
class Achievement {
  final String id;
  final String title;
  final String description;
  final AchievementType type;
  final String iconName;
  final DateTime unlockedAt;
  final int progress;
  final int target;
  final bool isUnlocked;
  final Map<String, String> translations;

  const Achievement({
    required this.id,
    required this.title,
    required this.description,
    required this.type,
    required this.iconName,
    required this.unlockedAt,
    this.progress = 0,
    this.target = 1,
    this.isUnlocked = false,
    this.translations = const {},
  });

  factory Achievement.fromJson(Map<String, dynamic> json) {
    return Achievement(
      id: json['id'] as String,
      title: json['title'] as String,
      description: json['description'] as String,
      type: AchievementType.values.firstWhere(
        (e) => e.name == json['type'],
        orElse: () => AchievementType.general,
      ),
      iconName: json['iconName'] as String,
      unlockedAt: DateTime.parse(json['unlockedAt']),
      progress: json['progress'] ?? 0,
      target: json['target'] ?? 1,
      isUnlocked: json['isUnlocked'] ?? false,
      translations: Map<String, String>.from(json['translations'] ?? {}),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'description': description,
      'type': type.name,
      'iconName': iconName,
      'unlockedAt': unlockedAt.toIso8601String(),
      'progress': progress,
      'target': target,
      'isUnlocked': isUnlocked,
      'translations': translations,
    };
  }

  /// Gets the progress percentage
  double get progressPercentage {
    return target > 0 ? (progress / target).clamp(0.0, 1.0) : 0.0;
  }
}

/// User statistics tracking
class UserStats {
  final int totalSongsPlayed;
  final int totalRitualsCompleted;
  final int totalMantrasRecited;
  final Duration totalListeningTime;
  final int favoriteItemsCount;
  final Map<String, int> categoryEngagement;
  final Map<String, int> languageUsage;
  final DateTime lastUpdated;

  const UserStats({
    this.totalSongsPlayed = 0,
    this.totalRitualsCompleted = 0,
    this.totalMantrasRecited = 0,
    this.totalListeningTime = Duration.zero,
    this.favoriteItemsCount = 0,
    this.categoryEngagement = const {},
    this.languageUsage = const {},
    required this.lastUpdated,
  });

  factory UserStats.fromJson(Map<String, dynamic> json) {
    return UserStats(
      totalSongsPlayed: json['totalSongsPlayed'] ?? 0,
      totalRitualsCompleted: json['totalRitualsCompleted'] ?? 0,
      totalMantrasRecited: json['totalMantrasRecited'] ?? 0,
      totalListeningTime:
          Duration(seconds: json['totalListeningTimeSeconds'] ?? 0),
      favoriteItemsCount: json['favoriteItemsCount'] ?? 0,
      categoryEngagement:
          Map<String, int>.from(json['categoryEngagement'] ?? {}),
      languageUsage: Map<String, int>.from(json['languageUsage'] ?? {}),
      lastUpdated: DateTime.parse(
          json['lastUpdated'] ?? DateTime.now().toIso8601String()),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'totalSongsPlayed': totalSongsPlayed,
      'totalRitualsCompleted': totalRitualsCompleted,
      'totalMantrasRecited': totalMantrasRecited,
      'totalListeningTimeSeconds': totalListeningTime.inSeconds,
      'favoriteItemsCount': favoriteItemsCount,
      'categoryEngagement': categoryEngagement,
      'languageUsage': languageUsage,
      'lastUpdated': lastUpdated.toIso8601String(),
    };
  }
}

/// Enums for user system

enum AppTheme { light, dark, sepia, system }

enum ReadingMode { normal, night, sepia, highContrast }

enum DevotionalLevel { beginner, novice, intermediate, advanced, master }

enum AchievementType {
  streak,
  learning,
  ritual,
  listening,
  sharing,
  milestone,
  festival,
  general
}

/// Extensions for better user experience

extension DevotionalLevelExtension on DevotionalLevel {
  String get displayName {
    switch (this) {
      case DevotionalLevel.beginner:
        return 'New Devotee';
      case DevotionalLevel.novice:
        return 'Learning Devotee';
      case DevotionalLevel.intermediate:
        return 'Practicing Devotee';
      case DevotionalLevel.advanced:
        return 'Dedicated Devotee';
      case DevotionalLevel.master:
        return 'Master Devotee';
    }
  }

  String get description {
    switch (this) {
      case DevotionalLevel.beginner:
        return 'Just started your spiritual journey';
      case DevotionalLevel.novice:
        return 'Learning the basics of devotion';
      case DevotionalLevel.intermediate:
        return 'Regularly practicing devotional activities';
      case DevotionalLevel.advanced:
        return 'Deeply committed to spiritual growth';
      case DevotionalLevel.master:
        return 'Exemplary devotee with consistent practice';
    }
  }

  int get requiredDays {
    switch (this) {
      case DevotionalLevel.beginner:
        return 0;
      case DevotionalLevel.novice:
        return 15;
      case DevotionalLevel.intermediate:
        return 60;
      case DevotionalLevel.advanced:
        return 180;
      case DevotionalLevel.master:
        return 365;
    }
  }
}

extension DateTimeExtension on DateTime {
  bool get isToday {
    final now = DateTime.now();
    return year == now.year && month == now.month && day == now.day;
  }

  bool get isYesterday {
    final yesterday = DateTime.now().subtract(const Duration(days: 1));
    return year == yesterday.year &&
        month == yesterday.month &&
        day == yesterday.day;
  }
}

extension TimeOfDayExtension on TimeOfDay {
  Map<String, dynamic> toJson() {
    return {
      'hour': hour,
      'minute': minute,
    };
  }
}

/// Helper to deserialize TimeOfDay from JSON
extension TimeOfDayFromJson on TimeOfDay {
  static TimeOfDay fromJson(Map<String, dynamic> json) {
    return TimeOfDay(
      hour: json['hour'] ?? 0,
      minute: json['minute'] ?? 0,
    );
  }
}
//pages/favorites_page.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:share_plus/share_plus.dart';
import '../models/song_model.dart';
import '../providers/favorites_provider.dart';
import '../providers/language_provider.dart';
import '../providers/theme_provider.dart';
import '../utils/constants.dart';
import '../utils/text_styles.dart';
import '../pages/song_view_page.dart';

class FavoritesPage extends StatefulWidget {
  const FavoritesPage({super.key});

  @override
  State<FavoritesPage> createState() => _FavoritesPageState();
}

class _FavoritesPageState extends State<FavoritesPage>
    with TickerProviderStateMixin {
  late TabController _tabController;
  String _sortBy = 'recent';
  bool _isGridView = false;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 4, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer3<FavoritesProvider, LanguageProvider, ThemeProvider>(
      builder: (context, favoritesProvider, languageProvider, themeProvider, child) {
        return Scaffold(
          backgroundColor: themeProvider.isDarkMode 
            ? AppColors.darkBackground 
            : AppColors.lightBackground,
          appBar: _buildAppBar(context, favoritesProvider, themeProvider),
          body: favoritesProvider.favoriteSongs.isEmpty
              ? _buildEmptyState(context, themeProvider)
              : _buildFavoritesContent(context, favoritesProvider, languageProvider, themeProvider),
        );
      },
    );
  }

  PreferredSizeWidget _buildAppBar(BuildContext context, FavoritesProvider favoritesProvider, ThemeProvider themeProvider) {
    return AppBar(
      backgroundColor: Colors.transparent,
      elevation: 0,
      title: Text(
        'My Favorites',
        style: AppTextStyles.headingMedium.copyWith(
          color: themeProvider.isDarkMode ? Colors.white : AppColors.textPrimary,
        ),
      ),
      actions: [
        if (favoritesProvider.favoriteSongs.isNotEmpty) ...[
          IconButton(
            icon: Icon(
              _isGridView ? Icons.list : Icons.grid_view,
              color: themeProvider.isDarkMode ? Colors.white70 : AppColors.textSecondary,
            ),
            onPressed: () {
              setState(() {
                _isGridView = !_isGridView;
              });
            },
          ),
          PopupMenuButton<String>(
            icon: Icon(
              Icons.sort,
              color: themeProvider.isDarkMode ? Colors.white70 : AppColors.textSecondary,
            ),
            onSelected: (value) {
              setState(() {
                _sortBy = value;
              });
            },
            itemBuilder: (context) => [
              const PopupMenuItem(
                value: 'recent',
                child: Text('Recently Added'),
              ),
              const PopupMenuItem(
                value: 'title',
                child: Text('Song Title'),
              ),
              const PopupMenuItem(
                value: 'singer',
                child: Text('Singer'),
              ),
              const PopupMenuItem(
                value: 'most_played',
                child: Text('Most Played'),
              ),
            ],
          ),
        ],
      ],
      bottom: favoritesProvider.favoriteSongs.isNotEmpty
          ? TabBar(
              controller: _tabController,
              tabs: const [
                Tab(text: 'All'),
                Tab(text: 'Songs'),
                Tab(text: 'Mantras'),
                Tab(text: 'Recent'),
              ],
              labelColor: AppColors.primary,
              unselectedLabelColor: themeProvider.isDarkMode 
                ? Colors.white60 
                : AppColors.textSecondary,
              indicatorColor: AppColors.primary,
            )
          : null,
    );
  }

  Widget _buildEmptyState(BuildContext context, ThemeProvider themeProvider) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            width: 120,
            height: 120,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              gradient: LinearGradient(
                colors: [
                  AppColors.primary.withOpacity(0.1),
                  AppColors.secondary.withOpacity(0.1),
                ],
              ),
            ),
            child: Icon(
              Icons.favorite_border,
              size: 60,
              color: themeProvider.isDarkMode ? Colors.white30 : AppColors.textSecondary,
            ),
          ),
          const SizedBox(height: 24),
          Text(
            'No Favorites Yet',
            style: AppTextStyles.headingMedium.copyWith(
              color: themeProvider.isDarkMode ? Colors.white70 : AppColors.textPrimary,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Start adding your favorite songs\nand mantras to see them here',
            textAlign: TextAlign.center,
            style: AppTextStyles.bodyMedium.copyWith(
              color: themeProvider.isDarkMode ? Colors.white60 : AppColors.textSecondary,
            ),
          ),
          const SizedBox(height: 32),
          ElevatedButton.icon(
            onPressed: () {
              DefaultTabController.of(context)?.animateTo(1); // Navigate to Songs tab
            },
            icon: const Icon(Icons.music_note),
            label: const Text('Browse Songs'),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.primary,
              foregroundColor: Colors.white,
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFavoritesContent(BuildContext context, FavoritesProvider favoritesProvider, 
      LanguageProvider languageProvider, ThemeProvider themeProvider) {
    return TabBarView(
      controller: _tabController,
      children: [
        _buildAllFavorites(context, favoritesProvider, languageProvider, themeProvider),
        _buildSongsFavorites(context, favoritesProvider, languageProvider, themeProvider),
        _buildMantrasFavorites(context, favoritesProvider, languageProvider, themeProvider),
        _buildRecentFavorites(context, favoritesProvider, languageProvider, themeProvider),
      ],
    );
  }

  Widget _buildAllFavorites(BuildContext context, FavoritesProvider favoritesProvider, 
      LanguageProvider languageProvider, ThemeProvider themeProvider) {
    final sortedSongs = _getSortedSongs(favoritesProvider.favoriteSongs);
    
    return Column(
      children: [
        _buildStatsCard(context, favoritesProvider, themeProvider),
        Expanded(
          child: _isGridView
              ? _buildGridView(sortedSongs, languageProvider, themeProvider)
              : _buildListView(sortedSongs, languageProvider, themeProvider),
        ),
      ],
    );
  }

  Widget _buildStatsCard(BuildContext context, FavoritesProvider favoritesProvider, ThemeProvider themeProvider) {
    return Container(
      margin: const EdgeInsets.all(16),
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            AppColors.primary.withOpacity(0.1),
            AppColors.secondary.withOpacity(0.1),
          ],
        ),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: themeProvider.isDarkMode ? Colors.white10 : Colors.black10,
        ),
      ),
      child: Row(
        children: [
          Expanded(
            child: _buildStatItem(
              'Total Favorites',
              '${favoritesProvider.favoriteSongs.length}',
              Icons.favorite,
              themeProvider,
            ),
          ),
          Container(
            width: 1,
            height: 40,
            color: themeProvider.isDarkMode ? Colors.white20 : Colors.black20,
          ),
          Expanded(
            child: _buildStatItem(
              'Songs',
              '${favoritesProvider.favoriteSongs.where((s) => s.type == 'song').length}',
              Icons.music_note,
              themeProvider,
            ),
          ),
          Container(
            width: 1,
            height: 40,
            color: themeProvider.isDarkMode ? Colors.white20 : Colors.black20,
          ),
          Expanded(
            child: _buildStatItem(
              'Mantras',
              '${favoritesProvider.favoriteSongs.where((s) => s.type == 'mantra').length}',
              Icons.self_improvement,
              themeProvider,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatItem(String label, String value, IconData icon, ThemeProvider themeProvider) {
    return Column(
      children: [
        Icon(
          icon,
          color: AppColors.primary,
          size: 24,
        ),
        const SizedBox(height: 8),
        Text(
          value,
          style: AppTextStyles.headingMedium.copyWith(
            color: themeProvider.isDarkMode ? Colors.white : AppColors.textPrimary,
          ),
        ),
        Text(
          label,
          style: AppTextStyles.bodySmall.copyWith(
            color: themeProvider.isDarkMode ? Colors.white60 : AppColors.textSecondary,
          ),
        ),
      ],
    );
  }

  Widget _buildSongsFavorites(BuildContext context, FavoritesProvider favoritesProvider, 
      LanguageProvider languageProvider, ThemeProvider themeProvider) {
    final songs = favoritesProvider.favoriteSongs.where((s) => s.type == 'song').toList();
    final sortedSongs = _getSortedSongs(songs);
    
    if (songs.isEmpty) {
      return _buildEmptyCategory('No favorite songs yet', Icons.music_note, themeProvider);
    }
    
    return _isGridView
        ? _buildGridView(sortedSongs, languageProvider, themeProvider)
        : _buildListView(sortedSongs, languageProvider, themeProvider);
  }

  Widget _buildMantrasFavorites(BuildContext context, FavoritesProvider favoritesProvider, 
      LanguageProvider languageProvider, ThemeProvider themeProvider) {
    final mantras = favoritesProvider.favoriteSongs.where((s) => s.type == 'mantra').toList();
    final sortedMantras = _getSortedSongs(mantras);
    
    if (mantras.isEmpty) {
      return _buildEmptyCategory('No favorite mantras yet', Icons.self_improvement, themeProvider);
    }
    
    return _isGridView
        ? _buildGridView(sortedMantras, languageProvider, themeProvider)
        : _buildListView(sortedMantras, languageProvider, themeProvider);
  }

  Widget _buildRecentFavorites(BuildContext context, FavoritesProvider favoritesProvider, 
      LanguageProvider languageProvider, ThemeProvider themeProvider) {
    final recentSongs = favoritesProvider.favoriteSongs.take(10).toList();
    
    if (recentSongs.isEmpty) {
      return _buildEmptyCategory('No recent favorites', Icons.access_time, themeProvider);
    }
    
    return _buildListView(recentSongs, languageProvider, themeProvider);
  }

  Widget _buildEmptyCategory(String message, IconData icon, ThemeProvider themeProvider) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            icon,
            size: 80,
            color: themeProvider.isDarkMode ? Colors.white30 : AppColors.textSecondary,
          ),
          const SizedBox(height: 16),
          Text(
            message,
            style: AppTextStyles.bodyLarge.copyWith(
              color: themeProvider.isDarkMode ? Colors.white60 : AppColors.textSecondary,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildListView(List<Song> songs, LanguageProvider languageProvider, ThemeProvider themeProvider) {
    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      itemCount: songs.length,
      itemBuilder: (context, index) {
        final song = songs[index];
        return _buildSongTile(song, languageProvider, themeProvider);
      },
    );
  }

  Widget _buildGridView(List<Song> songs, LanguageProvider languageProvider, ThemeProvider themeProvider) {
    return GridView.builder(
      padding: const EdgeInsets.all(16),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 2,
        childAspectRatio: 0.8,
        crossAxisSpacing: 12,
        mainAxisSpacing: 12,
      ),
      itemCount: songs.length,
      itemBuilder: (context, index) {
        final song = songs[index];
        return _buildSongCard(song, languageProvider, themeProvider);
      },
    );
  }

  Widget _buildSongTile(Song song, LanguageProvider languageProvider, ThemeProvider themeProvider) {
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      decoration: BoxDecoration(
        color: themeProvider.isDarkMode ? Colors.white.withOpacity(0.05) : Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: themeProvider.isDarkMode ? Colors.white10 : Colors.black10,
        ),
      ),
      child: ListTile(
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        leading: Container(
          width: 50,
          height: 50,
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [AppColors.primary, AppColors.secondary],
            ),
            borderRadius: BorderRadius.circular(12),
          ),
          child: Icon(
            song.type == 'song' ? Icons.music_note : Icons.self_improvement,
            color: Colors.white,
            size: 24,
          ),
        ),
        title: Text(
          song.title,
          style: AppTextStyles.bodyLarge.copyWith(
            color: themeProvider.isDarkMode ? Colors.white : AppColors.textPrimary,
            fontWeight: FontWeight.w600,
          ),
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Singer: ${song.singer}',
              style: AppTextStyles.bodySmall.copyWith(
                color: themeProvider.isDarkMode ? Colors.white70 : AppColors.textSecondary,
              ),
            ),
            if (song.writer.isNotEmpty)
              Text(
                'Writer: ${song.writer}',
                style: AppTextStyles.bodySmall.copyWith(
                  color: themeProvider.isDarkMode ? Colors.white60 : AppColors.textSecondary,
                ),
              ),
          ],
        ),
        trailing: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            IconButton(
              icon: const Icon(Icons.share, size: 20),
              color: themeProvider.isDarkMode ? Colors.white60 : AppColors.textSecondary,
              onPressed: () => _shareSong(song),
            ),
            Consumer<FavoritesProvider>(
              builder: (context, favProvider, child) {
                return IconButton(
                  icon: Icon(
                    favProvider.isFavorite(song.id) ? Icons.favorite : Icons.favorite_border,
                    color: favProvider.isFavorite(song.id) ? Colors.red : 
                      (themeProvider.isDarkMode ? Colors.white60 : AppColors.textSecondary),
                  ),
                  onPressed: () => favProvider.toggleFavorite(song),
                );
              },
            ),
          ],
        ),
        onTap: () => _navigateToSongView(song),
      ),
    );
  }

  Widget _buildSongCard(Song song, LanguageProvider languageProvider, ThemeProvider themeProvider) {
    return Container(
      decoration: BoxDecoration(
        color: themeProvider.isDarkMode ? Colors.white.withOpacity(0.05) : Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: themeProvider.isDarkMode ? Colors.white10 : Colors.black10,
        ),
      ),
      child: InkWell(
        onTap: () => _navigateToSongView(song),
        borderRadius: BorderRadius.circular(16),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                width: double.infinity,
                height: 80,
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    colors: [AppColors.primary, AppColors.secondary],
                  ),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  song.type == 'song' ? Icons.music_note : Icons.self_improvement,
                  color: Colors.white,
                  size: 32,
                ),
              ),
              const SizedBox(height: 12),
              Text(
                song.title,
                style: AppTextStyles.bodyMedium.copyWith(
                  color: themeProvider.isDarkMode ? Colors.white : AppColors.textPrimary,
                  fontWeight: FontWeight.w600,
                ),
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
              const SizedBox(height: 4),
              Text(
                song.singer,
                style: AppTextStyles.bodySmall.copyWith(
                  color: themeProvider.isDarkMode ? Colors.white70 : AppColors.textSecondary,
                ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
              const Spacer(),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Consumer<FavoritesProvider>(
                    builder: (context, favProvider, child) {
                      return IconButton(
                        icon: Icon(
                          favProvider.isFavorite(song.id) ? Icons.favorite : Icons.favorite_border,
                          size: 20,
                          color: favProvider.isFavorite(song.id) ? Colors.red : 
                            (themeProvider.isDarkMode ? Colors.white60 : AppColors.textSecondary),
                        ),
                        onPressed: () => favProvider.toggleFavorite(song),
                      );
                    },
                  ),
                  IconButton(
                    icon: const Icon(Icons.share, size: 20),
                    color: themeProvider.isDarkMode ? Colors.white60 : AppColors.textSecondary,
                    onPressed: () => _shareSong(song),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  List<Song> _getSortedSongs(List<Song> songs) {
    switch (_sortBy) {
      case 'title':
        return [...songs]..sort((a, b) => a.title.compareTo(b.title));
      case 'singer':
        return [...songs]..sort((a, b) => a.singer.compareTo(b.singer));
      case 'most_played':
        // For now, just return as is. In a real app, you'd track play counts
        return songs;
      case 'recent':
      default:
        return songs; // Already in recent order from provider
    }
  }

  void _navigateToSongView(Song song) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => SongViewPage(song: song),
      ),
    );
  }

  void _shareSong(Song song) {
    Share.share(
      'Check out this devotional song: ${song.title} by ${song.singer}\n\nShared from Lord Ayyappa Devotional App',
      subject: 'Devotional Song - ${song.title}',
    );
  }
}
//pages/home_page.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/theme_provider.dart';
import '../providers/language_provider.dart';
import '../providers/user_provider.dart';
import '../utils/constants.dart';
import '../utils/text_styles.dart';
import '../utils/helpers.dart';
import '../utils/mock_data.dart';
import '../models/song_model.dart';
import '../models/devotional_content.dart';
import '../widgets/home/daily_mantra_card.dart';
import '../widgets/home/quote_of_day.dart';
import '../widgets/home/songs_carousel.dart';
import '../widgets/home/photo_gallery_grid.dart';
import '../widgets/home/weather_greeting.dart';
import '../widgets/common/gradient_background.dart';

class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> with TickerProviderStateMixin {
  late ScrollController _scrollController;
  late AnimationController _fadeController;
  late Animation<double> _fadeAnimation;
  bool _showAppBarTitle = false;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();
    _fadeController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _fadeController, curve: Curves.easeInOut),
    );

    _scrollController.addListener(_onScroll);
    _initializeData();
  }

  void _onScroll() {
    const double titleShowOffset = 120;
    if (_scrollController.offset > titleShowOffset && !_showAppBarTitle) {
      setState(() => _showAppBarTitle = true);
      _fadeController.forward();
    } else if (_scrollController.offset <= titleShowOffset && _showAppBarTitle) {
      setState(() => _showAppBarTitle = false);
      _fadeController.reverse();
    }
  }

  void _initializeData() {
    // Initialize user progress and daily content
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<UserProvider>().updateDailyVisit();
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _fadeController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final themeProvider = context.watch<ThemeProvider>();
    final languageProvider = context.watch<LanguageProvider>();
    final userProvider = context.watch<UserProvider>();

    return Scaffold(
      body: GradientBackground(
        child: CustomScrollView(
          controller: _scrollController,
          slivers: [
            _buildAppBar(context, themeProvider, languageProvider),
            SliverToBoxAdapter(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Weather-based greeting
                  WeatherGreeting(),
                  const SizedBox(height: AppSizes.spacingM),

                  // Daily Mantra Card
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: AppSizes.paddingM),
                    child: DailyMantraCard(),
                  ),
                  const SizedBox(height: AppSizes.spacingL),

                  // Daily Quote
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: AppSizes.paddingM),
                    child: QuoteOfDay(),
                  ),
                  const SizedBox(height: AppSizes.spacingL),

                  // Popular Songs Carousel
                  _buildSectionHeader(
                    context,
                    _getLocalizedText(languageProvider.currentLanguage, 'popular_songs'),
                    () => _navigateToSongs(context),
                  ),
                  const SizedBox(height: AppSizes.spacingM),
                  SongsCarousel(
                    songs: MockData.getSampleSongs().take(3).toList(),
                    onSongTap: (song) => _navigateToSongView(context, song),
                  ),
                  const SizedBox(height: AppSizes.spacingL),

                  // Ayyappa History Section
                  _buildHistorySection(context, languageProvider),
                  const SizedBox(height: AppSizes.spacingL),

                  // Photo Gallery Preview
                  _buildSectionHeader(
                    context,
                    _getLocalizedText(languageProvider.currentLanguage, 'sacred_gallery'),
                    () => _navigateToLibrary(context, 'photos'),
                  ),
                  const SizedBox(height: AppSizes.spacingM),
                  PhotoGalleryGrid(
                    onPhotoTap: (photo) => _showPhotoDetail(context, photo),
                  ),
                  const SizedBox(height: AppSizes.spacingL),

                  // Quick Actions
                  _buildQuickActions(context, languageProvider),
                  
                  // Bottom spacing for navigation bar
                  const SizedBox(height: 100),
                ],
              ),
            ),
          ],
        ),
      ),
      floatingActionButton: _buildFloatingActionButton(context, themeProvider),
    );
  }

  Widget _buildAppBar(BuildContext context, ThemeProvider themeProvider, LanguageProvider languageProvider) {
    return SliverAppBar(
      expandedHeight: 200.0,
      floating: false,
      pinned: true,
      elevation: 0,
      backgroundColor: Colors.transparent,
      flexibleSpace: FlexibleSpaceBar(
        title: AnimatedBuilder(
          animation: _fadeAnimation,
          builder: (context, child) {
            return Opacity(
              opacity: _fadeAnimation.value,
              child: Text(
                _getLocalizedText(languageProvider.currentLanguage, 'app_name'),
                style: AppTextStyles.h3.copyWith(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                ),
              ),
            );
          },
        ),
        background: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [
                AppColors.saffron.withOpacity(0.9),
                AppColors.primary.withOpacity(0.7),
              ],
            ),
          ),
          child: Stack(
            children: [
              // Sacred pattern overlay
              Positioned.fill(
                child: Opacity(
                  opacity: 0.1,
                  child: Image.asset(
                    'assets/images/backgrounds/om_pattern.png',
                    repeat: ImageRepeat.repeat,
                    errorBuilder: (context, error, stackTrace) => Container(),
                  ),
                ),
              ),
              // Lord Ayyappa image
              Positioned(
                right: 20,
                bottom: 20,
                child: Container(
                  width: 80,
                  height: 80,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    border: Border.all(color: Colors.white.withOpacity(0.3), width: 2),
                    image: const DecorationImage(
                      image: AssetImage('assets/images/ayyappa/lord_ayyappa.png'),
                      fit: BoxFit.cover,
                      onError: null,
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
      actions: [
        IconButton(
          icon: Icon(
            themeProvider.isDarkMode ? Icons.light_mode : Icons.dark_mode,
            color: Colors.white,
          ),
          onPressed: () => _showSettingsDialog(context),
        ),
        IconButton(
          icon: const Icon(Icons.notifications_outlined, color: Colors.white),
          onPressed: () => _showNotificationSettings(context),
        ),
      ],
    );
  }

  Widget _buildSectionHeader(BuildContext context, String title, VoidCallback? onViewAll) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: AppSizes.paddingM),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            title,
            style: AppTextStyles.h3.copyWith(
              color: Theme.of(context).textTheme.headlineSmall?.color,
              fontWeight: FontWeight.bold,
            ),
          ),
          if (onViewAll != null)
            TextButton.icon(
              onPressed: onViewAll,
              icon: const Icon(Icons.arrow_forward_ios, size: 16),
              label: Text(
                _getLocalizedText(context.read<LanguageProvider>().currentLanguage, 'view_all'),
                style: AppTextStyles.caption.copyWith(
                  color: AppColors.primary,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildHistorySection(BuildContext context, LanguageProvider languageProvider) {
    final historyItems = MockData.getAyyappaHistory();
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionHeader(
          context,
          _getLocalizedText(languageProvider.currentLanguage, 'sacred_history'),
          () => _navigateToLibrary(context, 'history'),
        ),
        const SizedBox(height: AppSizes.spacingM),
        SizedBox(
          height: 160,
          child: ListView.builder(
            scrollDirection: Axis.horizontal,
            padding: const EdgeInsets.symmetric(horizontal: AppSizes.paddingM),
            itemCount: historyItems.length.clamp(0, 3),
            itemBuilder: (context, index) {
              final item = historyItems[index];
              return Container(
                width: 280,
                margin: const EdgeInsets.only(right: AppSizes.spacingM),
                child: Card(
                  elevation: 4,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(AppSizes.radiusM),
                  ),
                  child: InkWell(
                    onTap: () => _showHistoryDetail(context, item),
                    borderRadius: BorderRadius.circular(AppSizes.radiusM),
                    child: Container(
                      padding: const EdgeInsets.all(AppSizes.paddingM),
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(AppSizes.radiusM),
                        gradient: LinearGradient(
                          begin: Alignment.topLeft,
                          end: Alignment.bottomRight,
                          colors: [
                            AppColors.gold.withOpacity(0.1),
                            AppColors.saffron.withOpacity(0.1),
                          ],
                        ),
                      ),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            children: [
                              Container(
                                padding: const EdgeInsets.all(8),
                                decoration: BoxDecoration(
                                  color: AppColors.primary.withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(8),
                                ),
                                child: Icon(
                                  Icons.auto_stories,
                                  color: AppColors.primary,
                                  size: 24,
                                ),
                              ),
                              const SizedBox(width: AppSizes.spacingS),
                              Expanded(
                                child: Text(
                                  item.title,
                                  style: AppTextStyles.h4.copyWith(
                                    fontWeight: FontWeight.bold,
                                  ),
                                  maxLines: 2,
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: AppSizes.spacingS),
                          Expanded(
                            child: Text(
                              item.description,
                              style: AppTextStyles.body2.copyWith(
                                color: Theme.of(context).textTheme.bodyMedium?.color?.withOpacity(0.7),
                              ),
                              maxLines: 4,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  Widget _buildQuickActions(BuildContext context, LanguageProvider languageProvider) {
    final actions = [
      {
        'title': _getLocalizedText(languageProvider.currentLanguage, 'daily_rituals'),
        'icon': Icons.schedule,
        'color': AppColors.primary,
        'onTap': () => _navigateToLibrary(context, 'rituals'),
      },
      {
        'title': _getLocalizedText(languageProvider.currentLanguage, 'mantras'),
        'icon': Icons.music_note,
        'color': AppColors.saffron,
        'onTap': () => _navigateToLibrary(context, 'mantras'),
      },
      {
        'title': _getLocalizedText(languageProvider.currentLanguage, 'festivals'),
        'icon': Icons.celebration,
        'color': AppColors.gold,
        'onTap': () => _navigateToLibrary(context, 'festivals'),
      },
    ];

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: AppSizes.paddingM),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            _getLocalizedText(languageProvider.currentLanguage, 'quick_actions'),
            style: AppTextStyles.h3.copyWith(
              color: Theme.of(context).textTheme.headlineSmall?.color,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: AppSizes.spacingM),
          Row(
            children: actions.map((action) {
              return Expanded(
                child: Container(
                  margin: const EdgeInsets.only(right: AppSizes.spacingS),
                  child: Card(
                    elevation: 2,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(AppSizes.radiusM),
                    ),
                    child: InkWell(
                      onTap: action['onTap'] as VoidCallback,
                      borderRadius: BorderRadius.circular(AppSizes.radiusM),
                      child: Container(
                        padding: const EdgeInsets.all(AppSizes.paddingM),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Container(
                              padding: const EdgeInsets.all(12),
                              decoration: BoxDecoration(
                                color: (action['color'] as Color).withOpacity(0.1),
                                shape: BoxShape.circle,
                              ),
                              child: Icon(
                                action['icon'] as IconData,
                                color: action['color'] as Color,
                                size: 28,
                              ),
                            ),
                            const SizedBox(height: AppSizes.spacingS),
                            Text(
                              action['title'] as String,
                              style: AppTextStyles.caption.copyWith(
                                fontWeight: FontWeight.w600,
                              ),
                              textAlign: TextAlign.center,
                              maxLines: 2,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
              );
            }).toList(),
          ),
        ],
      ),
    );
  }

  Widget _buildFloatingActionButton(BuildContext context, ThemeProvider themeProvider) {
    return FloatingActionButton(
      onPressed: () => _showQuickMantraDialog(context),
      backgroundColor: AppColors.primary,
      child: const Icon(Icons.self_improvement, color: Colors.white),
    );
  }

  // Navigation methods
  void _navigateToSongs(BuildContext context) {
    // Navigate to songs page (tab index 1)
    DefaultTabController.of(context)?.animateTo(1);
  }

  void _navigateToSongView(BuildContext context, Song song) {
    Navigator.pushNamed(context, '/song_view', arguments: song);
  }

  void _navigateToLibrary(BuildContext context, String section) {
    // Navigate to library page (tab index 2) with specific section
    DefaultTabController.of(context)?.animateTo(2);
  }

  // Dialog methods
  void _showSettingsDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(_getLocalizedText(context.read<LanguageProvider>().currentLanguage, 'settings')),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.language),
              title: Text(_getLocalizedText(context.read<LanguageProvider>().currentLanguage, 'language')),
              trailing: DropdownButton<String>(
                value: context.read<LanguageProvider>().currentLanguage,
                items: ['ta', 'te', 'en'].map((lang) {
                  return DropdownMenuItem(
                    value: lang,
                    child: Text(_getLanguageName(lang)),
                  );
                }).toList(),
                onChanged: (value) {
                  if (value != null) {
                    context.read<LanguageProvider>().setLanguage(value);
                    Navigator.pop(context);
                  }
                },
              ),
            ),
            SwitchListTile(
              title: Text(_getLocalizedText(context.read<LanguageProvider>().currentLanguage, 'dark_mode')),
              value: context.read<ThemeProvider>().isDarkMode,
              onChanged: (value) {
                context.read<ThemeProvider>().toggleTheme();
              },
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(_getLocalizedText(context.read<LanguageProvider>().currentLanguage, 'close')),
          ),
        ],
      ),
    );
  }

  void _showNotificationSettings(BuildContext context) {
    // Implement notification settings
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(_getLocalizedText(context.read<LanguageProvider>().currentLanguage, 'feature_coming_soon')),
        backgroundColor: AppColors.primary,
      ),
    );
  }

  void _showHistoryDetail(BuildContext context, DevotionalContent item) {
    showDialog(
      context: context,
      builder: (context) => Dialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSizes.radiusM),
        ),
        child: Container(
          padding: const EdgeInsets.all(AppSizes.paddingL),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                item.title,
                style: AppTextStyles.h3.copyWith(
                  color: AppColors.primary,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: AppSizes.spacingM),
              Text(
                item.description,
                style: AppTextStyles.body1,
              ),
              const SizedBox(height: AppSizes.spacingL),
              Align(
                alignment: Alignment.centerRight,
                child: TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: Text(
                    _getLocalizedText(context.read<LanguageProvider>().currentLanguage, 'close'),
                    style: TextStyle(color: AppColors.primary),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showPhotoDetail(BuildContext context, String photo) {
    // Implement photo detail view
    showDialog(
      context: context,
      builder: (context) => Dialog(
        backgroundColor: Colors.transparent,
        child: Container(
          constraints: BoxConstraints(
            maxHeight: MediaQuery.of(context).size.height * 0.8,
          ),
          child: ClipRRect(
            borderRadius: BorderRadius.circular(AppSizes.radiusM),
            child: Image.asset(
              photo,
              fit: BoxFit.contain,
              errorBuilder: (context, error, stackTrace) => Container(
                height: 200,
                color: Colors.grey[300],
                child: const Icon(Icons.image_not_supported),
              ),
            ),
          ),
        ),
      ),
    );
  }

  void _showQuickMantraDialog(BuildContext context) {
    final mantras = MockData.getDailyMantras();
    final randomMantra = mantras[DateTime.now().day % mantras.length];

    showDialog(
      context: context,
      builder: (context) => Dialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSizes.radiusM),
        ),
        child: Container(
          padding: const EdgeInsets.all(AppSizes.paddingL),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(AppSizes.radiusM),
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                AppColors.saffron.withOpacity(0.1),
                AppColors.gold.withOpacity(0.1),
              ],
            ),
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                Icons.self_improvement,
                size: 48,
                color: AppColors.primary,
              ),
              const SizedBox(height: AppSizes.spacingM),
              Text(
                _getLocalizedText(context.read<LanguageProvider>().currentLanguage, 'quick_mantra'),
                style: AppTextStyles.h3.copyWith(
                  color: AppColors.primary,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: AppSizes.spacingM),
              Text(
                randomMantra.title,
                style: AppTextStyles.h4.copyWith(
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: AppSizes.spacingS),
              Text(
                randomMantra.description,
                style: AppTextStyles.body1,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: AppSizes.spacingL),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  TextButton(
                    onPressed: () => Navigator.pop(context),
                    child: Text(
                      _getLocalizedText(context.read<LanguageProvider>().currentLanguage, 'close'),
                      style: TextStyle(color: AppColors.primary),
                    ),
                  ),
                  ElevatedButton(
                    onPressed: () {
                      Navigator.pop(context);
                      _navigateToLibrary(context, 'mantras');
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppColors.primary,
                      foregroundColor: Colors.white,
                    ),
                    child: Text(_getLocalizedText(context.read<LanguageProvider>().currentLanguage, 'more_mantras')),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  // Helper methods
  String _getLocalizedText(String language, String key) {
    // Simple localization - in a real app, use proper i18n
    final texts = {
      'en': {
        'app_name': 'Lord Ayyappa',
        'popular_songs': 'Popular Devotional Songs',
        'sacred_history': 'Sacred History',
        'sacred_gallery': 'Sacred Gallery',
        'quick_actions': 'Quick Actions',
        'daily_rituals': 'Daily Rituals',
        'mantras': 'Mantras',
        'festivals': 'Festivals',
        'view_all': 'View All',
        'settings': 'Settings',
        'language': 'Language',
        'dark_mode': 'Dark Mode',
        'close': 'Close',
        'feature_coming_soon': 'Feature coming soon!',
        'quick_mantra': 'Quick Mantra',
        'more_mantras': 'More Mantras',
      },
      'ta': {
        'app_name': 'à®à®¯à®ªà¯à®ªà®©à¯',
        'popular_songs': 'à®ªà®¿à®°à®ªà®²à®®à®¾à®© à®ªà®•à¯à®¤à®¿ à®ªà®¾à®Ÿà®²à¯à®•à®³à¯',
        'sacred_history': 'à®ªà¯à®©à®¿à®¤ à®µà®°à®²à®¾à®±à¯',
        'sacred_gallery': 'à®ªà¯à®©à®¿à®¤ à®•à®¾à®Ÿà¯à®šà®¿à®¯à®•à®®à¯',
        'quick_actions': 'à®µà®¿à®°à¯ˆà®µà¯ à®šà¯†à®¯à®²à¯à®•à®³à¯',
        'daily_rituals': 'à®¤à®¿à®©à®šà®°à®¿ à®šà®Ÿà®™à¯à®•à¯à®•à®³à¯',
        'mantras': 'à®®à®¨à¯à®¤à®¿à®°à®™à¯à®•à®³à¯',
        'festivals': 'à®¤à®¿à®°à¯à®µà®¿à®´à®¾à®•à¯à®•à®³à¯',
        'view_all': 'à®…à®©à¯ˆà®¤à¯à®¤à¯ˆà®¯à¯à®®à¯ à®ªà®¾à®°à¯à®•à¯à®•',
        'settings': 'à®…à®®à¯ˆà®ªà¯à®ªà¯à®•à®³à¯',
        'language': 'à®®à¯Šà®´à®¿',
        'dark_mode': 'à®‡à®°à¯à®£à¯à®Ÿ à®ªà®¯à®©à¯à®®à¯à®±à¯ˆ',
        'close': 'à®®à¯‚à®Ÿà¯',
        'feature_coming_soon': 'à®…à®®à¯à®šà®®à¯ à®µà®¿à®°à¯ˆà®µà®¿à®²à¯ à®µà®°à¯à®®à¯!',
        'quick_mantra': 'à®µà®¿à®°à¯ˆà®µà¯ à®®à®¨à¯à®¤à®¿à®°à®®à¯',
        'more_mantras': 'à®®à¯‡à®²à¯à®®à¯ à®®à®¨à¯à®¤à®¿à®°à®™à¯à®•à®³à¯',
      },
      'te': {
        'app_name': 'à°…à°¯à±à°¯à°ªà±à°ª à°¸à±à°µà°¾à°®à°¿',
        'popular_songs': 'à°ªà±à°°à°®à±à°– à°­à°•à±à°¤à°¿ à°ªà°¾à°Ÿà°²à±',
        'sacred_history': 'à°ªà°µà°¿à°¤à±à°° à°šà°°à°¿à°¤à±à°°',
        'sacred_gallery': 'à°ªà°µà°¿à°¤à±à°° à°—à±à°¯à°¾à°²à°°à±€',
        'quick_actions': 'à°¤à±à°µà°°à°¿à°¤ à°šà°°à±à°¯à°²à±',
        'daily_rituals': 'à°¦à±ˆà°¨à°‚à°¦à°¿à°¨ à°†à°šà°¾à°°à°¾à°²à±',
        'mantras': 'à°®à°‚à°¤à±à°°à°¾à°²à±',
        'festivals': 'à°ªà°‚à°¡à±à°—à°²à±',
        'view_all': 'à°…à°¨à±à°¨à°¿ à°šà±‚à°¡à°‚à°¡à°¿',
        'settings': 'à°¸à±†à°Ÿà±à°Ÿà°¿à°‚à°—à±â€Œà°²à±',
        'language': 'à°­à°¾à°·',
        'dark_mode': 'à°¡à°¾à°°à±à°•à± à°®à±‹à°¡à±',
        'close': 'à°®à±‚à°¸à°¿à°µà±‡à°¯à°‚à°¡à°¿',
        'feature_coming_soon': 'à°«à±€à°šà°°à± à°¤à±à°µà°°à°²à±‹ à°µà°¸à±à°¤à±à°‚à°¦à°¿!',
        'quick_mantra': 'à°¤à±à°µà°°à°¿à°¤ à°®à°‚à°¤à±à°°à°‚',
        'more_mantras': 'à°®à°°à°¿à°¨à±à°¨à°¿ à°®à°‚à°¤à±à°°à°¾à°²à±',
      },
    };

    return texts[language]?[key] ?? texts['en']?[key] ?? key;
  }

  String _getLanguageName(String lang) {
    switch (lang) {
      case 'ta': return 'à®¤à®®à®¿à®´à¯';
      case 'te': return 'à°¤à±†à°²à±à°—à±';
      case 'en': return 'English';
      default: return 'English';
    }
  }
}
//pages/library_page.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_staggered_grid_view/flutter_staggered_grid_view.dart';
import '../models/devotional_content.dart';
import '../models/ritual_model.dart';
import '../models/festival_model.dart';
import '../providers/theme_provider.dart';
import '../providers/language_provider.dart';
import '../utils/constants.dart';
import '../utils/text_styles.dart';
import '../utils/mock_data.dart';

/// Library Page - Content hub with sacred texts, rituals, photos, and mantras
class LibraryPage extends StatefulWidget {
  const LibraryPage({super.key});

  @override
  State<LibraryPage> createState() => _LibraryPageState();
}

class _LibraryPageState extends State<LibraryPage>
    with TickerProviderStateMixin {
  late TabController _tabController;
  late AnimationController _fadeController;
  late Animation<double> _fadeAnimation;
  
  int _selectedCategoryIndex = 0;
  final List<String> _categories = [
    'Sacred Texts',
    'Ritual Guide',
    'Photo Gallery',
    'Mantras',
    'Festival Calendar'
  ];

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: _categories.length, vsync: this);
    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _fadeController, curve: Curves.easeInOut),
    );
    _fadeController.forward();
  }

  @override
  void dispose() {
    _tabController.dispose();
    _fadeController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<ThemeProvider, LanguageProvider>(
      builder: (context, themeProvider, languageProvider, child) {
        return Scaffold(
          backgroundColor: themeProvider.isDarkMode
              ? AppColors.darkBackground
              : Colors.grey.shade50,
          body: FadeTransition(
            opacity: _fadeAnimation,
            child: CustomScrollView(
              slivers: [
                _buildSliverAppBar(themeProvider),
                _buildCategoryTabs(themeProvider),
                _buildContent(themeProvider, languageProvider),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildSliverAppBar(ThemeProvider themeProvider) {
    return SliverAppBar(
      expandedHeight: 200,
      floating: false,
      pinned: true,
      elevation: 0,
      backgroundColor: Colors.transparent,
      flexibleSpace: FlexibleSpaceBar(
        background: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                AppColors.primary,
                AppColors.secondary,
                Colors.orange.shade300,
              ],
            ),
          ),
          child: Stack(
            children: [
              // Sacred geometry pattern
              Positioned.fill(
                child: Opacity(
                  opacity: 0.1,
                  child: CustomPaint(
                    painter: SacredGeometryPainter(),
                  ),
                ),
              ),
              // Content
              Positioned(
                bottom: 80,
                left: 20,
                right: 20,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Sacred Library',
                      style: AppTextStyles.displaySmall.copyWith(
                        color: Colors.white,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Explore the divine wisdom of Lord Ayyappa',
                      style: AppTextStyles.bodyLarge.copyWith(
                        color: Colors.white.withOpacity(0.9),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildCategoryTabs(ThemeProvider themeProvider) {
    return SliverToBoxAdapter(
      child: Container(
        margin: const EdgeInsets.all(16),
        child: SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          child: Row(
            children: List.generate(_categories.length, (index) {
              final isSelected = _selectedCategoryIndex == index;
              return GestureDetector(
                onTap: () => setState(() => _selectedCategoryIndex = index),
                child: AnimatedContainer(
                  duration: const Duration(milliseconds: 300),
                  margin: const EdgeInsets.only(right: 12),
                  padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                  decoration: BoxDecoration(
                    color: isSelected
                        ? AppColors.primary
                        : (themeProvider.isDarkMode
                            ? AppColors.darkSurface
                            : Colors.white),
                    borderRadius: BorderRadius.circular(25),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.1),
                        blurRadius: 8,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Text(
                    _categories[index],
                    style: AppTextStyles.bodyMedium.copyWith(
                      color: isSelected
                          ? Colors.white
                          : (themeProvider.isDarkMode ? Colors.white : Colors.black87),
                      fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                    ),
                  ),
                ),
              );
            }),
          ),
        ),
      ),
    );
  }

  Widget _buildContent(ThemeProvider themeProvider, LanguageProvider languageProvider) {
    switch (_selectedCategoryIndex) {
      case 0:
        return _buildSacredTexts(themeProvider, languageProvider);
      case 1:
        return _buildRitualGuide(themeProvider, languageProvider);
      case 2:
        return _buildPhotoGallery(themeProvider);
      case 3:
        return _buildMantrasCollection(themeProvider, languageProvider);
      case 4:
        return _buildFestivalCalendar(themeProvider, languageProvider);
      default:
        return _buildSacredTexts(themeProvider, languageProvider);
    }
  }

  Widget _buildSacredTexts(ThemeProvider themeProvider, LanguageProvider languageProvider) {
    final stories = MockData.getAyyappaStories();
    
    return SliverList(
      delegate: SliverChildBuilderDelegate(
        (context, index) {
          final story = stories[index];
          return Container(
            margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: Card(
              elevation: 4,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
              color: themeProvider.isDarkMode ? AppColors.darkSurface : Colors.white,
              child: InkWell(
                onTap: () => _openStoryDetails(story),
                borderRadius: BorderRadius.circular(16),
                child: Padding(
                  padding: const EdgeInsets.all(16),
                  child: Row(
                    children: [
                      Container(
                        width: 60,
                        height: 60,
                        decoration: BoxDecoration(
                          color: AppColors.primary.withOpacity(0.1),
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Icon(
                          Icons.auto_stories,
                          color: AppColors.primary,
                          size: 30,
                        ),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              story.title,
                              style: AppTextStyles.headlineSmall.copyWith(
                                color: themeProvider.isDarkMode ? Colors.white : Colors.black87,
                              ),
                            ),
                            const SizedBox(height: 4),
                            Text(
                              story.description,
                              style: AppTextStyles.bodyMedium.copyWith(
                                color: themeProvider.isDarkMode ? Colors.white70 : Colors.black54,
                              ),
                              maxLines: 2,
                              overflow: TextOverflow.ellipsis,
                            ),
                            const SizedBox(height: 8),
                            Row(
                              children: [
                                Icon(
                                  Icons.access_time,
                                  size: 14,
                                  color: AppColors.primary,
                                ),
                                const SizedBox(width: 4),
                                Text(
                                  '${story.readingTime} min read',
                                  style: AppTextStyles.bodySmall.copyWith(
                                    color: AppColors.primary,
                                  ),
                                ),
                              ],
                            ),
                          ],
                        ),
                      ),
                      Icon(
                        Icons.arrow_forward_ios,
                        color: themeProvider.isDarkMode ? Colors.white30 : Colors.black26,
                        size: 16,
                      ),
                    ],
                  ),
                ),
              ),
            ),
          );
        },
        childCount: stories.length,
      ),
    );
  }

  Widget _buildRitualGuide(ThemeProvider themeProvider, LanguageProvider languageProvider) {
    final rituals = MockData.getRituals();
    
    return SliverPadding(
      padding: const EdgeInsets.all(16),
      sliver: SliverStaggeredGrid.countBuilder(
        crossAxisCount: 2,
        itemCount: rituals.length,
        staggeredTileBuilder: (index) => const StaggeredTile.fit(1),
        mainAxisSpacing: 16,
        crossAxisSpacing: 16,
        itemBuilder: (context, index) {
          final ritual = rituals[index];
          return _buildRitualCard(ritual, themeProvider);
        },
      ),
    );
  }

  Widget _buildRitualCard(Ritual ritual, ThemeProvider themeProvider) {
    return Card(
      elevation: 6,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      color: themeProvider.isDarkMode ? AppColors.darkSurface : Colors.white,
      child: InkWell(
        onTap: () => _openRitualDetails(ritual),
        borderRadius: BorderRadius.circular(16),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                width: double.infinity,
                height: 80,
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    colors: [
                      AppColors.primary.withOpacity(0.8),
                      AppColors.secondary.withOpacity(0.6),
                    ],
                  ),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  _getRitualIcon(ritual.category),
                  color: Colors.white,
                  size: 40,
                ),
              ),
              const SizedBox(height: 12),
              Text(
                ritual.title,
                style: AppTextStyles.headlineSmall.copyWith(
                  color: themeProvider.isDarkMode ? Colors.white : Colors.black87,
                  fontSize: 16,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                ritual.description,
                style: AppTextStyles.bodySmall.copyWith(
                  color: themeProvider.isDarkMode ? Colors.white70 : Colors.black54,
                ),
                maxLines: 3,
                overflow: TextOverflow.ellipsis,
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: AppColors.primary.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      ritual.category,
                      style: AppTextStyles.bodySmall.copyWith(
                        color: AppColors.primary,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPhotoGallery(ThemeProvider themeProvider) {
    final galleryCategories = [
      {'title': 'Sabarimala Temple', 'icon': Icons.temple_hindu, 'count': 25},
      {'title': 'Festival Celebrations', 'icon': Icons.celebration, 'count': 18},
      {'title': 'Deity Images', 'icon': Icons.auto_awesome, 'count': 12},
      {'title': 'Pilgrimage Journey', 'icon': Icons.hiking, 'count': 30},
      {'title': 'Sacred Rituals', 'icon': Icons.local_fire_department, 'count': 15},
      {'title': 'Divine Moments', 'icon': Icons.camera_alt, 'count': 22},
    ];

    return SliverPadding(
      padding: const EdgeInsets.all(16),
      sliver: SliverGrid(
        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 2,
          crossAxisSpacing: 16,
          mainAxisSpacing: 16,
          childAspectRatio: 1.2,
        ),
        delegate: SliverChildBuilderDelegate(
          (context, index) {
            final category = galleryCategories[index];
            return _buildGalleryCard(category, themeProvider);
          },
          childCount: galleryCategories.length,
        ),
      ),
    );
  }

  Widget _buildGalleryCard(Map<String, dynamic> category, ThemeProvider themeProvider) {
    return Card(
      elevation: 8,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: InkWell(
        onTap: () => _openGalleryCategory(category['title']),
        borderRadius: BorderRadius.circular(16),
        child: Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(16),
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                AppColors.primary.withOpacity(0.8),
                AppColors.secondary.withOpacity(0.6),
              ],
            ),
          ),
          child: Stack(
            children: [
              Positioned(
                top: 16,
                left: 16,
                child: Icon(
                  category['icon'],
                  color: Colors.white,
                  size: 32,
                ),
              ),
              Positioned(
                bottom: 16,
                left: 16,
                right: 16,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      category['title'],
                      style: AppTextStyles.headlineSmall.copyWith(
                        color: Colors.white,
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      '${category['count']} photos',
                      style: AppTextStyles.bodySmall.copyWith(
                        color: Colors.white.withOpacity(0.8),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMantrasCollection(ThemeProvider themeProvider, LanguageProvider languageProvider) {
    final mantras = MockData.getMantras();
    
    return SliverList(
      delegate: SliverChildBuilderDelegate(
        (context, index) {
          final mantra = mantras[index];
          return Container(
            margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: Card(
              elevation: 4,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
              color: themeProvider.isDarkMode ? AppColors.darkSurface : Colors.white,
              child: ExpansionTile(
                tilePadding: const EdgeInsets.all(16),
                childrenPadding: const EdgeInsets.all(16),
                leading: Container(
                  width: 50,
                  height: 50,
                  decoration: BoxDecoration(
                    color: AppColors.primary.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Icon(
                    Icons.mosque,
                    color: AppColors.primary,
                    size: 24,
                  ),
                ),
                title: Text(
                  mantra.title,
                  style: AppTextStyles.headlineSmall.copyWith(
                    color: themeProvider.isDarkMode ? Colors.white : Colors.black87,
                  ),
                ),
                subtitle: Text(
                  mantra.description,
                  style: AppTextStyles.bodyMedium.copyWith(
                    color: themeProvider.isDarkMode ? Colors.white70 : Colors.black54,
                  ),
                ),
                children: [
                  Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      color: AppColors.primary.withOpacity(0.05),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Sanskrit:',
                          style: AppTextStyles.bodyMedium.copyWith(
                            fontWeight: FontWeight.bold,
                            color: AppColors.primary,
                          ),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          mantra.sanskritText,
                          style: AppTextStyles.bodyLarge.copyWith(
                            color: themeProvider.isDarkMode ? Colors.white : Colors.black87,
                            fontStyle: FontStyle.italic,
                          ),
                        ),
                        const SizedBox(height: 12),
                        Text(
                          'Meaning:',
                          style: AppTextStyles.bodyMedium.copyWith(
                            fontWeight: FontWeight.bold,
                            color: AppColors.primary,
                          ),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          mantra.meaning,
                          style: AppTextStyles.bodyMedium.copyWith(
                            color: themeProvider.isDarkMode ? Colors.white70 : Colors.black54,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          );
        },
        childCount: mantras.length,
      ),
    );
  }

  Widget _buildFestivalCalendar(ThemeProvider themeProvider, LanguageProvider languageProvider) {
    final festivals = MockData.getFestivals();
    
    return SliverList(
      delegate: SliverChildBuilderDelegate(
        (context, index) {
          final festival = festivals[index];
          return Container(
            margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: Card(
              elevation: 4,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
              color: themeProvider.isDarkMode ? AppColors.darkSurface : Colors.white,
              child: InkWell(
                onTap: () => _openFestivalDetails(festival),
                borderRadius: BorderRadius.circular(16),
                child: Padding(
                  padding: const EdgeInsets.all(16),
                  child: Row(
                    children: [
                      Container(
                        width: 60,
                        height: 60,
                        decoration: BoxDecoration(
                          gradient: LinearGradient(
                            colors: [
                              AppColors.primary,
                              AppColors.secondary,
                            ],
                          ),
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Text(
                              festival.date.day.toString(),
                              style: AppTextStyles.headlineSmall.copyWith(
                                color: Colors.white,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            Text(
                              _getMonthName(festival.date.month),
                              style: AppTextStyles.bodySmall.copyWith(
                                color: Colors.white,
                              ),
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              festival.name,
                              style: AppTextStyles.headlineSmall.copyWith(
                                color: themeProvider.isDarkMode ? Colors.white : Colors.black87,
                              ),
                            ),
                            const SizedBox(height: 4),
                            Text(
                              festival.description,
                              style: AppTextStyles.bodyMedium.copyWith(
                                color: themeProvider.isDarkMode ? Colors.white70 : Colors.black54,
                              ),
                              maxLines: 2,
                              overflow: TextOverflow.ellipsis,
                            ),
                            const SizedBox(height: 8),
                            Container(
                              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                              decoration: BoxDecoration(
                                color: _getImportanceColor(festival.importance).withOpacity(0.1),
                                borderRadius: BorderRadius.circular(12),
                              ),
                              child: Text(
                                festival.importance,
                                style: AppTextStyles.bodySmall.copyWith(
                                  color: _getImportanceColor(festival.importance),
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          );
        },
        childCount: festivals.length,
      ),
    );
  }

  IconData _getRitualIcon(String category) {
    switch (category.toLowerCase()) {
      case 'daily worship':
        return Icons.local_fire_department;
      case 'sabarimala pilgrimage':
        return Icons.hiking;
      case 'vratham':
        return Icons.self_improvement;
      case 'puja':
        return Icons.temple_hindu;
      default:
        return Icons.auto_awesome;
    }
  }

  String _getMonthName(int month) {
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return months[month - 1];
  }

  Color _getImportanceColor(String importance) {
    switch (importance.toLowerCase()) {
      case 'high':
        return Colors.red;
      case 'medium':
        return Colors.orange;
      case 'low':
        return Colors.green;
      default:
        return AppColors.primary;
    }
  }

  void _openStoryDetails(DevotionalContent story) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => StoryDetailsPage(story: story),
      ),
    );
  }

  void _openRitualDetails(Ritual ritual) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => RitualDetailsPage(ritual: ritual),
      ),
    );
  }

  void _openGalleryCategory(String category) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => PhotoGalleryPage(category: category),
      ),
    );
  }

  void _openFestivalDetails(Festival festival) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => FestivalDetailsPage(festival: festival),
      ),
    );
  }
}

// Custom painter for sacred geometry
class SacredGeometryPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.white.withOpacity(0.1)
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    final center = Offset(size.width / 2, size.height / 2);
    final radius = size.width / 4;

    // Draw flower of life pattern
    for (int i = 0; i < 6; i++) {
      final angle = (i * 60) * (3.14159 / 180);
      final circleCenter = Offset(
        center.dx + radius * 0.5 * cos(angle),
        center.dy + radius * 0.5 * sin(angle),
      );
      canvas.drawCircle(circleCenter, radius * 0.5, paint);
    }
    
    canvas.drawCircle(center, radius * 0.5, paint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

// Placeholder detail pages (to be implemented)
class StoryDetailsPage extends StatelessWidget {
  final DevotionalContent story;
  
  const StoryDetailsPage({super.key, required this.story});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(story.title)),
      body: const Center(child: Text('Story details coming soon!')),
    );
  }
}

class RitualDetailsPage extends StatelessWidget {
  final Ritual ritual;
  
  const RitualDetailsPage({super.key, required this.ritual});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(ritual.title)),
      body: const Center(child: Text('Ritual details coming soon!')),
    );
  }
}

class PhotoGalleryPage extends StatelessWidget {
  final String category;
  
  const PhotoGalleryPage({super.key, required this.category});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(category)),
      body: const Center(child: Text('Photo gallery coming soon!')),
    );
  }
}

class FestivalDetailsPage extends StatelessWidget {
  final Festival festival;
  
  const FestivalDetailsPage({super.key, required this.festival});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(festival.name)),
      body: const Center(child: Text('Festival details coming soon!')),
    );
  }
}
//pages/profile_page.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/user_provider.dart';
import '../providers/theme_provider.dart';
import '../providers/language_provider.dart';
import '../providers/favorites_provider.dart';
import '../utils/constants.dart';
import '../utils/text_styles.dart';
import '../models/user_model.dart';

class ProfilePage extends StatefulWidget {
  const ProfilePage({Key? key}) : super(key: key);

  @override
  State<ProfilePage> createState() => _ProfilePageState();
}

class _ProfilePageState extends State<ProfilePage> with TickerProviderStateMixin {
  late AnimationController _fadeController;
  late AnimationController _slideController;
  late Animation<double> _fadeAnimation;
  late Animation<Offset> _slideAnimation;

  @override
  void initState() {
    super.initState();
    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );
    _slideController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );

    _fadeAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _fadeController,
      curve: Curves.easeInOut,
    ));

    _slideAnimation = Tween<Offset>(
      begin: const Offset(0, 0.3),
      end: Offset.zero,
    ).animate(CurvedAnimation(
      parent: _slideController,
      curve: Curves.easeOutBack,
    ));

    _fadeController.forward();
    _slideController.forward();
  }

  @override
  void dispose() {
    _fadeController.dispose();
    _slideController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            colors: [
              Theme.of(context).primaryColor.withOpacity(0.1),
              Theme.of(context).colorScheme.surface,
              Theme.of(context).primaryColor.withOpacity(0.05),
            ],
          ),
        ),
        child: SafeArea(
          child: FadeTransition(
            opacity: _fadeAnimation,
            child: SlideTransition(
              position: _slideAnimation,
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(AppConstants.defaultPadding),
                child: Column(
                  children: [
                    _buildProfileHeader(),
                    const SizedBox(height: 24),
                    _buildStatisticsSection(),
                    const SizedBox(height: 24),
                    _buildAchievementsSection(),
                    const SizedBox(height: 24),
                    _buildSettingsSection(),
                    const SizedBox(height: 24),
                    _buildAppInfoSection(),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildProfileHeader() {
    return Consumer<UserProvider>(
      builder: (context, userProvider, child) {
        final user = userProvider.currentUser;
        return Container(
          padding: const EdgeInsets.all(24),
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                AppColors.primarySaffron.withOpacity(0.8),
                AppColors.sacredGold.withOpacity(0.6),
              ],
            ),
            borderRadius: BorderRadius.circular(20),
            boxShadow: [
              BoxShadow(
                color: AppColors.primarySaffron.withOpacity(0.3),
                blurRadius: 15,
                offset: const Offset(0, 8),
              ),
            ],
          ),
          child: Column(
            children: [
              Container(
                width: 100,
                height: 100,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  gradient: LinearGradient(
                    colors: [
                      Colors.white.withOpacity(0.9),
                      Colors.white.withOpacity(0.7),
                    ],
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.1),
                      blurRadius: 10,
                      offset: const Offset(0, 4),
                    ),
                  ],
                ),
                child: Icon(
                  Icons.person,
                  size: 50,
                  color: AppColors.primarySaffron,
                ),
              ),
              const SizedBox(height: 16),
              Text(
                user.name.isEmpty ? 'Devotee' : user.name,
                style: AppTextStyles.headlineSmall.copyWith(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 8),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                decoration: BoxDecoration(
                  color: Colors.white.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  'Devotional Journey: ${user.devotionalDays} days',
                  style: AppTextStyles.bodyMedium.copyWith(
                    color: Colors.white,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildStatisticsSection() {
    return Consumer2<UserProvider, FavoritesProvider>(
      builder: (context, userProvider, favoritesProvider, child) {
        final user = userProvider.currentUser;
        return Container(
          padding: const EdgeInsets.all(20),
          decoration: BoxDecoration(
            color: Theme.of(context).cardColor,
            borderRadius: BorderRadius.circular(16),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Your Devotional Statistics',
                style: AppTextStyles.headlineSmall.copyWith(
                  color: AppColors.primarySaffron,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: _buildStatCard(
                      'Songs Learned',
                      '${user.songsLearned}',
                      Icons.music_note,
                      AppColors.primarySaffron,
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: _buildStatCard(
                      'Favorites',
                      '${favoritesProvider.favoriteCount}',
                      Icons.favorite,
                      Colors.red,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  Expanded(
                    child: _buildStatCard(
                      'Streak Days',
                      '${user.streakDays}',
                      Icons.local_fire_department,
                      Colors.orange,
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: _buildStatCard(
                      'Progress',
                      '${user.learningProgress}%',
                      Icons.trending_up,
                      Colors.green,
                    ),
                  ),
                ],
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildStatCard(String title, String value, IconData icon, Color color) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: color.withOpacity(0.2),
          width: 1,
        ),
      ),
      child: Column(
        children: [
          Icon(
            icon,
            color: color,
            size: 24,
          ),
          const SizedBox(height: 8),
          Text(
            value,
            style: AppTextStyles.headlineMedium.copyWith(
              color: color,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            title,
            style: AppTextStyles.bodySmall.copyWith(
              color: Theme.of(context).textTheme.bodySmall?.color,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildAchievementsSection() {
    return Consumer<UserProvider>(
      builder: (context, userProvider, child) {
        final user = userProvider.currentUser;
        return Container(
          padding: const EdgeInsets.all(20),
          decoration: BoxDecoration(
            color: Theme.of(context).cardColor,
            borderRadius: BorderRadius.circular(16),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(
                    Icons.emoji_events,
                    color: AppColors.sacredGold,
                    size: 28,
                  ),
                  const SizedBox(width: 12),
                  Text(
                    'Achievements',
                    style: AppTextStyles.headlineSmall.copyWith(
                      color: AppColors.primarySaffron,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: user.achievements.map((achievement) {
                  return _buildAchievementBadge(achievement);
                }).toList(),
              ),
              if (user.achievements.isEmpty)
                Center(
                  child: Column(
                    children: [
                      Icon(
                        Icons.star_border,
                        size: 48,
                        color: Colors.grey.withOpacity(0.5),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Start your devotional journey to earn achievements',
                        style: AppTextStyles.bodyMedium.copyWith(
                          color: Colors.grey,
                        ),
                        textAlign: TextAlign.center,
                      ),
                    ],
                  ),
                ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildAchievementBadge(String achievement) {
    IconData icon;
    Color color;
    
    switch (achievement.toLowerCase()) {
      case 'first song':
        icon = Icons.music_note;
        color = Colors.blue;
        break;
      case 'week warrior':
        icon = Icons.calendar_week;
        color = Colors.green;
        break;
      case 'devotee':
        icon = Icons.favorite;
        color = Colors.red;
        break;
      case 'scholar':
        icon = Icons.school;
        color = Colors.purple;
        break;
      default:
        icon = Icons.star;
        color = AppColors.sacredGold;
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
          color: color.withOpacity(0.3),
          width: 1,
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 16,
            color: color,
          ),
          const SizedBox(width: 6),
          Text(
            achievement,
            style: AppTextStyles.bodySmall.copyWith(
              color: color,
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSettingsSection() {
    return Container(
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Settings',
            style: AppTextStyles.headlineSmall.copyWith(
              color: AppColors.primarySaffron,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 16),
          _buildSettingsTile(
            'Theme',
            'Appearance settings',
            Icons.palette,
            onTap: _showThemeDialog,
          ),
          const Divider(height: 24),
          _buildSettingsTile(
            'Language',
            'Change app language',
            Icons.language,
            onTap: _showLanguageDialog,
          ),
          const Divider(height: 24),
          _buildSettingsTile(
            'Notifications',
            'Daily devotional reminders',
            Icons.notifications,
            trailing: Consumer<UserProvider>(
              builder: (context, userProvider, child) {
                return Switch(
                  value: userProvider.currentUser.notificationsEnabled,
                  onChanged: (value) {
                    userProvider.updateNotificationSettings(value);
                  },
                  activeColor: AppColors.primarySaffron,
                );
              },
            ),
          ),
          const Divider(height: 24),
          _buildSettingsTile(
            'Reset Progress',
            'Clear all progress data',
            Icons.refresh,
            onTap: _showResetDialog,
            iconColor: Colors.red,
          ),
        ],
      ),
    );
  }

  Widget _buildSettingsTile(
    String title,
    String subtitle,
    IconData icon, {
    VoidCallback? onTap,
    Widget? trailing,
    Color? iconColor,
  }) {
    return ListTile(
      contentPadding: EdgeInsets.zero,
      leading: Container(
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: (iconColor ?? AppColors.primarySaffron).withOpacity(0.1),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Icon(
          icon,
          color: iconColor ?? AppColors.primarySaffron,
          size: 24,
        ),
      ),
      title: Text(
        title,
        style: AppTextStyles.bodyLarge.copyWith(
          fontWeight: FontWeight.w600,
        ),
      ),
      subtitle: Text(
        subtitle,
        style: AppTextStyles.bodyMedium.copyWith(
          color: Theme.of(context).textTheme.bodySmall?.color,
        ),
      ),
      trailing: trailing ?? const Icon(Icons.chevron_right),
      onTap: onTap,
    );
  }

  Widget _buildAppInfoSection() {
    return Container(
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'App Information',
            style: AppTextStyles.headlineSmall.copyWith(
              color: AppColors.primarySaffron,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 16),
          _buildInfoTile('Version', '1.0.0'),
          const SizedBox(height: 12),
          _buildInfoTile('Developer', 'Devotional Apps Studio'),
          const SizedBox(height: 12),
          _buildInfoTile('Support', 'support@ayyappaapp.com'),
          const SizedBox(height: 20),
          Row(
            children: [
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: _shareFeedback,
                  icon: const Icon(Icons.feedback),
                  label: const Text('Feedback'),
                  style: OutlinedButton.styleFrom(
                    foregroundColor: AppColors.primarySaffron,
                    side: BorderSide(color: AppColors.primarySaffron),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: _rateApp,
                  icon: const Icon(Icons.star),
                  label: const Text('Rate App'),
                  style: OutlinedButton.styleFrom(
                    foregroundColor: AppColors.sacredGold,
                    side: BorderSide(color: AppColors.sacredGold),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildInfoTile(String label, String value) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          label,
          style: AppTextStyles.bodyMedium.copyWith(
            color: Theme.of(context).textTheme.bodySmall?.color,
          ),
        ),
        Text(
          value,
          style: AppTextStyles.bodyMedium.copyWith(
            fontWeight: FontWeight.w600,
          ),
        ),
      ],
    );
  }

  void _showThemeDialog() {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return Consumer<ThemeProvider>(
          builder: (context, themeProvider, child) {
            return AlertDialog(
              title: Text(
                'Choose Theme',
                style: AppTextStyles.headlineSmall.copyWith(
                  color: AppColors.primarySaffron,
                ),
              ),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  RadioListTile<ThemeMode>(
                    title: const Text('Light'),
                    value: ThemeMode.light,
                    groupValue: themeProvider.themeMode,
                    onChanged: (ThemeMode? value) {
                      if (value != null) {
                        themeProvider.setThemeMode(value);
                        Navigator.pop(context);
                      }
                    },
                    activeColor: AppColors.primarySaffron,
                  ),
                  RadioListTile<ThemeMode>(
                    title: const Text('Dark'),
                    value: ThemeMode.dark,
                    groupValue: themeProvider.themeMode,
                    onChanged: (ThemeMode? value) {
                      if (value != null) {
                        themeProvider.setThemeMode(value);
                        Navigator.pop(context);
                      }
                    },
                    activeColor: AppColors.primarySaffron,
                  ),
                  RadioListTile<ThemeMode>(
                    title: const Text('System'),
                    value: ThemeMode.system,
                    groupValue: themeProvider.themeMode,
                    onChanged: (ThemeMode? value) {
                      if (value != null) {
                        themeProvider.setThemeMode(value);
                        Navigator.pop(context);
                      }
                    },
                    activeColor: AppColors.primarySaffron,
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }

  void _showLanguageDialog() {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return Consumer<LanguageProvider>(
          builder: (context, languageProvider, child) {
            return AlertDialog(
              title: Text(
                'Choose Language',
                style: AppTextStyles.headlineSmall.copyWith(
                  color: AppColors.primarySaffron,
                ),
              ),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: AppConstants.supportedLanguages.map((language) {
                  return RadioListTile<String>(
                    title: Text(language.displayName),
                    value: language.code,
                    groupValue: languageProvider.currentLanguage,
                    onChanged: (String? value) {
                      if (value != null) {
                        languageProvider.setLanguage(value);
                        Navigator.pop(context);
                      }
                    },
                    activeColor: AppColors.primarySaffron,
                  );
                }).toList(),
              ),
            );
          },
        );
      },
    );
  }

  void _showResetDialog() {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text(
            'Reset Progress',
            style: AppTextStyles.headlineSmall.copyWith(
              color: Colors.red,
            ),
          ),
          content: const Text(
            'Are you sure you want to reset all your progress? This action cannot be undone.',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () {
                Provider.of<UserProvider>(context, listen: false).resetProgress();
                Provider.of<FavoritesProvider>(context, listen: false).clearAllFavorites();
                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Progress reset successfully'),
                    backgroundColor: Colors.green,
                  ),
                );
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.red,
                foregroundColor: Colors.white,
              ),
              child: const Text('Reset'),
            ),
          ],
        );
      },
    );
  }

  void _shareFeedback() {
    // Implement feedback sharing functionality
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Feedback feature coming soon!'),
        backgroundColor: AppColors.primarySaffron,
      ),
    );
  }

  void _rateApp() {
    // Implement app rating functionality
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Thank you for your support!'),
        backgroundColor: AppColors.sacredGold,
      ),
    );
  }
}
//pages/songs_page.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/song_model.dart';
import '../providers/language_provider.dart';
import '../providers/favorites_provider.dart';
import '../providers/theme_provider.dart';
import '../utils/constants.dart';
import '../utils/text_styles.dart';
import '../utils/mock_data.dart';
import 'song_view_page.dart';

class SongsPage extends StatefulWidget {
  const SongsPage({super.key});

  @override
  State<SongsPage> createState() => _SongsPageState();
}

class _SongsPageState extends State<SongsPage> with TickerProviderStateMixin {
  final TextEditingController _searchController = TextEditingController();
  final FocusNode _searchFocusNode = FocusNode();
  
  List<Song> _filteredSongs = [];
  List<Song> _allSongs = [];
  
  String _searchQuery = '';
  SortCriteria _sortBy = SortCriteria.title;
  SortOrder _sortOrder = SortOrder.ascending;
  bool _showOnlyFavorites = false;
  bool _isSearching = false;
  
  late AnimationController _fabController;
  late AnimationController _searchController2;
  late Animation<double> _fabAnimation;
  late Animation<double> _searchAnimation;

  @override
  void initState() {
    super.initState();
    _initializeData();
    _initializeAnimations();
    _searchController.addListener(_onSearchChanged);
  }

  void _initializeAnimations() {
    _fabController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    
    _searchController2 = AnimationController(
      duration: const Duration(milliseconds: 400),
      vsync: this,
    );
    
    _fabAnimation = CurvedAnimation(
      parent: _fabController,
      curve: Curves.easeInOut,
    );
    
    _searchAnimation = CurvedAnimation(
      parent: _searchController2,
      curve: Curves.easeInOutCubic,
    );
    
    _fabController.forward();
  }

  void _initializeData() {
    _allSongs = MockData.getSongs();
    _filteredSongs = List.from(_allSongs);
    _applySorting();
  }

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    _fabController.dispose();
    _searchController2.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    setState(() {
      _searchQuery = _searchController.text.toLowerCase();
      _filterSongs();
    });
  }

  void _filterSongs() {
    List<Song> filtered = _allSongs.where((song) {
      // Search in title, singer, writer, and lyrics
      final titleMatch = song.title.toLowerCase().contains(_searchQuery);
      final singerMatch = song.singer.toLowerCase().contains(_searchQuery);
      final writerMatch = song.writer.toLowerCase().contains(_searchQuery);
      
      // Search in lyrics across all languages
      final lyricsMatch = song.lyrics.values.any((lyrics) =>
          lyrics.toLowerCase().contains(_searchQuery));
      
      final matchesSearch = _searchQuery.isEmpty || 
          titleMatch || singerMatch || writerMatch || lyricsMatch;
      
      // Filter by favorites if enabled
      final favoritesProvider = context.read<FavoritesProvider>();
      final matchesFavorites = !_showOnlyFavorites || 
          favoritesProvider.isFavorite(song.id, 'song');
      
      return matchesSearch && matchesFavorites;
    }).toList();
    
    _filteredSongs = filtered;
    _applySorting();
  }

  void _applySorting() {
    _filteredSongs.sort((a, b) {
      int comparison = 0;
      
      switch (_sortBy) {
        case SortCriteria.title:
          comparison = a.title.compareTo(b.title);
          break;
        case SortCriteria.singer:
          comparison = a.singer.compareTo(b.singer);
          break;
        case SortCriteria.writer:
          comparison = a.writer.compareTo(b.writer);
          break;
      }
      
      return _sortOrder == SortOrder.ascending ? comparison : -comparison;
    });
  }

  void _toggleSearch() {
    setState(() {
      _isSearching = !_isSearching;
      if (_isSearching) {
        _searchController2.forward();
        Future.delayed(const Duration(milliseconds: 200), () {
          _searchFocusNode.requestFocus();
        });
      } else {
        _searchController2.reverse();
        _searchController.clear();
        _searchFocusNode.unfocus();
      }
    });
  }

  void _showSortOptions() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => _buildSortBottomSheet(),
    );
  }

  Widget _buildSortBottomSheet() {
    final themeProvider = context.read<ThemeProvider>();
    final isDark = themeProvider.isDarkMode;
    
    return Container(
      decoration: BoxDecoration(
        color: isDark ? AppColors.cardDark : AppColors.cardLight,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.2),
            blurRadius: 20,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Handle bar
              Center(
                child: Container(
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: Colors.grey[400],
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
              ),
              const SizedBox(height: 20),
              
              Text(
                'Sort & Filter',
                style: AppTextStyles.headingLarge.copyWith(
                  color: isDark ? AppColors.textDark : AppColors.textLight,
                ),
              ),
              const SizedBox(height: 20),
              
              // Sort criteria
              Text(
                'Sort by',
                style: AppTextStyles.bodyMedium.copyWith(
                  color: isDark ? AppColors.textSecondaryDark : AppColors.textSecondaryLight,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(height: 12),
              
              ...SortCriteria.values.map((criteria) => 
                _buildSortOption(criteria, isDark)),
              
              const SizedBox(height: 20),
              
              // Sort order
              Text(
                'Order',
                style: AppTextStyles.bodyMedium.copyWith(
                  color: isDark ? AppColors.textSecondaryDark : AppColors.textSecondaryLight,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(height: 12),
              
              Row(
                children: [
                  Expanded(
                    child: _buildOrderButton(
                      'Ascending',
                      SortOrder.ascending,
                      Icons.arrow_upward,
                      isDark,
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: _buildOrderButton(
                      'Descending',
                      SortOrder.descending,
                      Icons.arrow_downward,
                      isDark,
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: 20),
              
              // Favorites filter
              Container(
                decoration: BoxDecoration(
                  color: isDark ? AppColors.surfaceDark : AppColors.surfaceLight,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: SwitchListTile(
                  title: Text(
                    'Show only favorites',
                    style: AppTextStyles.bodyMedium.copyWith(
                      color: isDark ? AppColors.textDark : AppColors.textLight,
                    ),
                  ),
                  subtitle: Text(
                    'Filter to show only your favorite songs',
                    style: AppTextStyles.bodySmall.copyWith(
                      color: isDark ? AppColors.textSecondaryDark : AppColors.textSecondaryLight,
                    ),
                  ),
                  value: _showOnlyFavorites,
                  activeColor: AppColors.primary,
                  onChanged: (value) {
                    setState(() {
                      _showOnlyFavorites = value;
                      _filterSongs();
                    });
                    Navigator.pop(context);
                  },
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSortOption(SortCriteria criteria, bool isDark) {
    final isSelected = _sortBy == criteria;
    String label;
    
    switch (criteria) {
      case SortCriteria.title:
        label = 'Title';
        break;
      case SortCriteria.singer:
        label = 'Singer';
        break;
      case SortCriteria.writer:
        label = 'Writer';
        break;
    }
    
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: InkWell(
        onTap: () {
          setState(() {
            _sortBy = criteria;
            _applySorting();
          });
          Navigator.pop(context);
        },
        borderRadius: BorderRadius.circular(12),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          decoration: BoxDecoration(
            color: isSelected 
                ? AppColors.primary.withOpacity(0.1)
                : (isDark ? AppColors.surfaceDark : AppColors.surfaceLight),
            borderRadius: BorderRadius.circular(12),
            border: isSelected
                ? Border.all(color: AppColors.primary, width: 1)
                : null,
          ),
          child: Row(
            children: [
              Icon(
                isSelected ? Icons.radio_button_checked : Icons.radio_button_unchecked,
                color: isSelected ? AppColors.primary : Colors.grey,
                size: 20,
              ),
              const SizedBox(width: 12),
              Text(
                label,
                style: AppTextStyles.bodyMedium.copyWith(
                  color: isSelected 
                      ? AppColors.primary 
                      : (isDark ? AppColors.textDark : AppColors.textLight),
                  fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildOrderButton(String label, SortOrder order, IconData icon, bool isDark) {
    final isSelected = _sortOrder == order;
    
    return InkWell(
      onTap: () {
        setState(() {
          _sortOrder = order;
          _applySorting();
        });
        Navigator.pop(context);
      },
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 12),
        decoration: BoxDecoration(
          color: isSelected 
              ? AppColors.primary 
              : (isDark ? AppColors.surfaceDark : AppColors.surfaceLight),
          borderRadius: BorderRadius.circular(12),
          border: !isSelected
              ? Border.all(color: Colors.grey.withOpacity(0.3))
              : null,
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              icon,
              color: isSelected ? Colors.white : Colors.grey,
              size: 18,
            ),
            const SizedBox(width: 8),
            Text(
              label,
              style: AppTextStyles.bodySmall.copyWith(
                color: isSelected 
                    ? Colors.white 
                    : (isDark ? AppColors.textDark : AppColors.textLight),
                fontWeight: FontWeight.w600,
              ),
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Consumer3<ThemeProvider, LanguageProvider, FavoritesProvider>(
      builder: (context, themeProvider, languageProvider, favoritesProvider, _) {
        final isDark = themeProvider.isDarkMode;
        
        return Scaffold(
          backgroundColor: isDark ? AppColors.backgroundDark : AppColors.backgroundLight,
          body: CustomScrollView(
            slivers: [
              // Custom App Bar with Search
              SliverAppBar(
                expandedHeight: _isSearching ? 160 : 120,
                floating: false,
                pinned: true,
                backgroundColor: isDark ? AppColors.surfaceDark : AppColors.surfaceLight,
                elevation: 0,
                flexibleSpace: FlexibleSpaceBar(
                  background: Container(
                    decoration: BoxDecoration(
                      gradient: LinearGradient(
                        begin: Alignment.topLeft,
                        end: Alignment.bottomRight,
                        colors: [
                          AppColors.primary,
                          AppColors.secondary,
                        ],
                      ),
                    ),
                    child: SafeArea(
                      child: Padding(
                        padding: const EdgeInsets.all(16),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Row(
                              children: [
                                Expanded(
                                  child: Column(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        'Devotional Songs',
                                        style: AppTextStyles.headingLarge.copyWith(
                                          color: Colors.white,
                                          fontWeight: FontWeight.bold,
                                        ),
                                      ),
                                      const SizedBox(height: 4),
                                      Text(
                                        '${_filteredSongs.length} songs',
                                        style: AppTextStyles.bodyMedium.copyWith(
                                          color: Colors.white.withOpacity(0.9),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                                IconButton(
                                  onPressed: _toggleSearch,
                                  icon: AnimatedSwitcher(
                                    duration: const Duration(milliseconds: 200),
                                    child: Icon(
                                      _isSearching ? Icons.close : Icons.search,
                                      key: ValueKey(_isSearching),
                                      color: Colors.white,
                                    ),
                                  ),
                                ),
                                IconButton(
                                  onPressed: _showSortOptions,
                                  icon: const Icon(
                                    Icons.tune,
                                    color: Colors.white,
                                  ),
                                ),
                              ],
                            ),
                            
                            // Search Bar
                            AnimatedBuilder(
                              animation: _searchAnimation,
                              builder: (context, child) {
                                return SizeTransition(
                                  sizeFactor: _searchAnimation,
                                  child: Padding(
                                    padding: const EdgeInsets.only(top: 16),
                                    child: Container(
                                      decoration: BoxDecoration(
                                        color: Colors.white.withOpacity(0.2),
                                        borderRadius: BorderRadius.circular(25),
                                        border: Border.all(
                                          color: Colors.white.withOpacity(0.3),
                                        ),
                                      ),
                                      child: TextField(
                                        controller: _searchController,
                                        focusNode: _searchFocusNode,
                                        style: const TextStyle(color: Colors.white),
                                        decoration: InputDecoration(
                                          hintText: 'Search songs, singers, lyrics...',
                                          hintStyle: TextStyle(
                                            color: Colors.white.withOpacity(0.7),
                                          ),
                                          prefixIcon: const Icon(
                                            Icons.search,
                                            color: Colors.white,
                                          ),
                                          suffixIcon: _searchQuery.isNotEmpty
                                              ? IconButton(
                                                  onPressed: () {
                                                    _searchController.clear();
                                                  },
                                                  icon: const Icon(
                                                    Icons.clear,
                                                    color: Colors.white,
                                                  ),
                                                )
                                              : null,
                                          border: InputBorder.none,
                                          contentPadding: const EdgeInsets.symmetric(
                                            horizontal: 20,
                                            vertical: 16,
                                          ),
                                        ),
                                      ),
                                    ),
                                  ),
                                );
                              },
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
              ),
              
              // Songs List
              SliverPadding(
                padding: const EdgeInsets.all(16),
                sliver: _filteredSongs.isEmpty
                    ? SliverFillRemaining(
                        child: _buildEmptyState(isDark),
                      )
                    : SliverList(
                        delegate: SliverChildBuilderDelegate(
                          (context, index) {
                            final song = _filteredSongs[index];
                            return Padding(
                              padding: const EdgeInsets.only(bottom: 12),
                              child: _buildSongTile(song, isDark, favoritesProvider),
                            );
                          },
                          childCount: _filteredSongs.length,
                        ),
                      ),
              ),
            ],
          ),
          
          // Floating Action Button
          floatingActionButton: ScaleTransition(
            scale: _fabAnimation,
            child: FloatingActionButton.extended(
              onPressed: () {
                // Navigate to random song or shuffle play
                if (_filteredSongs.isNotEmpty) {
                  final randomSong = _filteredSongs[
                      DateTime.now().millisecond % _filteredSongs.length];
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => SongViewPage(song: randomSong),
                    ),
                  );
                }
              },
              backgroundColor: AppColors.accent,
              icon: const Icon(Icons.shuffle, color: Colors.white),
              label: Text(
                'Shuffle',
                style: AppTextStyles.bodyMedium.copyWith(
                  color: Colors.white,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildSongTile(Song song, bool isDark, FavoritesProvider favoritesProvider) {
    final isFavorite = favoritesProvider.isFavorite(song.id, 'song');
    
    return Container(
      decoration: BoxDecoration(
        color: isDark ? AppColors.cardDark : AppColors.cardLight,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: InkWell(
        onTap: () {
          Navigator.push(
            context,
            PageRouteBuilder(
              pageBuilder: (context, animation, secondaryAnimation) =>
                  SongViewPage(song: song),
              transitionsBuilder: (context, animation, secondaryAnimation, child) {
                return SlideTransition(
                  position: Tween<Offset>(
                    begin: const Offset(1.0, 0.0),
                    end: Offset.zero,
                  ).animate(CurvedAnimation(
                    parent: animation,
                    curve: Curves.easeInOutCubic,
                  )),
                  child: child,
                );
              },
            ),
          );
        },
        borderRadius: BorderRadius.circular(16),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Song Icon
              Container(
                width: 56,
                height: 56,
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                    colors: [
                      AppColors.primary,
                      AppColors.secondary,
                    ],
                  ),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  song.iconType == SongIconType.music 
                      ? Icons.music_note 
                      : Icons.temple_hindu,
                  color: Colors.white,
                  size: 28,
                ),
              ),
              
              const SizedBox(width: 16),
              
              // Song Details
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      song.title,
                      style: AppTextStyles.bodyLarge.copyWith(
                        color: isDark ? AppColors.textDark : AppColors.textLight,
                        fontWeight: FontWeight.w600,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 4),
                    Text(
                      'Singer: ${song.singer}',
                      style: AppTextStyles.bodyMedium.copyWith(
                        color: isDark ? AppColors.textSecondaryDark : AppColors.textSecondaryLight,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 2),
                    Text(
                      'Writer: ${song.writer}',
                      style: AppTextStyles.bodySmall.copyWith(
                        color: isDark ? AppColors.textSecondaryDark : AppColors.textSecondaryLight,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),
              
              // Favorite Button
              IconButton(
                onPressed: () {
                  favoritesProvider.toggleFavorite(song.id, 'song', {
                    'title': song.title,
                    'singer': song.singer,
                    'writer': song.writer,
                  });
                  
                  // Show feedback
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text(
                        isFavorite 
                            ? 'Removed from favorites'
                            : 'Added to favorites',
                      ),
                      duration: const Duration(seconds: 1),
                      behavior: SnackBarBehavior.floating,
                      backgroundColor: AppColors.primary,
                    ),
                  );
                },
                icon: AnimatedSwitcher(
                  duration: const Duration(milliseconds: 200),
                  child: Icon(
                    isFavorite ? Icons.favorite : Icons.favorite_border,
                    key: ValueKey(isFavorite),
                    color: isFavorite ? AppColors.accent : Colors.grey,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyState(bool isDark) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Container(
              width: 120,
              height: 120,
              decoration: BoxDecoration(
                color: (isDark ? AppColors.surfaceDark : AppColors.surfaceLight)
                    .withOpacity(0.5),
                shape: BoxShape.circle,
              ),
              child: Icon(
                _showOnlyFavorites ? Icons.favorite_outline : Icons.search_off,
                size: 60,
                color: Colors.grey,
              ),
            ),
            const SizedBox(height: 24),
            Text(
              _showOnlyFavorites 
                  ? 'No favorite songs'
                  : _searchQuery.isNotEmpty 
                      ? 'No songs found'
                      : 'No songs available',
              style: AppTextStyles.headingMedium.copyWith(
                color: isDark ? AppColors.textDark : AppColors.textLight,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              _showOnlyFavorites
                  ? 'Start adding songs to your favorites to see them here.'
                  : _searchQuery.isNotEmpty
                      ? 'Try adjusting your search terms or filters.'
                      : 'Songs will appear here when available.',
              textAlign: TextAlign.center,
              style: AppTextStyles.bodyMedium.copyWith(
                color: isDark ? AppColors.textSecondaryDark : AppColors.textSecondaryLight,
              ),
            ),
            if (_showOnlyFavorites || _searchQuery.isNotEmpty) ...[
              const SizedBox(height: 24),
              ElevatedButton.icon(
                onPressed: () {
                  if (_showOnlyFavorites) {
                    setState(() {
                      _showOnlyFavorites = false;
                      _filterSongs();
                    });
                  } else if (_searchQuery.isNotEmpty) {
                    _searchController.clear();
                  }
                },
                icon: Icon(_showOnlyFavorites ? Icons.clear_all : Icons.clear),
                label: Text(_showOnlyFavorites ? 'Show All Songs' : 'Clear Search'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: AppColors.primary,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(25),
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

// Enums for sorting
enum SortCriteria { title, singer, writer }
enum SortOrder { ascending, descending }
//pages/song_view_page.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:share_plus/share_plus.dart';
import '../models/song_model.dart';
import '../providers/theme_provider.dart';
import '../providers/language_provider.dart';
import '../providers/favorites_provider.dart';
import '../utils/constants.dart';
import '../utils/text_styles.dart';
import '../utils/helpers.dart';

class SongViewPage extends StatefulWidget {
  final Song song;
  final String? heroTag;

  const SongViewPage({
    Key? key,
    required this.song,
    this.heroTag,
  }) : super(key: key);

  @override
  State<SongViewPage> createState() => _SongViewPageState();
}

class _SongViewPageState extends State<SongViewPage>
    with TickerProviderStateMixin {
  late ScrollController _scrollController;
  late PageController _pageController;
  late AnimationController _appBarAnimationController;
  late AnimationController _fabAnimationController;
  late Animation<double> _appBarOpacity;
  late Animation<double> _fabScale;

  bool _isAppBarVisible = true;
  bool _isFullScreen = false;
  double _fontSize = 16.0;
  int _currentLanguageIndex = 0;

  final List<String> _languageKeys = ['tamil', 'telugu', 'english_tamil', 'english_telugu'];
  final List<String> _languageLabels = ['à®¤à®®à®¿à®´à¯', 'à°¤à±†à°²à±à°—à±', 'EN-Tamil', 'EN-Telugu'];

  @override
  void initState() {
    super.initState();
    _setupControllers();
    _setupAnimations();
    _setupScrollListener();
    
    // Set initial language based on user preference
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final languageProvider = Provider.of<LanguageProvider>(context, listen: false);
      _currentLanguageIndex = _getLanguageIndex(languageProvider.currentLanguage);
      _pageController.animateToPage(
        _currentLanguageIndex,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
    });
  }

  void _setupControllers() {
    _scrollController = ScrollController();
    _pageController = PageController(initialPage: _currentLanguageIndex);
    _appBarAnimationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _fabAnimationController = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );
  }

  void _setupAnimations() {
    _appBarOpacity = Tween<double>(
      begin: 1.0,
      end: 0.0,
    ).animate(CurvedAnimation(
      parent: _appBarAnimationController,
      curve: Curves.easeInOut,
    ));

    _fabScale = Tween<double>(
      begin: 1.0,
      end: 0.0,
    ).animate(CurvedAnimation(
      parent: _fabAnimationController,
      curve: Curves.easeInOut,
    ));
  }

  void _setupScrollListener() {
    _scrollController.addListener(() {
      final scrollPosition = _scrollController.position.pixels;
      final maxScroll = _scrollController.position.maxScrollExtent;
      
      // Hide app bar when scrolling up (immersive mode)
      if (scrollPosition > 100 && _isAppBarVisible) {
        setState(() {
          _isAppBarVisible = false;
        });
        _appBarAnimationController.forward();
        _fabAnimationController.forward();
      } else if (scrollPosition <= 100 && !_isAppBarVisible) {
        setState(() {
          _isAppBarVisible = true;
        });
        _appBarAnimationController.reverse();
        _fabAnimationController.reverse();
      }

      // Enter full screen mode when scrolled significantly
      if (scrollPosition > maxScroll * 0.3 && !_isFullScreen) {
        setState(() {
          _isFullScreen = true;
        });
        _enterFullScreen();
      } else if (scrollPosition <= maxScroll * 0.2 && _isFullScreen) {
        setState(() {
          _isFullScreen = false;
        });
        _exitFullScreen();
      }
    });
  }

  void _enterFullScreen() {
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);
  }

  void _exitFullScreen() {
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.edgeToEdge);
  }

  int _getLanguageIndex(String language) {
    switch (language) {
      case 'ta': return 0;
      case 'te': return 1;
      case 'en-ta': return 2;
      case 'en-te': return 3;
      default: return 0;
    }
  }

  String _getCurrentLyrics() {
    switch (_currentLanguageIndex) {
      case 0: return widget.song.lyrics['tamil'] ?? '';
      case 1: return widget.song.lyrics['telugu'] ?? '';
      case 2: return widget.song.lyrics['english_tamil'] ?? '';
      case 3: return widget.song.lyrics['english_telugu'] ?? '';
      default: return widget.song.lyrics['tamil'] ?? '';
    }
  }

  void _shareSong() {
    final lyrics = _getCurrentLyrics();
    final language = _languageLabels[_currentLanguageIndex];
    
    final shareText = '''
ðŸ•‰ï¸ ${widget.song.title} ðŸ•‰ï¸

Singer: ${widget.song.singer}
Writer: ${widget.song.writer}
Language: $language

$lyrics

---
Shared from Lord Ayyappa Devotional App
''';
    
    Share.share(shareText);
  }

  void _showFontSizeDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Font Size'),
        content: StatefulBuilder(
          builder: (context, setState) => Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                'Sample Text',
                style: TextStyle(fontSize: _fontSize),
              ),
              const SizedBox(height: 16),
              Slider(
                value: _fontSize,
                min: 12.0,
                max: 24.0,
                divisions: 12,
                label: '${_fontSize.toInt()}px',
                onChanged: (value) {
                  setState(() {
                    _fontSize = value;
                  });
                  this.setState(() {});
                },
              ),
              Text('${_fontSize.toInt()}px'),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Done'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Consumer3<ThemeProvider, LanguageProvider, FavoritesProvider>(
      builder: (context, themeProvider, languageProvider, favoritesProvider, child) {
        final isDark = themeProvider.isDarkMode;
        final isFavorite = favoritesProvider.isFavorite(widget.song.id);
        
        return Scaffold(
          backgroundColor: isDark 
              ? AppColors.darkBackground 
              : AppColors.lightBackground,
          body: SafeArea(
            child: Stack(
              children: [
                // Gradient Background
                Container(
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      begin: Alignment.topCenter,
                      end: Alignment.bottomCenter,
                      colors: isDark
                          ? [
                              AppColors.primaryColor.withOpacity(0.1),
                              AppColors.darkBackground,
                            ]
                          : [
                              AppColors.primaryColor.withOpacity(0.05),
                              AppColors.lightBackground,
                            ],
                    ),
                  ),
                ),
                
                // Main Content
                Column(
                  children: [
                    // Custom App Bar
                    AnimatedBuilder(
                      animation: _appBarOpacity,
                      builder: (context, child) => Transform.translate(
                        offset: Offset(0, -60 * _appBarOpacity.value),
                        child: Opacity(
                          opacity: 1 - _appBarOpacity.value,
                          child: _buildAppBar(isDark, isFavorite, favoritesProvider),
                        ),
                      ),
                    ),
                    
                    // Language Tabs
                    AnimatedBuilder(
                      animation: _appBarOpacity,
                      builder: (context, child) => Transform.translate(
                        offset: Offset(0, -60 * _appBarOpacity.value),
                        child: Opacity(
                          opacity: 1 - _appBarOpacity.value,
                          child: _buildLanguageTabs(isDark),
                        ),
                      ),
                    ),
                    
                    // Lyrics Content
                    Expanded(
                      child: PageView.builder(
                        controller: _pageController,
                        onPageChanged: (index) {
                          setState(() {
                            _currentLanguageIndex = index;
                          });
                        },
                        itemCount: 4,
                        itemBuilder: (context, index) {
                          return _buildLyricsView(index, isDark);
                        },
                      ),
                    ),
                  ],
                ),
                
                // Floating Action Buttons
                AnimatedBuilder(
                  animation: _fabScale,
                  builder: (context, child) => Transform.scale(
                    scale: 1 - _fabScale.value,
                    child: Opacity(
                      opacity: 1 - _fabScale.value,
                      child: _buildFloatingButtons(isDark),
                    ),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildAppBar(bool isDark, bool isFavorite, FavoritesProvider favoritesProvider) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: (isDark ? AppColors.darkSurface : AppColors.lightSurface)
            .withOpacity(0.9),
        borderRadius: const BorderRadius.only(
          bottomLeft: Radius.circular(20),
          bottomRight: Radius.circular(20),
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Row(
        children: [
          IconButton(
            onPressed: () => Navigator.pop(context),
            icon: Icon(
              Icons.arrow_back_ios,
              color: isDark ? Colors.white : AppColors.darkText,
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Hero(
                  tag: widget.heroTag ?? 'song_${widget.song.id}',
                  child: Text(
                    widget.song.title,
                    style: AppTextStyles.headlineMedium.copyWith(
                      color: isDark ? Colors.white : AppColors.darkText,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  'Singer: ${widget.song.singer}',
                  style: AppTextStyles.bodySmall.copyWith(
                    color: isDark ? Colors.white70 : AppColors.darkText.withOpacity(0.7),
                  ),
                ),
                Text(
                  'Writer: ${widget.song.writer}',
                  style: AppTextStyles.bodySmall.copyWith(
                    color: isDark ? Colors.white70 : AppColors.darkText.withOpacity(0.7),
                  ),
                ),
              ],
            ),
          ),
          IconButton(
            onPressed: () {
              if (isFavorite) {
                favoritesProvider.removeFavorite(widget.song.id);
              } else {
                favoritesProvider.addFavorite(widget.song.id);
              }
              HapticFeedback.lightImpact();
            },
            icon: Icon(
              isFavorite ? Icons.favorite : Icons.favorite_border,
              color: isFavorite ? AppColors.accentColor : (isDark ? Colors.white : AppColors.darkText),
            ),
          ),
          IconButton(
            onPressed: _shareSong,
            icon: Icon(
              Icons.share,
              color: isDark ? Colors.white : AppColors.darkText,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildLanguageTabs(bool isDark) {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: (isDark ? AppColors.darkSurface : AppColors.lightSurface)
            .withOpacity(0.9),
        borderRadius: BorderRadius.circular(15),
      ),
      child: Row(
        children: List.generate(
          _languageLabels.length,
          (index) => Expanded(
            child: GestureDetector(
              onTap: () {
                setState(() {
                  _currentLanguageIndex = index;
                });
                _pageController.animateToPage(
                  index,
                  duration: const Duration(milliseconds: 300),
                  curve: Curves.easeInOut,
                );
              },
              child: AnimatedContainer(
                duration: const Duration(milliseconds: 200),
                padding: const EdgeInsets.symmetric(vertical: 12),
                decoration: BoxDecoration(
                  color: _currentLanguageIndex == index
                      ? AppColors.primaryColor
                      : Colors.transparent,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  _languageLabels[index],
                  textAlign: TextAlign.center,
                  style: AppTextStyles.bodyMedium.copyWith(
                    color: _currentLanguageIndex == index
                        ? Colors.white
                        : (isDark ? Colors.white : AppColors.darkText),
                    fontWeight: _currentLanguageIndex == index
                        ? FontWeight.bold
                        : FontWeight.normal,
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLyricsView(int languageIndex, bool isDark) {
    final lyrics = _getLyricsForLanguage(languageIndex);
    
    return Container(
      padding: const EdgeInsets.all(16),
      child: SingleChildScrollView(
        controller: _scrollController,
        physics: const BouncingScrollPhysics(),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const SizedBox(height: 20),
            Container(
              padding: const EdgeInsets.all(20),
              decoration: BoxDecoration(
                color: (isDark ? AppColors.darkSurface : AppColors.lightSurface)
                    .withOpacity(0.8),
                borderRadius: BorderRadius.circular(20),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.1),
                    blurRadius: 20,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: SelectableText(
                lyrics,
                style: AppTextStyles.bodyLarge.copyWith(
                  fontSize: _fontSize,
                  height: 1.8,
                  color: isDark ? Colors.white : AppColors.darkText,
                  fontFamily: _getLanguageFont(languageIndex),
                ),
              ),
            ),
            const SizedBox(height: 100), // Extra space for better scrolling
          ],
        ),
      ),
    );
  }

  String _getLyricsForLanguage(int index) {
    switch (index) {
      case 0: return widget.song.lyrics['tamil'] ?? '';
      case 1: return widget.song.lyrics['telugu'] ?? '';
      case 2: return widget.song.lyrics['english_tamil'] ?? '';
      case 3: return widget.song.lyrics['english_telugu'] ?? '';
      default: return widget.song.lyrics['tamil'] ?? '';
    }
  }

  String? _getLanguageFont(int index) {
    switch (index) {
      case 0: return 'TamilFont';
      case 1: return 'TeluguFont';
      default: return null;
    }
  }

  Widget _buildFloatingButtons(bool isDark) {
    return Positioned(
      bottom: 20,
      right: 20,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          FloatingActionButton.small(
            heroTag: 'font_size',
            onPressed: _showFontSizeDialog,
            backgroundColor: AppColors.primaryColor,
            child: const Icon(Icons.format_size, color: Colors.white),
          ),
          const SizedBox(height: 8),
          FloatingActionButton.small(
            heroTag: 'scroll_top',
            onPressed: () {
              _scrollController.animateTo(
                0,
                duration: const Duration(milliseconds: 500),
                curve: Curves.easeInOut,
              );
            },
            backgroundColor: AppColors.accentColor,
            child: const Icon(Icons.keyboard_arrow_up, color: Colors.white),
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _pageController.dispose();
    _appBarAnimationController.dispose();
    _fabAnimationController.dispose();
    _exitFullScreen(); // Ensure we exit full screen mode
    super.dispose();
  }
}
//providers/favorites_provider.dart
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/song_model.dart';
import '../models/devotional_content.dart';
import '../utils/mock_data.dart';
import 'dart:convert';

/// Provider for managing user favorites across the app
/// Handles songs, mantras, quotes, and other devotional content
class FavoritesProvider with ChangeNotifier {
  // Private fields
  List<Song> _favoriteSongs = [];
  List<Mantra> _favoriteMantras = [];
  List<DevotionalQuote> _favoriteQuotes = [];
  List<HistorySection> _favoriteHistory = [];
  Set<String> _favoriteSongIds = {};
  Set<String> _favoriteMantraIds = {};
  Set<String> _favoriteQuoteIds = {};
  Set<String> _favoriteHistoryIds = {};
  bool _isLoading = false;
  String _error = '';

  // Getters
  List<Song> get favoriteSongs => List.unmodifiable(_favoriteSongs);
  List<Mantra> get favoriteMantras => List.unmodifiable(_favoriteMantras);
  List<DevotionalQuote> get favoriteQuotes => List.unmodifiable(_favoriteQuotes);
  List<HistorySection> get favoriteHistory => List.unmodifiable(_favoriteHistory);
  Set<String> get favoriteSongIds => Set.unmodifiable(_favoriteSongIds);
  Set<String> get favoriteMantraIds => Set.unmodifiable(_favoriteMantraIds);
  Set<String> get favoriteQuoteIds => Set.unmodifiable(_favoriteQuoteIds);
  Set<String> get favoriteHistoryIds => Set.unmodifiable(_favoriteHistoryIds);
  
  bool get isLoading => _isLoading;
  String get error => _error;
  
  /// Total count of all favorites
  int get totalFavoritesCount => 
      _favoriteSongs.length + 
      _favoriteMantras.length + 
      _favoriteQuotes.length + 
      _favoriteHistory.length;

  /// Check if any content exists in favorites
  bool get hasFavorites => totalFavoritesCount > 0;

  /// Recently added favorites (last 5 items)
  List<dynamic> get recentFavorites {
    List<dynamic> recent = [];
    
    // Add recent songs (last 2)
    if (_favoriteSongs.length > 0) {
      recent.addAll(_favoriteSongs.take(2));
    }
    
    // Add recent mantras (last 2)
    if (_favoriteMantras.length > 0) {
      recent.addAll(_favoriteMantras.take(2));
    }
    
    // Add recent quote (last 1)
    if (_favoriteQuotes.length > 0) {
      recent.add(_favoriteQuotes.first);
    }
    
    return recent.take(5).toList();
  }

  /// Initialize favorites from storage
  Future<void> initializeFavorites() async {
    _setLoading(true);
    _clearError();
    
    try {
      await _loadFavoritesFromStorage();
      await _syncFavoriteData();
    } catch (e) {
      _setError('Failed to load favorites: ${e.toString()}');
      debugPrint('FavoritesProvider initialization error: $e');
    } finally {
      _setLoading(false);
    }
  }

  /// Load favorite IDs from SharedPreferences
  Future<void> _loadFavoritesFromStorage() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // Load favorite song IDs
      final songIds = prefs.getStringList('favorite_song_ids') ?? [];
      _favoriteSongIds = songIds.toSet();
      
      // Load favorite mantra IDs
      final mantraIds = prefs.getStringList('favorite_mantra_ids') ?? [];
      _favoriteMantraIds = mantraIds.toSet();
      
      // Load favorite quote IDs
      final quoteIds = prefs.getStringList('favorite_quote_ids') ?? [];
      _favoriteQuoteIds = quoteIds.toSet();
      
      // Load favorite history IDs
      final historyIds = prefs.getStringList('favorite_history_ids') ?? [];
      _favoriteHistoryIds = historyIds.toSet();
      
    } catch (e) {
      debugPrint('Error loading favorites from storage: $e');
      rethrow;
    }
  }

  /// Sync favorite data objects with IDs
  Future<void> _syncFavoriteData() async {
    try {
      // Sync songs
      _favoriteSongs = MockData.songs
          .where((song) => _favoriteSongIds.contains(song.id))
          .toList();
      
      // Sync mantras
      _favoriteMantras = MockData.mantras
          .where((mantra) => _favoriteMantraIds.contains(mantra.id))
          .toList();
      
      // Sync quotes
      _favoriteQuotes = MockData.devotionalQuotes
          .where((quote) => _favoriteQuoteIds.contains(quote.id))
          .toList();
      
      // Sync history
      _favoriteHistory = MockData.historyContent
          .where((history) => _favoriteHistoryIds.contains(history.id))
          .toList();
          
    } catch (e) {
      debugPrint('Error syncing favorite data: $e');
      rethrow;
    }
  }

  /// Toggle song favorite status
  Future<void> toggleSongFavorite(Song song) async {
    try {
      if (_favoriteSongIds.contains(song.id)) {
        await _removeSongFromFavorites(song);
      } else {
        await _addSongToFavorites(song);
      }
    } catch (e) {
      _setError('Failed to update song favorite: ${e.toString()}');
      debugPrint('Error toggling song favorite: $e');
    }
  }

  /// Add song to favorites
  Future<void> _addSongToFavorites(Song song) async {
    _favoriteSongIds.add(song.id);
    _favoriteSongs.insert(0, song); // Add to beginning for recent access
    await _saveFavoriteSongIds();
    notifyListeners();
  }

  /// Remove song from favorites
  Future<void> _removeSongFromFavorites(Song song) async {
    _favoriteSongIds.remove(song.id);
    _favoriteSongs.removeWhere((s) => s.id == song.id);
    await _saveFavoriteSongIds();
    notifyListeners();
  }

  /// Toggle mantra favorite status
  Future<void> toggleMantraFavorite(Mantra mantra) async {
    try {
      if (_favoriteMantraIds.contains(mantra.id)) {
        await _removeMantraFromFavorites(mantra);
      } else {
        await _addMantraToFavorites(mantra);
      }
    } catch (e) {
      _setError('Failed to update mantra favorite: ${e.toString()}');
      debugPrint('Error toggling mantra favorite: $e');
    }
  }

  /// Add mantra to favorites
  Future<void> _addMantraToFavorites(Mantra mantra) async {
    _favoriteMantraIds.add(mantra.id);
    _favoriteMantras.insert(0, mantra);
    await _saveFavoriteMantraIds();
    notifyListeners();
  }

  /// Remove mantra from favorites
  Future<void> _removeMantraFromFavorites(Mantra mantra) async {
    _favoriteMantraIds.remove(mantra.id);
    _favoriteMantras.removeWhere((m) => m.id == mantra.id);
    await _saveFavoriteMantraIds();
    notifyListeners();
  }

  /// Toggle quote favorite status
  Future<void> toggleQuoteFavorite(DevotionalQuote quote) async {
    try {
      if (_favoriteQuoteIds.contains(quote.id)) {
        await _removeQuoteFromFavorites(quote);
      } else {
        await _addQuoteToFavorites(quote);
      }
    } catch (e) {
      _setError('Failed to update quote favorite: ${e.toString()}');
      debugPrint('Error toggling quote favorite: $e');
    }
  }

  /// Add quote to favorites
  Future<void> _addQuoteToFavorites(DevotionalQuote quote) async {
    _favoriteQuoteIds.add(quote.id);
    _favoriteQuotes.insert(0, quote);
    await _saveFavoriteQuoteIds();
    notifyListeners();
  }

  /// Remove quote from favorites
  Future<void> _removeQuoteFromFavorites(DevotionalQuote quote) async {
    _favoriteQuoteIds.remove(quote.id);
    _favoriteQuotes.removeWhere((q) => q.id == quote.id);
    await _saveFavoriteQuoteIds();
    notifyListeners();
  }

  /// Toggle history favorite status
  Future<void> toggleHistoryFavorite(HistorySection history) async {
    try {
      if (_favoriteHistoryIds.contains(history.id)) {
        await _removeHistoryFromFavorites(history);
      } else {
        await _addHistoryToFavorites(history);
      }
    } catch (e) {
      _setError('Failed to update history favorite: ${e.toString()}');
      debugPrint('Error toggling history favorite: $e');
    }
  }

  /// Add history to favorites
  Future<void> _addHistoryToFavorites(HistorySection history) async {
    _favoriteHistoryIds.add(history.id);
    _favoriteHistory.insert(0, history);
    await _saveFavoriteHistoryIds();
    notifyListeners();
  }

  /// Remove history from favorites
  Future<void> _removeHistoryFromFavorites(HistorySection history) async {
    _favoriteHistoryIds.remove(history.id);
    _favoriteHistory.removeWhere((h) => h.id == history.id);
    await _saveFavoriteHistoryIds();
    notifyListeners();
  }

  /// Check if song is favorited
  bool isSongFavorited(String songId) {
    return _favoriteSongIds.contains(songId);
  }

  /// Check if mantra is favorited
  bool isMantraFavorited(String mantraId) {
    return _favoriteMantraIds.contains(mantraId);
  }

  /// Check if quote is favorited
  bool isQuoteFavorited(String quoteId) {
    return _favoriteQuoteIds.contains(quoteId);
  }

  /// Check if history is favorited
  bool isHistoryFavorited(String historyId) {
    return _favoriteHistoryIds.contains(historyId);
  }

  /// Get favorites filtered by category
  List<dynamic> getFavoritesByCategory(String category) {
    switch (category.toLowerCase()) {
      case 'songs':
        return _favoriteSongs;
      case 'mantras':
        return _favoriteMantras;
      case 'quotes':
        return _favoriteQuotes;
      case 'history':
        return _favoriteHistory;
      case 'all':
      default:
        List<dynamic> all = [];
        all.addAll(_favoriteSongs);
        all.addAll(_favoriteMantras);
        all.addAll(_favoriteQuotes);
        all.addAll(_favoriteHistory);
        return all;
    }
  }

  /// Search within favorites
  List<dynamic> searchFavorites(String query) {
    if (query.isEmpty) return getFavoritesByCategory('all');
    
    final lowercaseQuery = query.toLowerCase();
    List<dynamic> results = [];
    
    // Search songs
    results.addAll(_favoriteSongs.where((song) =>
        song.title.toLowerCase().contains(lowercaseQuery) ||
        song.singer.toLowerCase().contains(lowercaseQuery) ||
        song.writer.toLowerCase().contains(lowercaseQuery)));
    
    // Search mantras
    results.addAll(_favoriteMantras.where((mantra) =>
        mantra.title.toLowerCase().contains(lowercaseQuery) ||
        mantra.sanskrit.toLowerCase().contains(lowercaseQuery)));
    
    // Search quotes
    results.addAll(_favoriteQuotes.where((quote) =>
        quote.text.toLowerCase().contains(lowercaseQuery) ||
        quote.source.toLowerCase().contains(lowercaseQuery)));
    
    // Search history
    results.addAll(_favoriteHistory.where((history) =>
        history.title.toLowerCase().contains(lowercaseQuery) ||
        history.content.toLowerCase().contains(lowercaseQuery)));
    
    return results;
  }

  /// Clear all favorites
  Future<void> clearAllFavorites() async {
    try {
      _setLoading(true);
      
      // Clear in-memory data
      _favoriteSongs.clear();
      _favoriteMantras.clear();
      _favoriteQuotes.clear();
      _favoriteHistory.clear();
      _favoriteSongIds.clear();
      _favoriteMantraIds.clear();
      _favoriteQuoteIds.clear();
      _favoriteHistoryIds.clear();
      
      // Clear from storage
      final prefs = await SharedPreferences.getInstance();
      await Future.wait([
        prefs.remove('favorite_song_ids'),
        prefs.remove('favorite_mantra_ids'),
        prefs.remove('favorite_quote_ids'),
        prefs.remove('favorite_history_ids'),
      ]);
      
      notifyListeners();
    } catch (e) {
      _setError('Failed to clear favorites: ${e.toString()}');
      debugPrint('Error clearing favorites: $e');
    } finally {
      _setLoading(false);
    }
  }

  /// Export favorites as JSON string (for backup/sharing)
  String exportFavorites() {
    try {
      final data = {
        'songs': _favoriteSongIds.toList(),
        'mantras': _favoriteMantraIds.toList(),
        'quotes': _favoriteQuoteIds.toList(),
        'history': _favoriteHistoryIds.toList(),
        'exported_at': DateTime.now().toIso8601String(),
      };
      return jsonEncode(data);
    } catch (e) {
      debugPrint('Error exporting favorites: $e');
      return '{}';
    }
  }

  /// Import favorites from JSON string (for restore)
  Future<void> importFavorites(String jsonData) async {
    try {
      _setLoading(true);
      
      final data = jsonDecode(jsonData) as Map<String, dynamic>;
      
      if (data.containsKey('songs')) {
        _favoriteSongIds = (data['songs'] as List).cast<String>().toSet();
        await _saveFavoriteSongIds();
      }
      
      if (data.containsKey('mantras')) {
        _favoriteMantraIds = (data['mantras'] as List).cast<String>().toSet();
        await _saveFavoriteMantraIds();
      }
      
      if (data.containsKey('quotes')) {
        _favoriteQuoteIds = (data['quotes'] as List).cast<String>().toSet();
        await _saveFavoriteQuoteIds();
      }
      
      if (data.containsKey('history')) {
        _favoriteHistoryIds = (data['history'] as List).cast<String>().toSet();
        await _saveFavoriteHistoryIds();
      }
      
      await _syncFavoriteData();
      notifyListeners();
    } catch (e) {
      _setError('Failed to import favorites: ${e.toString()}');
      debugPrint('Error importing favorites: $e');
    } finally {
      _setLoading(false);
    }
  }

  // Private helper methods for saving to storage
  Future<void> _saveFavoriteSongIds() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setStringList('favorite_song_ids', _favoriteSongIds.toList());
  }

  Future<void> _saveFavoriteMantraIds() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setStringList('favorite_mantra_ids', _favoriteMantraIds.toList());
  }

  Future<void> _saveFavoriteQuoteIds() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setStringList('favorite_quote_ids', _favoriteQuoteIds.toList());
  }

  Future<void> _saveFavoriteHistoryIds() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setStringList('favorite_history_ids', _favoriteHistoryIds.toList());
  }

  // State management helpers
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }

  void _setError(String error) {
    _error = error;
    notifyListeners();
  }

  void _clearError() {
    _error = '';
    if (_error.isNotEmpty) notifyListeners();
  }

  /// Get statistics for user profile
  Map<String, int> getFavoriteStats() {
    return {
      'songs': _favoriteSongs.length,
      'mantras': _favoriteMantras.length,
      'quotes': _favoriteQuotes.length,
      'history': _favoriteHistory.length,
      'total': totalFavoritesCount,
    };
  }

  /// Refresh favorites (reload from storage and sync)
  Future<void> refreshFavorites() async {
    await initializeFavorites();
  }
}
//providers/language_provider.dart
// lib/providers/language_provider.dart

import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../utils/constants.dart';

/// Manages language state and preferences for the Lord Ayyappa Devotional App
/// Supports Tamil, Telugu, English Phonetic Tamil, and English Phonetic Telugu
class LanguageProvider extends ChangeNotifier {
  static const String _languageKey = 'selected_language';
  static const String _autoDetectKey = 'auto_detect_language';
  
  AppLanguage _currentLanguage = AppLanguage.englishPhoneticTamil;
  bool _autoDetectLanguage = true;
  bool _isInitialized = false;

  // Getters
  AppLanguage get currentLanguage => _currentLanguage;
  bool get autoDetectLanguage => _autoDetectLanguage;
  bool get isInitialized => _isInitialized;
  
  String get languageCode => _getLanguageCode(_currentLanguage);
  String get languageName => _getLanguageName(_currentLanguage);
  String get nativeLanguageName => _getNativeLanguageName(_currentLanguage);
  
  bool get isTamil => _currentLanguage == AppLanguage.tamil;
  bool get isTelugu => _currentLanguage == AppLanguage.telugu;
  bool get isEnglishPhoneticTamil => _currentLanguage == AppLanguage.englishPhoneticTamil;
  bool get isEnglishPhoneticTelugu => _currentLanguage == AppLanguage.englishPhoneticTelugu;
  bool get isPhoneticLanguage => isEnglishPhoneticTamil || isEnglishPhoneticTelugu;

  /// Initialize language preferences from storage
  Future<void> initializeLanguage() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      final savedLanguage = prefs.getString(_languageKey) ?? 'english_phonetic_tamil';
      final savedAutoDetect = prefs.getBool(_autoDetectKey) ?? true;
      
      _currentLanguage = _getLanguageFromString(savedLanguage);
      _autoDetectLanguage = savedAutoDetect;
      
      // Auto-detect language based on system locale if enabled
      if (_autoDetectLanguage) {
        await _detectSystemLanguage();
      }
      
      _isInitialized = true;
      notifyListeners();
    } catch (e) {
      debugPrint('Error initializing language: $e');
      _setDefaultLanguage();
    }
  }

  /// Set current language with persistence
  Future<void> setLanguage(AppLanguage language) async {
    if (_currentLanguage == language) return;
    
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_languageKey, _getLanguageString(language));
      
      _currentLanguage = language;
      notifyListeners();
      
      debugPrint('Language changed to: ${_getLanguageName(language)}');
    } catch (e) {
      debugPrint('Error saving language: $e');
    }
  }

  /// Toggle auto-detect language feature
  Future<void> setAutoDetectLanguage(bool autoDetect) async {
    if (_autoDetectLanguage == autoDetect) return;
    
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setBool(_autoDetectKey, autoDetect);
      
      _autoDetectLanguage = autoDetect;
      
      if (autoDetect) {
        await _detectSystemLanguage();
      }
      
      notifyListeners();
    } catch (e) {
      debugPrint('Error saving auto-detect setting: $e');
    }
  }

  /// Cycle through available languages
  Future<void> cycleLanguage() async {
    AppLanguage nextLanguage;
    switch (_currentLanguage) {
      case AppLanguage.tamil:
        nextLanguage = AppLanguage.telugu;
        break;
      case AppLanguage.telugu:
        nextLanguage = AppLanguage.englishPhoneticTamil;
        break;
      case AppLanguage.englishPhoneticTamil:
        nextLanguage = AppLanguage.englishPhoneticTelugu;
        break;
      case AppLanguage.englishPhoneticTelugu:
        nextLanguage = AppLanguage.tamil;
        break;
    }
    
    await setLanguage(nextLanguage);
  }

  /// Get all available languages
  List<AppLanguage> getAvailableLanguages() {
    return AppLanguage.values;
  }

  /// Get language display information
  Map<String, String> getLanguageInfo(AppLanguage language) {
    return {
      'code': _getLanguageCode(language),
      'name': _getLanguageName(language),
      'nativeName': _getNativeLanguageName(language),
      'script': _getLanguageScript(language),
      'rtl': _isRightToLeft(language).toString(),
    };
  }

  /// Get text direction for current language
  TextDirection getTextDirection() {
    return _isRightToLeft(_currentLanguage) ? TextDirection.rtl : TextDirection.ltr;
  }

  /// Get font family for current language
  String? getFontFamily() {
    switch (_currentLanguage) {
      case AppLanguage.tamil:
        return 'Tamil';
      case AppLanguage.telugu:
        return 'Telugu';
      case AppLanguage.englishPhoneticTamil:
      case AppLanguage.englishPhoneticTelugu:
        return null; // Use system default
    }
  }

  /// Get appropriate text style for current language
  TextStyle getLanguageTextStyle(TextStyle baseStyle) {
    final fontFamily = getFontFamily();
    if (fontFamily != null) {
      return baseStyle.copyWith(fontFamily: fontFamily);
    }
    return baseStyle;
  }

  /// Check if text input method should be enabled for current language
  bool shouldShowNativeKeyboard() {
    return isTamil || isTelugu;
  }

  /// Get localized strings (basic implementation)
  String getLocalizedString(String key) {
    final strings = _getLocalizedStrings();
    return strings[key] ?? key;
  }

  /// Private helper methods
  Future<void> _detectSystemLanguage() async {
    try {
      final systemLocale = WidgetsBinding.instance.platformDispatcher.locale;
      AppLanguage detectedLanguage;
      
      switch (systemLocale.languageCode) {
        case 'ta':
          detectedLanguage = AppLanguage.tamil;
          break;
        case 'te':
          detectedLanguage = AppLanguage.telugu;
          break;
        default:
          // Default to English Phonetic Tamil for better accessibility
          detectedLanguage = AppLanguage.englishPhoneticTamil;
      }
      
      if (detectedLanguage != _currentLanguage) {
        _currentLanguage = detectedLanguage;
        
        // Save the auto-detected language
        final prefs = await SharedPreferences.getInstance();
        await prefs.setString(_languageKey, _getLanguageString(detectedLanguage));
      }
    } catch (e) {
      debugPrint('Error detecting system language: $e');
    }
  }

  void _setDefaultLanguage() {
    _currentLanguage = AppLanguage.englishPhoneticTamil;
    _autoDetectLanguage = true;
    _isInitialized = true;
    notifyListeners();
  }

  AppLanguage _getLanguageFromString(String language) {
    switch (language.toLowerCase()) {
      case 'tamil':
        return AppLanguage.tamil;
      case 'telugu':
        return AppLanguage.telugu;
      case 'english_phonetic_tamil':
        return AppLanguage.englishPhoneticTamil;
      case 'english_phonetic_telugu':
        return AppLanguage.englishPhoneticTelugu;
      default:
        return AppLanguage.englishPhoneticTamil;
    }
  }

  String _getLanguageString(AppLanguage language) {
    switch (language) {
      case AppLanguage.tamil:
        return 'tamil';
      case AppLanguage.telugu:
        return 'telugu';
      case AppLanguage.englishPhoneticTamil:
        return 'english_phonetic_tamil';
      case AppLanguage.englishPhoneticTelugu:
        return 'english_phonetic_telugu';
    }
  }

  String _getLanguageCode(AppLanguage language) {
    switch (language) {
      case AppLanguage.tamil:
        return 'ta';
      case AppLanguage.telugu:
        return 'te';
      case AppLanguage.englishPhoneticTamil:
        return 'en-ta';
      case AppLanguage.englishPhoneticTelugu:
        return 'en-te';
    }
  }

  String _getLanguageName(AppLanguage language) {
    switch (language) {
      case AppLanguage.tamil:
        return 'Tamil';
      case AppLanguage.telugu:
        return 'Telugu';
      case AppLanguage.englishPhoneticTamil:
        return 'English (Tamil)';
      case AppLanguage.englishPhoneticTelugu:
        return 'English (Telugu)';
    }
  }

  String _getNativeLanguageName(AppLanguage language) {
    switch (language) {
      case AppLanguage.tamil:
        return 'à®¤à®®à®¿à®´à¯';
      case AppLanguage.telugu:
        return 'à°¤à±†à°²à±à°—à±';
      case AppLanguage.englishPhoneticTamil:
        return 'English (Tamil Phonetic)';
      case AppLanguage.englishPhoneticTelugu:
        return 'English (Telugu Phonetic)';
    }
  }

  String _getLanguageScript(AppLanguage language) {
    switch (language) {
      case AppLanguage.tamil:
        return 'Tamil';
      case AppLanguage.telugu:
        return 'Telugu';
      case AppLanguage.englishPhoneticTamil:
      case AppLanguage.englishPhoneticTelugu:
        return 'Latin';
    }
  }

  bool _isRightToLeft(AppLanguage language) {
    // Tamil and Telugu are left-to-right scripts
    return false;
  }

  Map<String, String> _getLocalizedStrings() {
    switch (_currentLanguage) {
      case AppLanguage.tamil:
        return {
          'home': 'à®®à¯à®•à®ªà¯à®ªà¯',
          'songs': 'à®ªà®¾à®Ÿà®²à¯à®•à®³à¯',
          'library': 'à®¨à¯‚à®²à®•à®®à¯',
          'favorites': 'à®µà®¿à®°à¯à®ªà¯à®ªà®™à¯à®•à®³à¯',
          'profile': 'à®šà¯à®¯à®µà®¿à®µà®°à®®à¯',
          'search': 'à®¤à¯‡à®Ÿà¯',
          'settings': 'à®…à®®à¯ˆà®ªà¯à®ªà¯à®•à®³à¯',
          'language': 'à®®à¯Šà®´à®¿',
          'theme': 'à®¤à¯€à®®à¯',
          'lord_ayyappa': 'à®à®¯à®ªà¯à®ª à®ªà¯†à®°à¯à®®à®¾à®©à¯',
          'daily_mantra': 'à®¤à®¿à®©à®šà®°à®¿ à®®à®¨à¯à®¤à®¿à®°à®®à¯',
          'quote_of_day': 'à®‡à®©à¯à®±à¯ˆà®¯ à®®à¯‡à®±à¯à®•à¯‹à®³à¯',
          'good_morning': 'à®•à®¾à®²à¯ˆ à®µà®£à®•à¯à®•à®®à¯',
          'good_afternoon': 'à®®à®¤à®¿à®¯ à®µà®£à®•à¯à®•à®®à¯',
          'good_evening': 'à®®à®¾à®²à¯ˆ à®µà®£à®•à¯à®•à®®à¯',
          'good_night': 'à®‡à®°à®µà¯ à®µà®£à®•à¯à®•à®®à¯',
        };
      
      case AppLanguage.telugu:
        return {
          'home': 'à°¹à±‹à°®à±',
          'songs': 'à°ªà°¾à°Ÿà°²à±',
          'library': 'à°²à±ˆà°¬à±à°°à°°à±€',
          'favorites': 'à°‡à°·à±à°Ÿà°®à±ˆà°¨à°µà°¿',
          'profile': 'à°ªà±à°°à±Šà°«à±ˆà°²à±',
          'search': 'à°µà±†à°¤à±à°•à±',
          'settings': 'à°¸à±†à°Ÿà±à°Ÿà°¿à°‚à°—à±à°²à±',
          'language': 'à°­à°¾à°·',
          'theme': 'à°¥à±€à°®à±',
          'lord_ayyappa': 'à°…à°¯à±à°¯à°ªà±à°ª à°¸à±à°µà°¾à°®à°¿',
          'daily_mantra': 'à°¦à°¿à°¨à°šà°°à±à°¯ à°®à°‚à°¤à±à°°à°‚',
          'quote_of_day': 'à°¨à±‡à°Ÿà°¿ à°®à°¾à°Ÿ',
          'good_morning': 'à°¶à±à°­à±‹à°¦à°¯à°‚',
          'good_afternoon': 'à°¶à±à°­ à°®à°§à±à°¯à°¾à°¹à±à°¨à°‚',
          'good_evening': 'à°¶à±à°­ à°¸à°¾à°¯à°‚à°¤à±à°°à°‚',
          'good_night': 'à°¶à±à°­ à°°à°¾à°¤à±à°°à°¿',
        };
      
      default:
        return {
          'home': 'Home',
          'songs': 'Songs',
          'library': 'Library',
          'favorites': 'Favorites',
          'profile': 'Profile',
          'search': 'Search',
          'settings': 'Settings',
          'language': 'Language',
          'theme': 'Theme',
          'lord_ayyappa': 'Lord Ayyappa',
          'daily_mantra': 'Daily Mantra',
          'quote_of_day': 'Quote of the Day',
          'good_morning': 'Good Morning',
          'good_afternoon': 'Good Afternoon',
          'good_evening': 'Good Evening',
          'good_night': 'Good Night',
        };
    }
  }

  /// Get language-specific greeting based on time
  String getTimeBasedGreeting() {
    final hour = DateTime.now().hour;
    String greetingKey;
    
    if (hour < 12) {
      greetingKey = 'good_morning';
    } else if (hour < 17) {
      greetingKey = 'good_afternoon';
    } else if (hour < 21) {
      greetingKey = 'good_evening';
    } else {
      greetingKey = 'good_night';
    }
    
    return getLocalizedString(greetingKey);
  }

  /// Get language flag emoji
  String getLanguageFlag() {
    switch (_currentLanguage) {
      case AppLanguage.tamil:
      case AppLanguage.englishPhoneticTamil:
        return 'ðŸ‡®ðŸ‡³'; // India flag for Tamil
      case AppLanguage.telugu:
      case AppLanguage.englishPhoneticTelugu:
        return 'ðŸ‡®ðŸ‡³'; // India flag for Telugu
    }
  }

  /// Check if current language supports native script
  bool supportsNativeScript() {
    return isTamil || isTelugu;
  }

  /// Get sample text for language preview
  String getSampleText() {
    switch (_currentLanguage) {
      case AppLanguage.tamil:
        return 'à®¸à¯à®µà®¾à®®à®¿ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®¾';
      case AppLanguage.telugu:
        return 'à°¸à±à°µà°¾à°®à°¿ à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª';
      case AppLanguage.englishPhoneticTamil:
        return 'Swami Saranam Ayyappa';
      case AppLanguage.englishPhoneticTelugu:
        return 'Swami Sharanam Ayyappa';
    }
  }
}
//providers/theme_provider.dart
// lib/providers/theme_provider.dart

import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../utils/constants.dart';

/// Manages theme state and persistence for the Lord Ayyappa Devotional App
/// Supports Light, Dark, and Sepia themes with smooth transitions
class ThemeProvider extends ChangeNotifier {
  static const String _themeKey = 'selected_theme';
  static const String _fontSizeKey = 'font_size';
  
  ThemeMode _themeMode = ThemeMode.light;
  AppTheme _currentTheme = AppTheme.light;
  double _fontSize = 16.0;
  bool _isInitialized = false;

  // Getters
  ThemeMode get themeMode => _themeMode;
  AppTheme get currentTheme => _currentTheme;
  double get fontSize => _fontSize;
  bool get isInitialized => _isInitialized;
  
  bool get isDarkMode => _currentTheme == AppTheme.dark;
  bool get isLightMode => _currentTheme == AppTheme.light;
  bool get isSepiaMode => _currentTheme == AppTheme.sepia;

  /// Initialize theme from shared preferences
  Future<void> initializeTheme() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      final savedTheme = prefs.getString(_themeKey) ?? 'light';
      final savedFontSize = prefs.getDouble(_fontSizeKey) ?? 16.0;
      
      _currentTheme = _getThemeFromString(savedTheme);
      _themeMode = _getThemeModeFromTheme(_currentTheme);
      _fontSize = savedFontSize.clamp(AppConstants.minFontSize, AppConstants.maxFontSize);
      
      _isInitialized = true;
      notifyListeners();
    } catch (e) {
      debugPrint('Error initializing theme: $e');
      _setDefaultTheme();
    }
  }

  /// Set theme with persistence
  Future<void> setTheme(AppTheme theme) async {
    if (_currentTheme == theme) return;
    
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_themeKey, theme.name);
      
      _currentTheme = theme;
      _themeMode = _getThemeModeFromTheme(theme);
      
      notifyListeners();
    } catch (e) {
      debugPrint('Error saving theme: $e');
    }
  }

  /// Toggle between themes in sequence: Light -> Dark -> Sepia -> Light
  Future<void> toggleTheme() async {
    AppTheme nextTheme;
    switch (_currentTheme) {
      case AppTheme.light:
        nextTheme = AppTheme.dark;
        break;
      case AppTheme.dark:
        nextTheme = AppTheme.sepia;
        break;
      case AppTheme.sepia:
        nextTheme = AppTheme.light;
        break;
    }
    
    await setTheme(nextTheme);
  }

  /// Set font size for reading content
  Future<void> setFontSize(double size) async {
    final clampedSize = size.clamp(AppConstants.minFontSize, AppConstants.maxFontSize);
    
    if (_fontSize == clampedSize) return;
    
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setDouble(_fontSizeKey, clampedSize);
      
      _fontSize = clampedSize;
      notifyListeners();
    } catch (e) {
      debugPrint('Error saving font size: $e');
    }
  }

  /// Increase font size by step
  Future<void> increaseFontSize() async {
    await setFontSize(_fontSize + 2.0);
  }

  /// Decrease font size by step
  Future<void> decreaseFontSize() async {
    await setFontSize(_fontSize - 2.0);
  }

  /// Reset font size to default
  Future<void> resetFontSize() async {
    await setFontSize(16.0);
  }

  /// Get theme data based on current theme
  ThemeData getThemeData() {
    switch (_currentTheme) {
      case AppTheme.light:
        return _buildLightTheme();
      case AppTheme.dark:
        return _buildDarkTheme();
      case AppTheme.sepia:
        return _buildSepiaTheme();
    }
  }

  /// Build light theme
  ThemeData _buildLightTheme() {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      colorScheme: ColorScheme.fromSeed(
        seedColor: AppColors.primary,
        brightness: Brightness.light,
      ),
      primaryColor: AppColors.primary,
      scaffoldBackgroundColor: AppColors.background,
      cardColor: AppColors.surface,
      
      // App Bar Theme
      appBarTheme: AppBarTheme(
        backgroundColor: AppColors.primary,
        foregroundColor: Colors.white,
        elevation: 0,
        centerTitle: true,
        titleTextStyle: TextStyle(
          fontSize: 20,
          fontWeight: FontWeight.w600,
          color: Colors.white,
        ),
      ),
      
      // Bottom Navigation Theme
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: AppColors.surface,
        selectedItemColor: AppColors.primary,
        unselectedItemColor: AppColors.textSecondary,
        type: BottomNavigationBarType.fixed,
        elevation: 8,
      ),
      
      // Card Theme
      cardTheme: CardTheme(
        color: AppColors.surface,
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppConstants.borderRadius),
        ),
      ),
      
      // Text Theme
      textTheme: _buildTextTheme(AppColors.textPrimary),
      
      // Icon Theme
      iconTheme: IconThemeData(color: AppColors.primary),
      
      // Floating Action Button Theme
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: AppColors.accent,
        foregroundColor: Colors.white,
      ),
    );
  }

  /// Build dark theme
  ThemeData _buildDarkTheme() {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      colorScheme: ColorScheme.fromSeed(
        seedColor: AppColors.primary,
        brightness: Brightness.dark,
      ),
      primaryColor: AppColors.primary,
      scaffoldBackgroundColor: AppColors.darkBackground,
      cardColor: AppColors.darkSurface,
      
      // App Bar Theme
      appBarTheme: AppBarTheme(
        backgroundColor: AppColors.darkSurface,
        foregroundColor: AppColors.darkTextPrimary,
        elevation: 0,
        centerTitle: true,
        titleTextStyle: TextStyle(
          fontSize: 20,
          fontWeight: FontWeight.w600,
          color: AppColors.darkTextPrimary,
        ),
      ),
      
      // Bottom Navigation Theme
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: AppColors.darkSurface,
        selectedItemColor: AppColors.primary,
        unselectedItemColor: AppColors.darkTextSecondary,
        type: BottomNavigationBarType.fixed,
        elevation: 8,
      ),
      
      // Card Theme
      cardTheme: CardTheme(
        color: AppColors.darkSurface,
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppConstants.borderRadius),
        ),
      ),
      
      // Text Theme
      textTheme: _buildTextTheme(AppColors.darkTextPrimary),
      
      // Icon Theme
      iconTheme: IconThemeData(color: AppColors.primary),
      
      // Floating Action Button Theme
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: AppColors.accent,
        foregroundColor: Colors.white,
      ),
    );
  }

  /// Build sepia theme for comfortable reading
  ThemeData _buildSepiaTheme() {
    const sepiaBackground = Color(0xFFF4F1E8);
    const sepiaSurface = Color(0xFFF9F7F1);
    const sepiaText = Color(0xFF5D4E37);
    const sepiaSecondary = Color(0xFF8B7355);
    
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      colorScheme: ColorScheme.fromSeed(
        seedColor: AppColors.primary,
        brightness: Brightness.light,
      ),
      primaryColor: AppColors.primary,
      scaffoldBackgroundColor: sepiaBackground,
      cardColor: sepiaSurface,
      
      // App Bar Theme
      appBarTheme: AppBarTheme(
        backgroundColor: sepiaSurface,
        foregroundColor: sepiaText,
        elevation: 0,
        centerTitle: true,
        titleTextStyle: TextStyle(
          fontSize: 20,
          fontWeight: FontWeight.w600,
          color: sepiaText,
        ),
      ),
      
      // Bottom Navigation Theme
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: sepiaSurface,
        selectedItemColor: AppColors.primary,
        unselectedItemColor: sepiaSecondary,
        type: BottomNavigationBarType.fixed,
        elevation: 8,
      ),
      
      // Card Theme
      cardTheme: CardTheme(
        color: sepiaSurface,
        elevation: 1,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppConstants.borderRadius),
        ),
      ),
      
      // Text Theme
      textTheme: _buildTextTheme(sepiaText),
      
      // Icon Theme
      iconTheme: IconThemeData(color: AppColors.primary),
      
      // Floating Action Button Theme
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: AppColors.accent,
        foregroundColor: Colors.white,
      ),
    );
  }

  /// Build consistent text theme
  TextTheme _buildTextTheme(Color textColor) {
    return TextTheme(
      displayLarge: TextStyle(color: textColor, fontSize: 32, fontWeight: FontWeight.bold),
      displayMedium: TextStyle(color: textColor, fontSize: 28, fontWeight: FontWeight.bold),
      displaySmall: TextStyle(color: textColor, fontSize: 24, fontWeight: FontWeight.w600),
      headlineLarge: TextStyle(color: textColor, fontSize: 22, fontWeight: FontWeight.w600),
      headlineMedium: TextStyle(color: textColor, fontSize: 20, fontWeight: FontWeight.w600),
      headlineSmall: TextStyle(color: textColor, fontSize: 18, fontWeight: FontWeight.w600),
      titleLarge: TextStyle(color: textColor, fontSize: 16, fontWeight: FontWeight.w600),
      titleMedium: TextStyle(color: textColor, fontSize: 14, fontWeight: FontWeight.w500),
      titleSmall: TextStyle(color: textColor, fontSize: 12, fontWeight: FontWeight.w500),
      bodyLarge: TextStyle(color: textColor, fontSize: _fontSize, height: 1.5),
      bodyMedium: TextStyle(color: textColor, fontSize: _fontSize - 2, height: 1.4),
      bodySmall: TextStyle(color: textColor, fontSize: _fontSize - 4, height: 1.3),
      labelLarge: TextStyle(color: textColor, fontSize: 14, fontWeight: FontWeight.w500),
      labelMedium: TextStyle(color: textColor, fontSize: 12, fontWeight: FontWeight.w500),
      labelSmall: TextStyle(color: textColor, fontSize: 10, fontWeight: FontWeight.w500),
    );
  }

  /// Helper methods
  AppTheme _getThemeFromString(String theme) {
    switch (theme.toLowerCase()) {
      case 'dark':
        return AppTheme.dark;
      case 'sepia':
        return AppTheme.sepia;
      default:
        return AppTheme.light;
    }
  }

  ThemeMode _getThemeModeFromTheme(AppTheme theme) {
    switch (theme) {
      case AppTheme.dark:
        return ThemeMode.dark;
      case AppTheme.light:
      case AppTheme.sepia:
        return ThemeMode.light;
    }
  }

  void _setDefaultTheme() {
    _currentTheme = AppTheme.light;
    _themeMode = ThemeMode.light;
    _fontSize = 16.0;
    _isInitialized = true;
    notifyListeners();
  }

  /// Get theme display name
  String getThemeDisplayName() {
    switch (_currentTheme) {
      case AppTheme.light:
        return 'Light';
      case AppTheme.dark:
        return 'Dark';
      case AppTheme.sepia:
        return 'Sepia';
    }
  }

  /// Get theme icon
  IconData getThemeIcon() {
    switch (_currentTheme) {
      case AppTheme.light:
        return Icons.light_mode;
      case AppTheme.dark:
        return Icons.dark_mode;
      case AppTheme.sepia:
        return Icons.auto_stories;
    }
  }
}

/// Theme types enum
enum AppTheme { light, dark, sepia }
//providers/user_provider.dart
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/user_model.dart';
import '../models/song_model.dart';
import '../utils/constants.dart';

/// Provider for managing user profile, preferences, and devotional journey
class UserProvider with ChangeNotifier {
  UserModel _user = UserModel(
    id: 'default_user',
    name: 'Devotee',
    email: '',
    joinDate: DateTime.now(),
  );

  bool _isLoading = false;
  String? _error;

  // Getters
  UserModel get user => _user;
  bool get isLoading => _isLoading;
  String? get error => _error;
  
  // Devotional journey getters
  int get devotionalStreak => _user.devotionalStreak;
  int get totalSongsLearned => _user.songsLearned.length;
  int get totalListeningTime => _user.totalListeningMinutes;
  List<String> get achievements => _user.achievements;
  Map<String, int> get dailyProgress => _user.dailyProgress;

  /// Initialize user data from storage
  Future<void> initializeUser() async {
    try {
      _setLoading(true);
      _clearError();
      
      final prefs = await SharedPreferences.getInstance();
      
      // Load user basic info
      final userName = prefs.getString('user_name') ?? 'Devotee';
      final userEmail = prefs.getString('user_email') ?? '';
      final joinDateString = prefs.getString('join_date');
      
      DateTime joinDate = DateTime.now();
      if (joinDateString != null) {
        joinDate = DateTime.parse(joinDateString);
      }

      // Load devotional progress
      final streak = prefs.getInt('devotional_streak') ?? 0;
      final totalMinutes = prefs.getInt('total_listening_minutes') ?? 0;
      final songsLearned = prefs.getStringList('songs_learned') ?? [];
      final achievementsList = prefs.getStringList('achievements') ?? [];
      
      // Load daily progress (last 30 days)
      final dailyProgressMap = <String, int>{};
      for (int i = 0; i < 30; i++) {
        final date = DateTime.now().subtract(Duration(days: i));
        final dateKey = '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
        dailyProgressMap[dateKey] = prefs.getInt('progress_$dateKey') ?? 0;
      }

      // Load learning progress
      final learningProgress = <String, double>{};
      for (final songId in songsLearned) {
        learningProgress[songId] = prefs.getDouble('learning_$songId') ?? 0.0;
      }

      // Load user preferences
      final preferences = UserPreferences(
        fontSize: prefs.getDouble('font_size') ?? AppConstants.defaultFontSize,
        autoPlay: prefs.getBool('auto_play') ?? true,
        dailyReminder: prefs.getBool('daily_reminder') ?? true,
        reminderTime: TimeOfDay(
          hour: prefs.getInt('reminder_hour') ?? 6,
          minute: prefs.getInt('reminder_minute') ?? 0,
        ),
        offlineMode: prefs.getBool('offline_mode') ?? false,
        karaokeMode: prefs.getBool('karaoke_mode') ?? false,
      );

      _user = UserModel(
        id: prefs.getString('user_id') ?? 'default_user',
        name: userName,
        email: userEmail,
        joinDate: joinDate,
        devotionalStreak: streak,
        totalListeningMinutes: totalMinutes,
        songsLearned: songsLearned,
        achievements: achievementsList,
        dailyProgress: dailyProgressMap,
        learningProgress: learningProgress,
        preferences: preferences,
      );

      _checkAndUpdateStreak();
      await _updateAchievements();
      
    } catch (e) {
      _setError('Failed to load user data: $e');
      debugPrint('Error initializing user: $e');
    } finally {
      _setLoading(false);
    }
  }

  /// Update user profile information
  Future<void> updateProfile({
    String? name,
    String? email,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      final prefs = await SharedPreferences.getInstance();
      
      if (name != null) {
        _user = _user.copyWith(name: name);
        await prefs.setString('user_name', name);
      }
      
      if (email != null) {
        _user = _user.copyWith(email: email);
        await prefs.setString('user_email', email);
      }
      
      notifyListeners();
    } catch (e) {
      _setError('Failed to update profile: $e');
    } finally {
      _setLoading(false);
    }
  }

  /// Update user preferences
  Future<void> updatePreferences(UserPreferences preferences) async {
    try {
      _setLoading(true);
      _clearError();

      final prefs = await SharedPreferences.getInstance();
      
      _user = _user.copyWith(preferences: preferences);
      
      // Save preferences to storage
      await prefs.setDouble('font_size', preferences.fontSize);
      await prefs.setBool('auto_play', preferences.autoPlay);
      await prefs.setBool('daily_reminder', preferences.dailyReminder);
      await prefs.setInt('reminder_hour', preferences.reminderTime.hour);
      await prefs.setInt('reminder_minute', preferences.reminderTime.minute);
      await prefs.setBool('offline_mode', preferences.offlineMode);
      await prefs.setBool('karaoke_mode', preferences.karaokeMode);
      
      notifyListeners();
    } catch (e) {
      _setError('Failed to update preferences: $e');
    } finally {
      _setLoading(false);
    }
  }

  /// Record song listening session
  Future<void> recordListeningSession({
    required String songId,
    required int durationMinutes,
    bool completed = false,
  }) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // Update total listening time
      final newTotal = _user.totalListeningMinutes + durationMinutes;
      _user = _user.copyWith(totalListeningMinutes: newTotal);
      await prefs.setInt('total_listening_minutes', newTotal);

      // Update daily progress
      final today = DateTime.now();
      final todayKey = '${today.year}-${today.month.toString().padLeft(2, '0')}-${today.day.toString().padLeft(2, '0')}';
      final currentProgress = _user.dailyProgress[todayKey] ?? 0;
      final updatedProgress = Map<String, int>.from(_user.dailyProgress);
      updatedProgress[todayKey] = currentProgress + durationMinutes;
      
      _user = _user.copyWith(dailyProgress: updatedProgress);
      await prefs.setInt('progress_$todayKey', updatedProgress[todayKey]!);

      // Update learning progress if completed
      if (completed) {
        await _markSongAsLearned(songId);
      }

      // Update streak for daily activity
      await _updateDailyStreak();
      await _updateAchievements();
      
      notifyListeners();
    } catch (e) {
      _setError('Failed to record listening session: $e');
    }
  }

  /// Mark a song as learned
  Future<void> _markSongAsLearned(String songId) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      if (!_user.songsLearned.contains(songId)) {
        final updatedList = List<String>.from(_user.songsLearned)..add(songId);
        _user = _user.copyWith(songsLearned: updatedList);
        await prefs.setStringList('songs_learned', updatedList);
        
        // Set learning progress to 100%
        final updatedProgress = Map<String, double>.from(_user.learningProgress);
        updatedProgress[songId] = 1.0;
        _user = _user.copyWith(learningProgress: updatedProgress);
        await prefs.setDouble('learning_$songId', 1.0);
      }
    } catch (e) {
      debugPrint('Error marking song as learned: $e');
    }
  }

  /// Update learning progress for a song
  Future<void> updateLearningProgress(String songId, double progress) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      final updatedProgress = Map<String, double>.from(_user.learningProgress);
      updatedProgress[songId] = progress.clamp(0.0, 1.0);
      
      _user = _user.copyWith(learningProgress: updatedProgress);
      await prefs.setDouble('learning_$songId', progress);
      
      // Auto-mark as learned if 100% complete
      if (progress >= 1.0) {
        await _markSongAsLearned(songId);
      }
      
      notifyListeners();
    } catch (e) {
      _setError('Failed to update learning progress: $e');
    }
  }

  /// Check and update devotional streak
  void _checkAndUpdateStreak() {
    final today = DateTime.now();
    final yesterday = today.subtract(const Duration(days: 1));
    
    final todayKey = '${today.year}-${today.month.toString().padLeft(2, '0')}-${today.day.toString().padLeft(2, '0')}';
    final yesterdayKey = '${yesterday.year}-${yesterday.month.toString().padLeft(2, '0')}-${yesterday.day.toString().padLeft(2, '0')}';
    
    final todayProgress = _user.dailyProgress[todayKey] ?? 0;
    final yesterdayProgress = _user.dailyProgress[yesterdayKey] ?? 0;
    
    // Reset streak if no activity yesterday (unless it's the first day)
    if (yesterdayProgress == 0 && _user.devotionalStreak > 0 && 
        today.difference(_user.joinDate).inDays > 1) {
      _user = _user.copyWith(devotionalStreak: todayProgress > 0 ? 1 : 0);
    }
  }

  /// Update daily streak when user is active
  Future<void> _updateDailyStreak() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final lastActiveDate = prefs.getString('last_active_date');
      final today = DateTime.now();
      final todayString = '${today.year}-${today.month.toString().padLeft(2, '0')}-${today.day.toString().padLeft(2, '0')}';
      
      if (lastActiveDate != todayString) {
        // New day activity
        final newStreak = _user.devotionalStreak + 1;
        _user = _user.copyWith(devotionalStreak: newStreak);
        
        await prefs.setInt('devotional_streak', newStreak);
        await prefs.setString('last_active_date', todayString);
      }
    } catch (e) {
      debugPrint('Error updating daily streak: $e');
    }
  }

  /// Update user achievements based on progress
  Future<void> _updateAchievements() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final achievements = List<String>.from(_user.achievements);
      bool hasNewAchievements = false;

      // First Song achievement
      if (_user.songsLearned.isNotEmpty && !achievements.contains('first_song')) {
        achievements.add('first_song');
        hasNewAchievements = true;
      }

      // Dedication achievements (streak-based)
      final streakMilestones = [7, 30, 100, 365];
      for (final milestone in streakMilestones) {
        final achievementId = '${milestone}_day_streak';
        if (_user.devotionalStreak >= milestone && !achievements.contains(achievementId)) {
          achievements.add(achievementId);
          hasNewAchievements = true;
        }
      }

      // Learning achievements (songs learned)
      final songMilestones = [5, 10, 20, 50];
      for (final milestone in songMilestones) {
        final achievementId = '${milestone}_songs_learned';
        if (_user.songsLearned.length >= milestone && !achievements.contains(achievementId)) {
          achievements.add(achievementId);
          hasNewAchievements = true;
        }
      }

      // Listening time achievements (hours)
      final timeMilestones = [60, 300, 1000, 5000]; // minutes
      for (final milestone in timeMilestones) {
        final achievementId = '${milestone ~/ 60}_hours_listening';
        if (_user.totalListeningMinutes >= milestone && !achievements.contains(achievementId)) {
          achievements.add(achievementId);
          hasNewAchievements = true;
        }
      }

      // Early Bird achievement (activity before 7 AM)
      final now = DateTime.now();
      if (now.hour < 7 && !achievements.contains('early_bird')) {
        achievements.add('early_bird');
        hasNewAchievements = true;
      }

      if (hasNewAchievements) {
        _user = _user.copyWith(achievements: achievements);
        await prefs.setStringList('achievements', achievements);
      }
    } catch (e) {
      debugPrint('Error updating achievements: $e');
    }
  }

  /// Get achievement details
  Map<String, dynamic> getAchievementDetails(String achievementId) {
    final achievementMap = {
      'first_song': {
        'title': 'First Song',
        'description': 'Learned your first devotional song',
        'icon': 'ðŸŽµ',
        'category': 'learning',
      },
      '7_day_streak': {
        'title': 'Week Warrior',
        'description': '7 days of continuous devotion',
        'icon': 'ðŸ”¥',
        'category': 'dedication',
      },
      '30_day_streak': {
        'title': 'Monthly Devotee',
        'description': '30 days of continuous devotion',
        'icon': 'â­',
        'category': 'dedication',
      },
      '100_day_streak': {
        'title': 'Centennial Devotee',
        'description': '100 days of continuous devotion',
        'icon': 'ðŸ’Ž',
        'category': 'dedication',
      },
      '365_day_streak': {
        'title': 'Yearly Devotee',
        'description': '365 days of continuous devotion',
        'icon': 'ðŸ‘‘',
        'category': 'dedication',
      },
      '5_songs_learned': {
        'title': 'Song Explorer',
        'description': 'Learned 5 devotional songs',
        'icon': 'ðŸŽ¼',
        'category': 'learning',
      },
      '10_songs_learned': {
        'title': 'Melody Master',
        'description': 'Learned 10 devotional songs',
        'icon': 'ðŸŽ¶',
        'category': 'learning',
      },
      '20_songs_learned': {
        'title': 'Hymn Hero',
        'description': 'Learned 20 devotional songs',
        'icon': 'ðŸ†',
        'category': 'learning',
      },
      '50_songs_learned': {
        'title': 'Devotional Virtuoso',
        'description': 'Learned 50 devotional songs',
        'icon': 'ðŸŒŸ',
        'category': 'learning',
      },
      '1_hours_listening': {
        'title': 'Attentive Listener',
        'description': '1 hour of devotional listening',
        'icon': 'ðŸ‘‚',
        'category': 'listening',
      },
      '5_hours_listening': {
        'title': 'Dedicated Listener',
        'description': '5 hours of devotional listening',
        'icon': 'ðŸŽ§',
        'category': 'listening',
      },
      '16_hours_listening': {
        'title': 'Devoted Listener',
        'description': '16 hours of devotional listening',
        'icon': 'ðŸ”Š',
        'category': 'listening',
      },
      '83_hours_listening': {
        'title': 'Spiritual Audio Guide',
        'description': '83+ hours of devotional listening',
        'icon': 'ðŸ“»',
        'category': 'listening',
      },
      'early_bird': {
        'title': 'Early Bird Devotee',
        'description': 'Morning devotion before 7 AM',
        'icon': 'ðŸŒ…',
        'category': 'special',
      },
    };

    return achievementMap[achievementId] ?? {
      'title': 'Unknown Achievement',
      'description': 'Achievement details not found',
      'icon': 'ðŸ…',
      'category': 'general',
    };
  }

  /// Get user statistics for profile display
  Map<String, dynamic> getUserStatistics() {
    final joinDays = DateTime.now().difference(_user.joinDate).inDays + 1;
    final averageDaily = joinDays > 0 ? _user.totalListeningMinutes / joinDays : 0;
    
    return {
      'join_days': joinDays,
      'devotional_streak': _user.devotionalStreak,
      'songs_learned': _user.songsLearned.length,
      'total_listening_hours': (_user.totalListeningMinutes / 60).toStringAsFixed(1),
      'average_daily_minutes': averageDaily.toStringAsFixed(1),
      'achievements_count': _user.achievements.length,
      'favorite_time': _getBestListeningTime(),
    };
  }

  /// Get the time of day when user is most active
  String _getBestListeningTime() {
    // This would analyze daily progress patterns
    // For now, return a simple morning preference
    if (_user.preferences.reminderTime.hour < 10) {
      return 'Morning';
    } else if (_user.preferences.reminderTime.hour < 18) {
      return 'Afternoon';
    } else {
      return 'Evening';
    }
  }

  /// Reset user data (for testing or new user)
  Future<void> resetUserData() async {
    try {
      _setLoading(true);
      final prefs = await SharedPreferences.getInstance();
      
      // Clear all user-related preferences
      final keysToRemove = [
        'user_name', 'user_email', 'join_date', 'devotional_streak',
        'total_listening_minutes', 'songs_learned', 'achievements',
        'last_active_date', 'font_size', 'auto_play', 'daily_reminder',
        'reminder_hour', 'reminder_minute', 'offline_mode', 'karaoke_mode',
      ];
      
      for (final key in keysToRemove) {
        await prefs.remove(key);
      }
      
      // Clear daily progress
      for (int i = 0; i < 30; i++) {
        final date = DateTime.now().subtract(Duration(days: i));
        final dateKey = '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
        await prefs.remove('progress_$dateKey');
      }
      
      // Reset to default user
      _user = UserModel(
        id: 'default_user',
        name: 'Devotee',
        email: '',
        joinDate: DateTime.now(),
      );
      
      notifyListeners();
    } catch (e) {
      _setError('Failed to reset user data: $e');
    } finally {
      _setLoading(false);
    }
  }

  /// Helper methods for state management
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }

  void _setError(String error) {
    _error = error;
    notifyListeners();
  }

  void _clearError() {
    _error = null;
  }
}
//services/database_service.dart
import 'dart:convert';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import '../models/song_model.dart';
import '../models/user_model.dart';
import '../models/devotional_content.dart';
import '../models/ritual_model.dart';
import '../models/festival_model.dart';

/// Service class for handling all database operations
/// Manages local storage for songs, user data, favorites, and devotional content
class DatabaseService {
  static final DatabaseService _instance = DatabaseService._internal();
  factory DatabaseService() => _instance;
  DatabaseService._internal();

  static Database? _database;

  /// Get database instance, initialize if not exists
  Future<Database> get database async {
    _database ??= await _initDatabase();
    return _database!;
  }

  /// Initialize the database with all required tables
  Future<Database> _initDatabase() async {
    try {
      final dbPath = await getDatabasesPath();
      final path = join(dbPath, 'ayyappa_devotional.db');

      return await openDatabase(
        path,
        version: 1,
        onCreate: _createTables,
        onUpgrade: _onUpgrade,
      );
    } catch (e) {
      throw Exception('Failed to initialize database: $e');
    }
  }

  /// Create all database tables
  Future<void> _createTables(Database db, int version) async {
    try {
      // Songs table
      await db.execute('''
        CREATE TABLE songs (
          id TEXT PRIMARY KEY,
          title TEXT NOT NULL,
          singer TEXT NOT NULL,
          writer TEXT NOT NULL,
          iconType TEXT NOT NULL,
          tamilLyrics TEXT NOT NULL,
          teluguLyrics TEXT NOT NULL,
          englishPhoneticTamil TEXT NOT NULL,
          englishPhoneticTelugu TEXT NOT NULL,
          isFavorite INTEGER NOT NULL DEFAULT 0,
          playCount INTEGER NOT NULL DEFAULT 0,
          lastPlayed TEXT,
          createdAt TEXT NOT NULL,
          updatedAt TEXT NOT NULL
        )
      ''');

      // User data table
      await db.execute('''
        CREATE TABLE user_data (
          id INTEGER PRIMARY KEY,
          name TEXT NOT NULL,
          email TEXT,
          profileImagePath TEXT,
          totalDaysActive INTEGER NOT NULL DEFAULT 0,
          currentStreak INTEGER NOT NULL DEFAULT 0,
          songsLearned INTEGER NOT NULL DEFAULT 0,
          mantraRecitations INTEGER NOT NULL DEFAULT 0,
          achievementBadges TEXT,
          lastActiveDate TEXT,
          createdAt TEXT NOT NULL,
          updatedAt TEXT NOT NULL
        )
      ''');

      // Favorites table
      await db.execute('''
        CREATE TABLE favorites (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          itemId TEXT NOT NULL,
          itemType TEXT NOT NULL,
          userId INTEGER NOT NULL DEFAULT 1,
          addedAt TEXT NOT NULL
        )
      ''');

      // Devotional content table (mantras, quotes, etc.)
      await db.execute('''
        CREATE TABLE devotional_content (
          id TEXT PRIMARY KEY,
          type TEXT NOT NULL,
          title TEXT NOT NULL,
          content TEXT NOT NULL,
          language TEXT NOT NULL,
          category TEXT,
          tags TEXT,
          createdAt TEXT NOT NULL
        )
      ''');

      // User progress tracking
      await db.execute('''
        CREATE TABLE user_progress (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          userId INTEGER NOT NULL DEFAULT 1,
          activityType TEXT NOT NULL,
          activityData TEXT NOT NULL,
          completedAt TEXT NOT NULL
        )
      ''');

      // Reading history
      await db.execute('''
        CREATE TABLE reading_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          itemId TEXT NOT NULL,
          itemType TEXT NOT NULL,
          readingTime INTEGER NOT NULL,
          completionPercentage REAL NOT NULL,
          readAt TEXT NOT NULL
        )
      ''');

      // Settings table
      await db.execute('''
        CREATE TABLE app_settings (
          key TEXT PRIMARY KEY,
          value TEXT NOT NULL,
          updatedAt TEXT NOT NULL
        )
      ''');

      // Create indexes for better performance
      await db.execute('CREATE INDEX idx_songs_favorite ON songs(isFavorite)');
      await db.execute('CREATE INDEX idx_favorites_type ON favorites(itemType)');
      await db.execute('CREATE INDEX idx_devotional_type ON devotional_content(type)');
      await db.execute('CREATE INDEX idx_progress_user ON user_progress(userId)');

    } catch (e) {
      throw Exception('Failed to create database tables: $e');
    }
  }

  /// Handle database upgrades
  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    // Handle future database schema changes
    if (oldVersion < newVersion) {
      // Add migration logic here when needed
    }
  }

  // SONGS OPERATIONS

  /// Insert a new song into the database
  Future<void> insertSong(Song song) async {
    try {
      final db = await database;
      final now = DateTime.now().toIso8601String();
      
      await db.insert(
        'songs',
        {
          ...song.toMap(),
          'createdAt': now,
          'updatedAt': now,
        },
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
    } catch (e) {
      throw Exception('Failed to insert song: $e');
    }
  }

  /// Get all songs from database
  Future<List<Song>> getAllSongs() async {
    try {
      final db = await database;
      final List<Map<String, dynamic>> maps = await db.query('songs');
      
      return List.generate(maps.length, (i) => Song.fromMap(maps[i]));
    } catch (e) {
      throw Exception('Failed to get songs: $e');
    }
  }

  /// Get favorite songs
  Future<List<Song>> getFavoriteSongs() async {
    try {
      final db = await database;
      final List<Map<String, dynamic>> maps = await db.query(
        'songs',
        where: 'isFavorite = ?',
        whereArgs: [1],
        orderBy: 'updatedAt DESC',
      );
      
      return List.generate(maps.length, (i) => Song.fromMap(maps[i]));
    } catch (e) {
      throw Exception('Failed to get favorite songs: $e');
    }
  }

  /// Update song favorite status
  Future<void> updateSongFavorite(String songId, bool isFavorite) async {
    try {
      final db = await database;
      await db.update(
        'songs',
        {
          'isFavorite': isFavorite ? 1 : 0,
          'updatedAt': DateTime.now().toIso8601String(),
        },
        where: 'id = ?',
        whereArgs: [songId],
      );
    } catch (e) {
      throw Exception('Failed to update song favorite: $e');
    }
  }

  /// Update song play count and last played time
  Future<void> updateSongPlayStats(String songId) async {
    try {
      final db = await database;
      final now = DateTime.now().toIso8601String();
      
      await db.rawUpdate('''
        UPDATE songs 
        SET playCount = playCount + 1, 
            lastPlayed = ?, 
            updatedAt = ?
        WHERE id = ?
      ''', [now, now, songId]);
    } catch (e) {
      throw Exception('Failed to update song play stats: $e');
    }
  }

  /// Search songs by query
  Future<List<Song>> searchSongs(String query) async {
    try {
      final db = await database;
      final lowerQuery = query.toLowerCase();
      
      final List<Map<String, dynamic>> maps = await db.query(
        'songs',
        where: '''
          LOWER(title) LIKE ? OR 
          LOWER(singer) LIKE ? OR 
          LOWER(writer) LIKE ? OR
          LOWER(tamilLyrics) LIKE ? OR
          LOWER(teluguLyrics) LIKE ? OR
          LOWER(englishPhoneticTamil) LIKE ? OR
          LOWER(englishPhoneticTelugu) LIKE ?
        ''',
        whereArgs: List.filled(7, '%$lowerQuery%'),
      );
      
      return List.generate(maps.length, (i) => Song.fromMap(maps[i]));
    } catch (e) {
      throw Exception('Failed to search songs: $e');
    }
  }

  // USER DATA OPERATIONS

  /// Insert or update user data
  Future<void> saveUserData(UserModel user) async {
    try {
      final db = await database;
      final now = DateTime.now().toIso8601String();
      
      final userData = user.toMap();
      userData['achievementBadges'] = jsonEncode(user.achievementBadges);
      userData['updatedAt'] = now;
      
      await db.insert(
        'user_data',
        {
          ...userData,
          'createdAt': now,
        },
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
    } catch (e) {
      throw Exception('Failed to save user data: $e');
    }
  }

  /// Get user data
  Future<UserModel?> getUserData() async {
    try {
      final db = await database;
      final List<Map<String, dynamic>> maps = await db.query(
        'user_data',
        limit: 1,
      );
      
      if (maps.isEmpty) return null;
      
      final userData = maps.first;
      userData['achievementBadges'] = jsonDecode(userData['achievementBadges'] ?? '[]');
      
      return UserModel.fromMap(userData);
    } catch (e) {
      throw Exception('Failed to get user data: $e');
    }
  }

  /// Update user statistics
  Future<void> updateUserStats({
    int? totalDaysActive,
    int? currentStreak,
    int? songsLearned,
    int? mantraRecitations,
  }) async {
    try {
      final db = await database;
      final updates = <String, dynamic>{
        'updatedAt': DateTime.now().toIso8601String(),
      };
      
      if (totalDaysActive != null) updates['totalDaysActive'] = totalDaysActive;
      if (currentStreak != null) updates['currentStreak'] = currentStreak;
      if (songsLearned != null) updates['songsLearned'] = songsLearned;
      if (mantraRecitations != null) updates['mantraRecitations'] = mantraRecitations;
      
      await db.update('user_data', updates, where: 'id = ?', whereArgs: [1]);
    } catch (e) {
      throw Exception('Failed to update user stats: $e');
    }
  }

  // DEVOTIONAL CONTENT OPERATIONS

  /// Insert devotional content (mantras, quotes, etc.)
  Future<void> insertDevotionalContent(DevotionalContent content) async {
    try {
      final db = await database;
      await db.insert(
        'devotional_content',
        {
          ...content.toMap(),
          'tags': jsonEncode(content.tags),
          'createdAt': DateTime.now().toIso8601String(),
        },
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
    } catch (e) {
      throw Exception('Failed to insert devotional content: $e');
    }
  }

  /// Get devotional content by type
  Future<List<DevotionalContent>> getDevotionalContentByType(String type) async {
    try {
      final db = await database;
      final List<Map<String, dynamic>> maps = await db.query(
        'devotional_content',
        where: 'type = ?',
        whereArgs: [type],
        orderBy: 'createdAt DESC',
      );
      
      return maps.map((map) {
        map['tags'] = List<String>.from(jsonDecode(map['tags'] ?? '[]'));
        return DevotionalContent.fromMap(map);
      }).toList();
    } catch (e) {
      throw Exception('Failed to get devotional content: $e');
    }
  }

  // FAVORITES OPERATIONS

  /// Add item to favorites
  Future<void> addToFavorites(String itemId, String itemType) async {
    try {
      final db = await database;
      await db.insert(
        'favorites',
        {
          'itemId': itemId,
          'itemType': itemType,
          'addedAt': DateTime.now().toIso8601String(),
        },
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
    } catch (e) {
      throw Exception('Failed to add to favorites: $e');
    }
  }

  /// Remove item from favorites
  Future<void> removeFromFavorites(String itemId, String itemType) async {
    try {
      final db = await database;
      await db.delete(
        'favorites',
        where: 'itemId = ? AND itemType = ?',
        whereArgs: [itemId, itemType],
      );
    } catch (e) {
      throw Exception('Failed to remove from favorites: $e');
    }
  }

  /// Check if item is favorite
  Future<bool> isFavorite(String itemId, String itemType) async {
    try {
      final db = await database;
      final result = await db.query(
        'favorites',
        where: 'itemId = ? AND itemType = ?',
        whereArgs: [itemId, itemType],
        limit: 1,
      );
      
      return result.isNotEmpty;
    } catch (e) {
      throw Exception('Failed to check favorite status: $e');
    }
  }

  // READING HISTORY OPERATIONS

  /// Add reading history entry
  Future<void> addReadingHistory({
    required String itemId,
    required String itemType,
    required int readingTime,
    required double completionPercentage,
  }) async {
    try {
      final db = await database;
      await db.insert(
        'reading_history',
        {
          'itemId': itemId,
          'itemType': itemType,
          'readingTime': readingTime,
          'completionPercentage': completionPercentage,
          'readAt': DateTime.now().toIso8601String(),
        },
      );
    } catch (e) {
      throw Exception('Failed to add reading history: $e');
    }
  }

  /// Get reading history
  Future<List<Map<String, dynamic>>> getReadingHistory({int limit = 50}) async {
    try {
      final db = await database;
      return await db.query(
        'reading_history',
        orderBy: 'readAt DESC',
        limit: limit,
      );
    } catch (e) {
      throw Exception('Failed to get reading history: $e');
    }
  }

  // SETTINGS OPERATIONS

  /// Save app setting
  Future<void> saveSetting(String key, String value) async {
    try {
      final db = await database;
      await db.insert(
        'app_settings',
        {
          'key': key,
          'value': value,
          'updatedAt': DateTime.now().toIso8601String(),
        },
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
    } catch (e) {
      throw Exception('Failed to save setting: $e');
    }
  }

  /// Get app setting
  Future<String?> getSetting(String key) async {
    try {
      final db = await database;
      final result = await db.query(
        'app_settings',
        where: 'key = ?',
        whereArgs: [key],
        limit: 1,
      );
      
      return result.isNotEmpty ? result.first['value'] as String : null;
    } catch (e) {
      throw Exception('Failed to get setting: $e');
    }
  }

  // UTILITY OPERATIONS

  /// Clear all data (for testing or reset)
  Future<void> clearAllData() async {
    try {
      final db = await database;
      await db.transaction((txn) async {
        await txn.delete('songs');
        await txn.delete('user_data');
        await txn.delete('favorites');
        await txn.delete('devotional_content');
        await txn.delete('user_progress');
        await txn.delete('reading_history');
        await txn.delete('app_settings');
      });
    } catch (e) {
      throw Exception('Failed to clear all data: $e');
    }
  }

  /// Get database statistics
  Future<Map<String, int>> getDatabaseStats() async {
    try {
      final db = await database;
      final stats = <String, int>{};
      
      final tables = ['songs', 'user_data', 'favorites', 'devotional_content', 
                     'user_progress', 'reading_history', 'app_settings'];
      
      for (final table in tables) {
        final result = await db.rawQuery('SELECT COUNT(*) as count FROM $table');
        stats[table] = result.first['count'] as int;
      }
      
      return stats;
    } catch (e) {
      throw Exception('Failed to get database stats: $e');
    }
  }

  /// Close database connection
  Future<void> close() async {
    final db = _database;
    if (db != null) {
      await db.close();
      _database = null;
    }
  }
}
//services/notification_service.dart
import 'package:flutter/foundation.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:permission_handler/permission_handler.dart';
import 'preferences_service.dart';

/// Service for managing local notifications and devotional reminders
class NotificationService {
  static final FlutterLocalNotificationsPlugin _notificationsPlugin =
      FlutterLocalNotificationsPlugin();
  
  static bool _initialized = false;
  
  /// Initialize notification service
  static Future<void> init() async {
    if (_initialized) return;
    
    try {
      // Android initialization settings
      const AndroidInitializationSettings initializationSettingsAndroid =
          AndroidInitializationSettings('@mipmap/ic_launcher');
      
      // iOS initialization settings
      const DarwinInitializationSettings initializationSettingsIOS =
          DarwinInitializationSettings(
        requestAlertPermission: true,
        requestBadgePermission: true,
        requestSoundPermission: true,
      );
      
      const InitializationSettings initializationSettings =
          InitializationSettings(
        android: initializationSettingsAndroid,
        iOS: initializationSettingsIOS,
      );
      
      await _notificationsPlugin.initialize(
        initializationSettings,
        onDidReceiveNotificationResponse: _onNotificationTapped,
      );
      
      _initialized = true;
      
      // Request permissions
      await _requestPermissions();
      
      // Schedule daily reminders if enabled
      if (PreferencesService.getNotificationsEnabled()) {
        await _scheduleDailyReminders();
      }
    } catch (e) {
      print('Error initializing notifications: $e');
    }
  }
  
  /// Handle notification tap
  static void _onNotificationTapped(NotificationResponse response) {
    try {
      final String? payload = response.payload;
      if (payload != null) {
        // Handle different notification types based on payload
        switch (payload) {
          case 'daily_mantra':
            // Navigate to home page
            break;
          case 'evening_prayer':
            // Navigate to prayers section
            break;
          case 'festival_reminder':
            // Navigate to festival calendar
            break;
          default:
            // Default navigation
            break;
        }
      }
    } catch (e) {
      print('Error handling notification tap: $e');
    }
  }
  
  /// Request notification permissions
  static Future<bool> _requestPermissions() async {
    try {
      if (defaultTargetPlatform == TargetPlatform.android) {
        final AndroidFlutterLocalNotificationsPlugin? androidImplementation =
            _notificationsPlugin.resolvePlatformSpecificImplementation<
                AndroidFlutterLocalNotificationsPlugin>();
        
        final bool? granted = await androidImplementation?.requestNotificationsPermission();
        return granted ?? false;
      } else if (defaultTargetPlatform == TargetPlatform.iOS) {
        final bool? granted = await _notificationsPlugin
            .resolvePlatformSpecificImplementation<
                IOSFlutterLocalNotificationsPlugin>()
            ?.requestPermissions(
              alert: true,
              badge: true,
              sound: true,
            );
        return granted ?? false;
      }
      return true;
    } catch (e) {
      print('Error requesting permissions: $e');
      return false;
    }
  }
  
  /// Show immediate notification
  static Future<void> showNotification({
    required int id,
    required String title,
    required String body,
    String? payload,
    String? channelId,
    String? channelName,
    String? channelDescription,
  }) async {
    try {
      const AndroidNotificationDetails androidDetails =
          AndroidNotificationDetails(
        'ayyappa_devotional',
        'Ayyappa Devotional',
        channelDescription: 'Daily devotional reminders and updates',
        importance: Importance.high,
        priority: Priority.high,
        icon: '@mipmap/ic_launcher',
        color: Color(0xFFFF6B35), // Saffron color
        playSound: true,
        enableVibration: true,
        styleInformation: BigTextStyleInformation(''),
      );
      
      const DarwinNotificationDetails iosDetails = DarwinNotificationDetails(
        presentAlert: true,
        presentBadge: true,
        presentSound: true,
        sound: 'default',
      );
      
      const NotificationDetails notificationDetails = NotificationDetails(
        android: androidDetails,
        iOS: iosDetails,
      );
      
      await _notificationsPlugin.show(
        id,
        title,
        body,
        notificationDetails,
        payload: payload,
      );
    } catch (e) {
      print('Error showing notification: $e');
    }
  }
  
  /// Schedule daily devotional reminders
  static Future<void> _scheduleDailyReminders() async {
    try {
      await _cancelAllNotifications();
      
      String reminderTime = PreferencesService.getDailyReminderTime();
      List<String> timeParts = reminderTime.split(':');
      int hour = int.parse(timeParts[0]);
      int minute = int.parse(timeParts[1]);
      
      // Morning devotional reminder
      await _scheduleDailyNotification(
        id: 1,
        title: 'Swamiye Saranam Ayyappa! ðŸ•‰ï¸',
        body: 'Start your day with Lord Ayyappa\'s blessings. Read today\'s mantra.',
        hour: hour,
        minute: minute,
        payload: 'daily_mantra',
      );
      
      // Evening prayer reminder
      await _scheduleDailyNotification(
        id: 2,
        title: 'Evening Prayers ðŸ™',
        body: 'Join in evening devotional prayers to Lord Ayyappa.',
        hour: 18,
        minute: 0,
        payload: 'evening_prayer',
      );
      
      // Weekly motivation
      await _scheduleWeeklyNotification(
        id: 3,
        title: 'Devotional Journey ðŸŒŸ',
        body: 'Continue your spiritual journey with Lord Ayyappa.',
        weekday: 1, // Monday
        hour: 9,
        minute: 0,
        payload: 'weekly_reminder',
      );
    } catch (e) {
      print('Error scheduling daily reminders: $e');
    }
  }
  
  /// Schedule a daily recurring notification
  static Future<void> _scheduleDailyNotification({
    required int id,
    required String title,
    required String body,
    required int hour,
    required int minute,
    String? payload,
  }) async {
    try {
      await _notificationsPlugin.zonedSchedule(
        id,
        title,
        body,
        _nextInstanceOfTime(hour, minute),
        const NotificationDetails(
          android: AndroidNotificationDetails(
            'daily_reminders',
            'Daily Reminders',
            channelDescription: 'Daily devotional reminders',
            importance: Importance.high,
            priority: Priority.high,
            icon: '@mipmap/ic_launcher',
            color: Color(0xFFFF6B35),
            playSound: true,
            sound: RawResourceAndroidNotificationSound('ayyappa_bell'),
          ),
          iOS: DarwinNotificationDetails(
            presentAlert: true,
            presentBadge: true,
            presentSound: true,
            sound: 'ayyappa_bell.mp3',
          ),
        ),
        androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
        uiLocalNotificationDateInterpretation:
            UILocalNotificationDateInterpretation.absoluteTime,
        matchDateTimeComponents: DateTimeComponents.time,
        payload: payload,
      );
    } catch (e) {
      print('Error scheduling daily notification: $e');
    }
  }
  
  /// Schedule a weekly recurring notification
  static Future<void> _scheduleWeeklyNotification({
    required int id,
    required String title,
    required String body,
    required int weekday,
    required int hour,
    required int minute,
    String? payload,
  }) async {
    try {
      await _notificationsPlugin.zonedSchedule(
        id,
        title,
        body,
        _nextInstanceOfWeekday(weekday, hour, minute),
        const NotificationDetails(
          android: AndroidNotificationDetails(
            'weekly_reminders',
            'Weekly Reminders',
            channelDescription: 'Weekly devotional reminders',
            importance: Importance.high,
            priority: Priority.high,
            icon: '@mipmap/ic_launcher',
            color: Color(0xFFFF6B35),
          ),
          iOS: DarwinNotificationDetails(
            presentAlert: true,
            presentBadge: true,
            presentSound: true,
          ),
        ),
        androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
        uiLocalNotificationDateInterpretation:
            UILocalNotificationDateInterpretation.absoluteTime,
        matchDateTimeComponents: DateTimeComponents.dayOfWeekAndTime,
        payload: payload,
      );
    } catch (e) {
      print('Error scheduling weekly notification: $e');
    }
  }
  
  /// Get next instance of specified time
  static tz.TZDateTime _nextInstanceOfTime(int hour, int minute) {
    final tz.TZDateTime now = tz.TZDateTime.now(tz.local);
    tz.TZDateTime scheduledDate = tz.TZDateTime(
      tz.local,
      now.year,
      now.month,
      now.day,
      hour,
      minute,
    );
    
    if (scheduledDate.isBefore(now)) {
      scheduledDate = scheduledDate.add(const Duration(days: 1));
    }
    
    return scheduledDate;
  }
  
  /// Get next instance of specified weekday and time
  static tz.TZDateTime _nextInstanceOfWeekday(int weekday, int hour, int minute) {
    tz.TZDateTime scheduledDate = _nextInstanceOfTime(hour, minute);
    
    while (scheduledDate.weekday != weekday) {
      scheduledDate = scheduledDate.add(const Duration(days: 1));
    }
    
    return scheduledDate;
  }
  
  /// Schedule festival reminders
  static Future<void> scheduleFestivalReminder({
    required String festivalName,
    required DateTime festivalDate,
    String? description,
  }) async {
    try {
      // Reminder 3 days before
      final threeDaysBefore = festivalDate.subtract(const Duration(days: 3));
      if (threeDaysBefore.isAfter(DateTime.now())) {
        await _notificationsPlugin.zonedSchedule(
          festivalName.hashCode,
          'Upcoming Festival ðŸŽ‰',
          '$festivalName is coming in 3 days! ${description ?? ""}',
          tz.TZDateTime.from(threeDaysBefore, tz.local),
          const NotificationDetails(
            android: AndroidNotificationDetails(
              'festival_reminders',
              'Festival Reminders',
              channelDescription: 'Reminders for upcoming festivals',
              importance: Importance.high,
              priority: Priority.high,
              icon: '@mipmap/ic_launcher',
              color: Color(0xFFFF6B35),
            ),
            iOS: DarwinNotificationDetails(
              presentAlert: true,
              presentBadge: true,
              presentSound: true,
            ),
          ),
          androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
          uiLocalNotificationDateInterpretation:
              UILocalNotificationDateInterpretation.absoluteTime,
          payload: 'festival_reminder',
        );
      }
      
      // Reminder on the day
      if (festivalDate.isAfter(DateTime.now())) {
        await _notificationsPlugin.zonedSchedule(
          festivalName.hashCode + 1,
          'Festival Today! ðŸŽŠ',
          'Today is $festivalName. Join in the celebrations!',
          tz.TZDateTime.from(
            DateTime(festivalDate.year, festivalDate.month, festivalDate.day, 6, 0),
            tz.local,
          ),
          const NotificationDetails(
            android: AndroidNotificationDetails(
              'festival_reminders',
              'Festival Reminders',
              channelDescription: 'Reminders for festivals',
              importance: Importance.max,
              priority: Priority.max,
              icon: '@mipmap/ic_launcher',
              color: Color(0xFFFF6B35),
              playSound: true,
              enableVibration: true,
            ),
            iOS: DarwinNotificationDetails(
              presentAlert: true,
              presentBadge: true,
              presentSound: true,
            ),
          ),
          androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
          uiLocalNotificationDateInterpretation:
              UILocalNotificationDateInterpretation.absoluteTime,
          payload: 'festival_today',
        );
      }
    } catch (e) {
      print('Error scheduling festival reminder: $e');
    }
  }
  
  /// Schedule achievement notification
  static Future<void> showAchievementNotification({
    required String achievementTitle,
    required String achievementDescription,
  }) async {
    try {
      await showNotification(
        id: DateTime.now().millisecondsSinceEpoch ~/ 1000,
        title: 'Achievement Unlocked! ðŸ†',
        body: '$achievementTitle - $achievementDescription',
        payload: 'achievement',
      );
    } catch (e) {
      print('Error showing achievement notification: $e');
    }
  }
  
  /// Update notification settings
  static Future<void> updateNotificationSettings({
    required bool enabled,
    String? reminderTime,
  }) async {
    try {
      await PreferencesService.setNotificationsEnabled(enabled);
      
      if (reminderTime != null) {
        await PreferencesService.setDailyReminderTime(reminderTime);
      }
      
      if (enabled) {
        await _scheduleDailyReminders();
      } else {
        await _cancelAllNotifications();
      }
    } catch (e) {
      print('Error updating notification settings: $e');
    }
  }
  
  /// Cancel all notifications
  static Future<void> _cancelAllNotifications() async {
    try {
      await _notificationsPlugin.cancelAll();
    } catch (e) {
      print('Error canceling notifications: $e');
    }
  }
  
  /// Cancel specific notification
  static Future<void> cancelNotification(int id) async {
    try {
      await _notificationsPlugin.cancel(id);
    } catch (e) {
      print('Error canceling notification $id: $e');
    }
  }
  
  /// Get pending notifications count
  static Future<int> getPendingNotificationsCount() async {
    try {
      final List<PendingNotificationRequest> pendingNotifications =
          await _notificationsPlugin.pendingNotificationRequests();
      return pendingNotifications.length;
    } catch (e) {
      print('Error getting pending notifications count: $e');
      return 0;
    }
  }
  
  /// Check if notifications are enabled
  static Future<bool> areNotificationsEnabled() async {
    try {
      final bool? result = await _notificationsPlugin
          .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin>()
          ?.areNotificationsEnabled();
      return result ?? false;
    } catch (e) {
      print('Error checking notifications enabled: $e');
      return false;
    }
  }
  
  /// Show motivational quotes based on user activity
  static Future<void> showMotivationalNotification() async {
    final List<Map<String, String>> quotes = [
      {
        'title': 'Divine Blessing ðŸ•‰ï¸',
        'body': 'Swamiye Saranam Ayyappa! May Lord Ayyappa guide your spiritual journey.',
      },
      {
        'title': 'Sacred Reminder ðŸ™',
        'body': 'Remember the divine teachings and stay blessed throughout the day.',
      },
      {
        'title': 'Spiritual Strength ðŸ’ª',
        'body': 'Draw strength from Lord Ayyappa\'s blessings in all your endeavors.',
      },
      {
        'title': 'Divine Protection ðŸ›¡ï¸',
        'body': 'May Lord Ayyappa protect and bless you and your family always.',
      },
    ];
    
    final quote = quotes[DateTime.now().millisecond % quotes.length];
    
    await showNotification(
      id: 999,
      title: quote['title']!,
      body: quote['body']!,
      payload: 'motivational',
    );
  }
}
//services/preferences_service.dart
import 'package:shared_preferences/shared_preferences.dart';

/// Service for managing user preferences and settings
class PreferencesService {
  static const String _languageKey = 'selected_language';
  static const String _themeKey = 'selected_theme';
  static const String _fontSizeKey = 'font_size';
  static const String _readingModeKey = 'reading_mode';
  static const String _notificationsKey = 'notifications_enabled';
  static const String _dailyReminderKey = 'daily_reminder_time';
  static const String _firstLaunchKey = 'first_launch';
  static const String _devotionalStreakKey = 'devotional_streak';
  static const String _lastOpenDateKey = 'last_open_date';
  static const String _achievementsKey = 'achievements';
  static const String _learningProgressKey = 'learning_progress';
  static const String _favoriteCollectionsKey = 'favorite_collections';
  
  static SharedPreferences? _prefs;
  
  /// Initialize preferences service
  static Future<void> init() async {
    try {
      _prefs = await SharedPreferences.getInstance();
    } catch (e) {
      print('Error initializing preferences: $e');
    }
  }
  
  /// Get SharedPreferences instance
  static SharedPreferences get prefs {
    if (_prefs == null) {
      throw Exception('PreferencesService not initialized. Call init() first.');
    }
    return _prefs!;
  }
  
  // Language Settings
  static String getLanguage() {
    try {
      return prefs.getString(_languageKey) ?? 'ta';
    } catch (e) {
      print('Error getting language: $e');
      return 'ta';
    }
  }
  
  static Future<bool> setLanguage(String language) async {
    try {
      return await prefs.setString(_languageKey, language);
    } catch (e) {
      print('Error setting language: $e');
      return false;
    }
  }
  
  // Theme Settings
  static String getTheme() {
    try {
      return prefs.getString(_themeKey) ?? 'light';
    } catch (e) {
      print('Error getting theme: $e');
      return 'light';
    }
  }
  
  static Future<bool> setTheme(String theme) async {
    try {
      return await prefs.setString(_themeKey, theme);
    } catch (e) {
      print('Error setting theme: $e');
      return false;
    }
  }
  
  // Font Size Settings
  static double getFontSize() {
    try {
      return prefs.getDouble(_fontSizeKey) ?? 16.0;
    } catch (e) {
      print('Error getting font size: $e');
      return 16.0;
    }
  }
  
  static Future<bool> setFontSize(double fontSize) async {
    try {
      return await prefs.setDouble(_fontSizeKey, fontSize);
    } catch (e) {
      print('Error setting font size: $e');
      return false;
    }
  }
  
  // Reading Mode Settings
  static String getReadingMode() {
    try {
      return prefs.getString(_readingModeKey) ?? 'normal';
    } catch (e) {
      print('Error getting reading mode: $e');
      return 'normal';
    }
  }
  
  static Future<bool> setReadingMode(String mode) async {
    try {
      return await prefs.setString(_readingModeKey, mode);
    } catch (e) {
      print('Error setting reading mode: $e');
      return false;
    }
  }
  
  // Notification Settings
  static bool getNotificationsEnabled() {
    try {
      return prefs.getBool(_notificationsKey) ?? true;
    } catch (e) {
      print('Error getting notifications setting: $e');
      return true;
    }
  }
  
  static Future<bool> setNotificationsEnabled(bool enabled) async {
    try {
      return await prefs.setBool(_notificationsKey, enabled);
    } catch (e) {
      print('Error setting notifications: $e');
      return false;
    }
  }
  
  // Daily Reminder Time
  static String getDailyReminderTime() {
    try {
      return prefs.getString(_dailyReminderKey) ?? '06:00';
    } catch (e) {
      print('Error getting daily reminder time: $e');
      return '06:00';
    }
  }
  
  static Future<bool> setDailyReminderTime(String time) async {
    try {
      return await prefs.setString(_dailyReminderKey, time);
    } catch (e) {
      print('Error setting daily reminder time: $e');
      return false;
    }
  }
  
  // First Launch
  static bool isFirstLaunch() {
    try {
      return prefs.getBool(_firstLaunchKey) ?? true;
    } catch (e) {
      print('Error checking first launch: $e');
      return true;
    }
  }
  
  static Future<bool> setFirstLaunchCompleted() async {
    try {
      return await prefs.setBool(_firstLaunchKey, false);
    } catch (e) {
      print('Error setting first launch completed: $e');
      return false;
    }
  }
  
  // Devotional Streak
  static int getDevotionalStreak() {
    try {
      return prefs.getInt(_devotionalStreakKey) ?? 0;
    } catch (e) {
      print('Error getting devotional streak: $e');
      return 0;
    }
  }
  
  static Future<bool> setDevotionalStreak(int streak) async {
    try {
      return await prefs.setInt(_devotionalStreakKey, streak);
    } catch (e) {
      print('Error setting devotional streak: $e');
      return false;
    }
  }
  
  // Last Open Date
  static String getLastOpenDate() {
    try {
      return prefs.getString(_lastOpenDateKey) ?? '';
    } catch (e) {
      print('Error getting last open date: $e');
      return '';
    }
  }
  
  static Future<bool> setLastOpenDate(String date) async {
    try {
      return await prefs.setString(_lastOpenDateKey, date);
    } catch (e) {
      print('Error setting last open date: $e');
      return false;
    }
  }
  
  // Achievements
  static List<String> getAchievements() {
    try {
      return prefs.getStringList(_achievementsKey) ?? [];
    } catch (e) {
      print('Error getting achievements: $e');
      return [];
    }
  }
  
  static Future<bool> setAchievements(List<String> achievements) async {
    try {
      return await prefs.setStringList(_achievementsKey, achievements);
    } catch (e) {
      print('Error setting achievements: $e');
      return false;
    }
  }
  
  static Future<bool> addAchievement(String achievement) async {
    try {
      List<String> achievements = getAchievements();
      if (!achievements.contains(achievement)) {
        achievements.add(achievement);
        return await setAchievements(achievements);
      }
      return true;
    } catch (e) {
      print('Error adding achievement: $e');
      return false;
    }
  }
  
  // Learning Progress
  static Map<String, dynamic> getLearningProgress() {
    try {
      String? progressJson = prefs.getString(_learningProgressKey);
      if (progressJson != null && progressJson.isNotEmpty) {
        // In a real app, you'd use json.decode here
        // For now, return empty map
        return {};
      }
      return {};
    } catch (e) {
      print('Error getting learning progress: $e');
      return {};
    }
  }
  
  static Future<bool> setLearningProgress(Map<String, dynamic> progress) async {
    try {
      // In a real app, you'd use json.encode here
      return await prefs.setString(_learningProgressKey, progress.toString());
    } catch (e) {
      print('Error setting learning progress: $e');
      return false;
    }
  }
  
  // Favorite Collections
  static List<String> getFavoriteCollections() {
    try {
      return prefs.getStringList(_favoriteCollectionsKey) ?? [];
    } catch (e) {
      print('Error getting favorite collections: $e');
      return [];
    }
  }
  
  static Future<bool> setFavoriteCollections(List<String> collections) async {
    try {
      return await prefs.setStringList(_favoriteCollectionsKey, collections);
    } catch (e) {
      print('Error setting favorite collections: $e');
      return false;
    }
  }
  
  // Utility Methods
  static Future<bool> clearAllPreferences() async {
    try {
      return await prefs.clear();
    } catch (e) {
      print('Error clearing preferences: $e');
      return false;
    }
  }
  
  static Future<bool> resetToDefaults() async {
    try {
      await setLanguage('ta');
      await setTheme('light');
      await setFontSize(16.0);
      await setReadingMode('normal');
      await setNotificationsEnabled(true);
      await setDailyReminderTime('06:00');
      await setDevotionalStreak(0);
      await setAchievements([]);
      await setLearningProgress({});
      await setFavoriteCollections([]);
      return true;
    } catch (e) {
      print('Error resetting to defaults: $e');
      return false;
    }
  }
  
  /// Update devotional streak based on daily usage
  static Future<void> updateDevotionalStreak() async {
    try {
      String today = DateTime.now().toString().split(' ')[0];
      String lastOpen = getLastOpenDate();
      
      if (lastOpen.isEmpty) {
        // First time opening
        await setDevotionalStreak(1);
        await setLastOpenDate(today);
      } else {
        DateTime lastOpenDate = DateTime.parse(lastOpen);
        DateTime todayDate = DateTime.parse(today);
        int daysDifference = todayDate.difference(lastOpenDate).inDays;
        
        if (daysDifference == 1) {
          // Consecutive day
          int currentStreak = getDevotionalStreak();
          await setDevotionalStreak(currentStreak + 1);
          await setLastOpenDate(today);
          
          // Award streak achievements
          int newStreak = currentStreak + 1;
          if (newStreak == 7) {
            await addAchievement('week_streak');
          } else if (newStreak == 30) {
            await addAchievement('month_streak');
          } else if (newStreak == 108) {
            await addAchievement('sacred_streak');
          }
        } else if (daysDifference > 1) {
          // Streak broken
          await setDevotionalStreak(1);
          await setLastOpenDate(today);
        }
        // If daysDifference == 0, same day, no change needed
      }
    } catch (e) {
      print('Error updating devotional streak: $e');
    }
  }
  
  /// Get user statistics
  static Map<String, dynamic> getUserStats() {
    try {
      return {
        'streak': getDevotionalStreak(),
        'achievements': getAchievements().length,
        'favoriteCollections': getFavoriteCollections().length,
        'learningProgress': getLearningProgress(),
        'theme': getTheme(),
        'language': getLanguage(),
        'fontSize': getFontSize(),
        'readingMode': getReadingMode(),
        'notificationsEnabled': getNotificationsEnabled(),
        'dailyReminderTime': getDailyReminderTime(),
      };
    } catch (e) {
      print('Error getting user stats: $e');
      return {};
    }
  }
}
//services/share_service.dart
import 'package:flutter/services.dart';
import 'package:share_plus/share_plus.dart';
import 'package:path_provider/path_provider.dart';
import 'dart:io';
import 'dart:typed_data';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import '../models/song_model.dart';
import '../models/devotional_content.dart';
import '../utils/constants.dart';

/// Service class for handling social sharing functionality
/// Enables sharing of devotional content, songs, mantras, and images
class ShareService {
  static const String _appName = 'Lord Ayyappa Devotional';
  static const String _appUrl = 'https://play.google.com/store/apps/details?id=com.ayyappa.devotional';
  
  /// Share a song with its lyrics in the selected language
  static Future<void> shareSong({
    required Song song,
    required String language,
    String? customMessage,
  }) async {
    try {
      final lyrics = _getSongLyrics(song, language);
      final languageDisplay = _getLanguageDisplayName(language);
      
      final message = customMessage ?? 
        'ðŸ•‰ï¸ ${song.title} - Lord Ayyappa Devotional Song\n\n'
        'ðŸŽµ Singer: ${song.singer}\n'
        'âœï¸ Writer: ${song.writer}\n'
        'ðŸŒ Language: $languageDisplay\n\n'
        '$lyrics\n\n'
        'ðŸ™ Shared via $_appName\n'
        'Download: $_appUrl';

      await Share.share(
        message,
        subject: 'ðŸ•‰ï¸ ${song.title} - Lord Ayyappa Devotional',
      );
    } catch (e) {
      debugPrint('Error sharing song: $e');
      rethrow;
    }
  }

  /// Share a daily mantra with decorative formatting
  static Future<void> shareMantra({
    required DevotionalContent mantra,
    String? customMessage,
  }) async {
    try {
      final message = customMessage ??
        'ðŸ•‰ï¸ Daily Mantra - Lord Ayyappa ðŸ•‰ï¸\n\n'
        '${mantra.title}\n\n'
        'ðŸ“¿ ${mantra.content}\n\n'
        'ðŸŒ¸ Meaning: ${mantra.description}\n\n'
        'ðŸ™ May Lord Ayyappa bless you!\n\n'
        'Shared via $_appName\n'
        'Download: $_appUrl';

      await Share.share(
        message,
        subject: 'ðŸ•‰ï¸ Daily Mantra - Lord Ayyappa',
      );
    } catch (e) {
      debugPrint('Error sharing mantra: $e');
      rethrow;
    }
  }

  /// Share a devotional quote with spiritual formatting
  static Future<void> shareQuote({
    required String quote,
    required String author,
    String? customMessage,
  }) async {
    try {
      final message = customMessage ??
        'ðŸŒº Devotional Quote ðŸŒº\n\n'
        '"$quote"\n\n'
        '~ $author\n\n'
        'ðŸ•‰ï¸ Ayyappa Swamy Saranam ðŸ•‰ï¸\n\n'
        'Shared via $_appName\n'
        'Download: $_appUrl';

      await Share.share(
        message,
        subject: 'ðŸŒº Devotional Quote - Lord Ayyappa',
      );
    } catch (e) {
      debugPrint('Error sharing quote: $e');
      rethrow;
    }
  }

  /// Share historical content about Lord Ayyappa
  static Future<void> shareHistory({
    required DevotionalContent history,
    String? customMessage,
  }) async {
    try {
      final message = customMessage ??
        'ðŸ“¿ Lord Ayyappa - ${history.title} ðŸ“¿\n\n'
        '${history.content}\n\n'
        'ðŸ™ Learn more about Lord Ayyappa\'s divine stories\n\n'
        'Shared via $_appName\n'
        'Download: $_appUrl';

      await Share.share(
        message,
        subject: 'ðŸ“¿ ${history.title} - Lord Ayyappa',
      );
    } catch (e) {
      debugPrint('Error sharing history: $e');
      rethrow;
    }
  }

  /// Share ritual information and guidelines
  static Future<void> shareRitual({
    required String ritualTitle,
    required String ritualContent,
    String? customMessage,
  }) async {
    try {
      final message = customMessage ??
        'ðŸ›• Ayyappa Ritual Guide ðŸ›•\n\n'
        '$ritualTitle\n\n'
        '$ritualContent\n\n'
        'ðŸ™ May your devotional journey be blessed!\n\n'
        'Shared via $_appName\n'
        'Download: $_appUrl';

      await Share.share(
        message,
        subject: 'ðŸ›• $ritualTitle - Lord Ayyappa',
      );
    } catch (e) {
      debugPrint('Error sharing ritual: $e');
      rethrow;
    }
  }

  /// Share the app with friends and family
  static Future<void> shareApp({
    String? customMessage,
  }) async {
    try {
      final message = customMessage ??
        'ðŸ•‰ï¸ Lord Ayyappa Devotional App ðŸ•‰ï¸\n\n'
        'ðŸŽµ Devotional Songs with Lyrics\n'
        'ðŸ“¿ Daily Mantras & Quotes\n'
        'ðŸ›• Sacred Rituals & History\n'
        'ðŸ“… Festival Calendar\n'
        'ðŸŒ Multiple Languages Support\n\n'
        'ðŸ™ Start your spiritual journey today!\n\n'
        'Download: $_appUrl';

      await Share.share(
        message,
        subject: 'ðŸ•‰ï¸ Lord Ayyappa Devotional App',
      );
    } catch (e) {
      debugPrint('Error sharing app: $e');
      rethrow;
    }
  }

  /// Share user's devotional progress and achievements
  static Future<void> shareProgress({
    required int totalSongsLearned,
    required int devotionalStreak,
    required int totalMantrasChanted,
    String? customMessage,
  }) async {
    try {
      final message = customMessage ??
        'ðŸ† My Devotional Journey - Lord Ayyappa ðŸ†\n\n'
        'ðŸŽµ Songs Learned: $totalSongsLearned\n'
        'ðŸ”¥ Devotional Streak: $devotionalStreak days\n'
        'ðŸ“¿ Mantras Chanted: $totalMantrasChanted\n\n'
        'ðŸ™ Ayyappa Swamy has blessed my spiritual path!\n\n'
        'Join me in devotion:\n'
        '$_appUrl';

      await Share.share(
        message,
        subject: 'ðŸ† My Devotional Journey - Lord Ayyappa',
      );
    } catch (e) {
      debugPrint('Error sharing progress: $e');
      rethrow;
    }
  }

  /// Share image with optional text overlay
  static Future<void> shareImage({
    required String imagePath,
    String? text,
    String? customMessage,
  }) async {
    try {
      final List<XFile> files = [XFile(imagePath)];
      
      final message = customMessage ??
        (text != null 
          ? 'ðŸ•‰ï¸ $text\n\nðŸ™ Ayyappa Swamy Saranam!\n\nShared via $_appName'
          : 'ðŸ•‰ï¸ Lord Ayyappa Blessings\n\nðŸ™ Ayyappa Swamy Saranam!\n\nShared via $_appName');

      
      await Share.shareXFiles(
        files,
        text: message,
        subject: 'ðŸ•‰ï¸ Lord Ayyappa Blessings',
      );
    } catch (e) {
      debugPrint('Error sharing image: $e');
      rethrow;
    }
  }

  /// Create and share a custom devotional card as image
  static Future<void> shareDevotionalCard({
    required GlobalKey cardKey,
    required String title,
    required String content,
  }) async {
    try {
      // Capture the widget as image
      final RenderRepaintBoundary boundary = 
          cardKey.currentContext!.findRenderObject() as RenderRepaintBoundary;
      
      final ui.Image image = await boundary.toImage(pixelRatio: 3.0);
      final ByteData? byteData = await image.toByteData(format: ui.ImageByteFormat.png);
      final Uint8List pngBytes = byteData!.buffer.asUint8List();

      // Save to temporary directory
      final directory = await getTemporaryDirectory();
      final imagePath = '${directory.path}/devotional_card_${DateTime.now().millisecondsSinceEpoch}.png';
      final imageFile = File(imagePath);
      await imageFile.writeAsBytes(pngBytes);

      // Share the image
      await shareImage(
        imagePath: imagePath,
        text: title,
        customMessage: 'ðŸ•‰ï¸ $title\n\n$content\n\nðŸ™ Ayyappa Swamy Saranam!\n\nShared via $_appName',
      );

      // Clean up temporary file
      await imageFile.delete();
    } catch (e) {
      debugPrint('Error sharing devotional card: $e');
      rethrow;
    }
  }

  /// Share festival information and dates
  static Future<void> shareFestival({
    required String festivalName,
    required DateTime festivalDate,
    required String description,
    String? customMessage,
  }) async {
    try {
      final formattedDate = '${festivalDate.day}/${festivalDate.month}/${festivalDate.year}';
      
      final message = customMessage ??
        'ðŸŽ‰ $festivalName ðŸŽ‰\n\n'
        'ðŸ“… Date: $formattedDate\n\n'
        '$description\n\n'
        'ðŸ™ Join us in celebrating Lord Ayyappa!\n\n'
        'Shared via $_appName\n'
        'Download: $_appUrl';

      await Share.share(
        message,
        subject: 'ðŸŽ‰ $festivalName - Lord Ayyappa',
      );
    } catch (e) {
      debugPrint('Error sharing festival: $e');
      rethrow;
    }
  }

  /// Share personalized devotional playlist
  static Future<void> sharePlaylist({
    required List<Song> songs,
    required String playlistName,
    String? customMessage,
  }) async {
    try {
      final songList = songs.map((song) => 'ðŸŽµ ${song.title} - ${song.singer}').join('\n');
      
      final message = customMessage ??
        'ðŸŽ¼ My Devotional Playlist: $playlistName ðŸŽ¼\n\n'
        '$songList\n\n'
        'ðŸ™ These songs bring me closer to Lord Ayyappa!\n\n'
        'Create your own playlist:\n'
        '$_appUrl';

      await Share.share(
        message,
        subject: 'ðŸŽ¼ $playlistName - Lord Ayyappa Devotional',
      );
    } catch (e) {
      debugPrint('Error sharing playlist: $e');
      rethrow;
    }
  }

  /// Get song lyrics based on selected language
  static String _getSongLyrics(Song song, String language) {
    switch (language) {
      case 'ta':
        return song.tamilLyrics.join('\n');
      case 'te':
        return song.teluguLyrics.join('\n');
      case 'en_ta':
        return song.englishPhoneticTamilLyrics.join('\n');
      case 'en_te':
        return song.englishPhoneticTeluguLyrics.join('\n');
      default:
        return song.tamilLyrics.join('\n');
    }
  }

  /// Get display name for language code
  static String _getLanguageDisplayName(String languageCode) {
    switch (languageCode) {
      case 'ta':
        return 'Tamil';
      case 'te':
        return 'Telugu';
      case 'en_ta':
        return 'English (Tamil Phonetic)';
      case 'en_te':
        return 'English (Telugu Phonetic)';
      default:
        return 'Tamil';
    }
  }

  /// Check if sharing is available on the device
  static Future<bool> isShareAvailable() async {
    try {
      // This is a simple check - share_plus handles platform availability
      return true;
    } catch (e) {
      debugPrint('Error checking share availability: $e');
      return false;
    }
  }

  /// Share with specific social media apps (if available)
  static Future<void> shareToSpecificApp({
    required String message,
    required String packageName,
  }) async {
    try {
      // Note: This would require platform-specific implementation
      // For now, we'll use the standard share dialog
      await Share.share(message);
    } catch (e) {
      debugPrint('Error sharing to specific app: $e');
      // Fallback to standard share
      await Share.share(message);
    }
  }

  /// Create a shareable text summary of user's favorites
  static Future<void> shareFavoritesSummary({
    required List<Song> favoriteSongs,
    required List<DevotionalContent> favoriteMantas,
    String? customMessage,
  }) async {
    try {
      final songsList = favoriteSongs
          .take(5)
          .map((song) => 'ðŸŽµ ${song.title}')
          .join('\n');
      
      final mantrasList = favoriteMantas
          .take(3)
          .map((mantra) => 'ðŸ“¿ ${mantra.title}')
          .join('\n');

      final message = customMessage ??
        'ðŸ’– My Favorite Devotional Content ðŸ’–\n\n'
        'Favorite Songs:\n$songsList\n\n'
        'Favorite Mantras:\n$mantrasList\n\n'
        'ðŸ™ These help me connect with Lord Ayyappa!\n\n'
        'Discover your favorites:\n'
        '$_appUrl';

      await Share.share(
        message,
        subject: 'ðŸ’– My Devotional Favorites - Lord Ayyappa',
      );
    } catch (e) {
      debugPrint('Error sharing favorites summary: $e');
      rethrow;
    }
  }
}
//utils/constants.dart
import 'package:flutter/material.dart';

/// App-wide constants including colors, dimensions, strings, and configuration
class AppConstants {
  // App Info
  static const String appName = 'Ayyappa Devotional';
  static const String appVersion = '1.0.0';
  static const String appDescription =
      'Premium devotional app for Lord Ayyappa';

  // Database
  static const String databaseName = 'ayyappa_devotional.db';
  static const int databaseVersion = 1;

  // SharedPreferences Keys
  static const String keyThemeMode = 'theme_mode';
  static const String keyLanguage = 'selected_language';
  static const String keyFontSize = 'font_size';
  static const String keyFirstLaunch = 'first_launch';
  static const String keyUserName = 'user_name';
  static const String keyDevotionalStreak = 'devotional_streak';
  static const String keyLastVisit = 'last_visit';
  static const String keyFavorites = 'favorites';
  static const String keyCompletedSongs = 'completed_songs';
  static const String keyAchievements = 'achievements';

  // Notification Settings
  static const String keyNotificationsEnabled = 'notifications_enabled';
  static const String keyNotificationTime = 'notification_time';
  static const String keyDailyReminderEnabled = 'daily_reminder_enabled';

  // Default Values
  static const double defaultFontSize = 16.0;
  static const double minFontSize = 12.0;
  static const double maxFontSize = 24.0;
  static const int defaultNotificationHour = 6;
  static const int defaultNotificationMinute = 0;

  // Animation Durations
  static const Duration shortAnimation = Duration(milliseconds: 200);
  static const Duration mediumAnimation = Duration(milliseconds: 300);
  static const Duration longAnimation = Duration(milliseconds: 500);

  // UI Dimensions
  static const double cardElevation = 8.0;
  static const double buttonElevation = 4.0;
  static const double borderRadius = 16.0;
  static const double smallBorderRadius = 8.0;
  static const double largeBorderRadius = 24.0;

  // Padding & Margins
  static const double smallPadding = 8.0;
  static const double mediumPadding = 16.0;
  static const double largePadding = 24.0;
  static const double extraLargePadding = 32.0;

  // Icon Sizes
  static const double smallIconSize = 16.0;
  static const double mediumIconSize = 24.0;
  static const double largeIconSize = 32.0;
  static const double extraLargeIconSize = 48.0;

  // Image Sizes
  static const double thumbnailSize = 60.0;
  static const double smallImageSize = 100.0;
  static const double mediumImageSize = 150.0;
  static const double largeImageSize = 200.0;

  // Languages
  static const List<String> supportedLanguages = ['en', 'ta', 'te'];
  static const String defaultLanguage = 'en';

  // API & URLs (for future use)
  static const String baseUrl = 'https://api.ayyappa-devotional.com';
  static const String feedbackEmail = 'feedback@ayyappa-devotional.com';
  static const String supportUrl = 'https://support.ayyappa-devotional.com';

  // Social Media
  static const String playStoreUrl =
      'https://play.google.com/store/apps/details?id=com.ayyappa.devotional';
  static const String appStoreUrl =
      'https://apps.apple.com/app/ayyappa-devotional/id123456789';

  // Achievement Thresholds
  static const int streakBeginner = 3;
  static const int streakIntermediate = 7;
  static const int streakAdvanced = 21;
  static const int streakMaster = 108;

  static const int songsBeginnerCount = 2;
  static const int songsIntermediateCount = 5;
  static const int songsAdvancedCount = 10;

  // Notification IDs
  static const int dailyReminderNotificationId = 1;
  static const int festivalNotificationId = 2;
  static const int achievementNotificationId = 3;
}

/// App color palette with spiritual theme
class AppColors {
  // Primary Colors (Saffron/Orange theme)
  static const Color primary = Color(0xFFFF6B35);
  static const Color primaryLight = Color(0xFFFF8F65);
  static const Color primaryDark = Color(0xFFE55100);

  // Secondary Colors (Deep Blue/Purple theme)
  static const Color secondary = Color(0xFF3F51B5);
  static const Color secondaryLight = Color(0xFF757DE8);
  static const Color secondaryDark = Color(0xFF002984);

  // Accent Colors (Gold theme)
  static const Color accent = Color(0xFFFFD700);
  static const Color accentLight = Color(0xFFFFE082);
  static const Color accentDark = Color(0xFFFFC107);

  // Devotional Colors
  static const Color devotionalOrange = Color(0xFFFF8A65);
  static const Color devotionalBlue = Color(0xFF5C6BC0);
  static const Color devotionalGold = Color(0xFFFFB74D);
  static const Color devotionalRed = Color(0xFFE57373);
  static const Color devotionalGreen = Color(0xFF81C784);

  // Gradient Colors
  static const List<Color> primaryGradient = [
    Color(0xFFFF6B35),
    Color(0xFFFF8F65),
  ];

  static const List<Color> secondaryGradient = [
    Color(0xFF3F51B5),
    Color(0xFF757DE8),
  ];

  static const List<Color> accentGradient = [
    Color(0xFFFFD700),
    Color(0xFFFFE082),
  ];

  static const List<Color> sunriseGradient = [
    Color(0xFFFF8A65),
    Color(0xFFFFB74D),
    Color(0xFFFFD700),
  ];

  static const List<Color> spiritualGradient = [
    Color(0xFF3F51B5),
    Color(0xFF9C27B0),
    Color(0xFFE91E63),
  ];

  // Text Colors
  static const Color textPrimary = Color(0xFF212121);
  static const Color textSecondary = Color(0xFF757575);
  static const Color textLight = Color(0xFFBDBDBD);
  static const Color textWhite = Color(0xFFFFFFFF);

  // Background Colors
  static const Color backgroundLight = Color(0xFFFAFAFA);
  static const Color backgroundDark = Color(0xFF121212);
  static const Color surfaceLight = Color(0xFFFFFFFF);
  static const Color surfaceDark = Color(0xFF1E1E1E);

  // Status Colors
  static const Color success = Color(0xFF4CAF50);
  static const Color warning = Color(0xFFFF9800);
  static const Color error = Color(0xFFF44336);
  static const Color info = Color(0xFF2196F3);

  // Glassmorphism Colors
  static Color glassMorphismLight = Colors.white.withOpacity(0.2);
  static Color glassMorphismDark = Colors.black.withOpacity(0.2);
  static Color glassMorphismBorder = Colors.white.withOpacity(0.3);

  // Shadow Colors
  static Color shadowLight = Colors.black.withOpacity(0.1);
  static Color shadowDark = Colors.black.withOpacity(0.3);
  static Color shadowColored = primary.withOpacity(0.2);
}

/// Text styles for the app
class AppTextStyles {
  // Headings
  static const TextStyle heading1 = TextStyle(
    fontSize: 32,
    fontWeight: FontWeight.bold,
    letterSpacing: -0.5,
  );

  static const TextStyle heading2 = TextStyle(
    fontSize: 28,
    fontWeight: FontWeight.bold,
    letterSpacing: -0.3,
  );

  static const TextStyle heading3 = TextStyle(
    fontSize: 24,
    fontWeight: FontWeight.w600,
    letterSpacing: -0.2,
  );

  static const TextStyle heading4 = TextStyle(
    fontSize: 20,
    fontWeight: FontWeight.w600,
    letterSpacing: 0,
  );

  static const TextStyle heading5 = TextStyle(
    fontSize: 18,
    fontWeight: FontWeight.w600,
    letterSpacing: 0.1,
  );

  static const TextStyle heading6 = TextStyle(
    fontSize: 16,
    fontWeight: FontWeight.w600,
    letterSpacing: 0.1,
  );

  // Body Text
  static const TextStyle bodyLarge = TextStyle(
    fontSize: 16,
    fontWeight: FontWeight.w400,
    letterSpacing: 0.2,
    height: 1.5,
  );

  static const TextStyle bodyMedium = TextStyle(
    fontSize: 14,
    fontWeight: FontWeight.w400,
    letterSpacing: 0.2,
    height: 1.4,
  );

  static const TextStyle bodySmall = TextStyle(
    fontSize: 12,
    fontWeight: FontWeight.w400,
    letterSpacing: 0.3,
    height: 1.3,
  );

  // Special Text Styles
  static const TextStyle devotionalText = TextStyle(
    fontSize: 18,
    fontWeight: FontWeight.w500,
    letterSpacing: 0.5,
    height: 1.6,
  );

  static const TextStyle mantraText = TextStyle(
    fontSize: 20,
    fontWeight: FontWeight.w500,
    letterSpacing: 1.0,
    height: 1.8,
  );

  static const TextStyle lyricsText = TextStyle(
    fontSize: 16,
    fontWeight: FontWeight.w400,
    letterSpacing: 0.3,
    height: 1.7,
  );

  // Button Text
  static const TextStyle buttonLarge = TextStyle(
    fontSize: 16,
    fontWeight: FontWeight.w600,
    letterSpacing: 0.5,
  );

  static const TextStyle buttonMedium = TextStyle(
    fontSize: 14,
    fontWeight: FontWeight.w600,
    letterSpacing: 0.5,
  );

  static const TextStyle buttonSmall = TextStyle(
    fontSize: 12,
    fontWeight: FontWeight.w600,
    letterSpacing: 0.5,
  );

  // Caption & Labels
  static const TextStyle caption = TextStyle(
    fontSize: 12,
    fontWeight: FontWeight.w400,
    letterSpacing: 0.4,
  );

  static const TextStyle label = TextStyle(
    fontSize: 14,
    fontWeight: FontWeight.w500,
    letterSpacing: 0.4,
  );

  static const TextStyle overline = TextStyle(
    fontSize: 10,
    fontWeight: FontWeight.w500,
    letterSpacing: 1.5,
  );
}

/// App theme configurations
class AppThemes {
  static const String light = 'light';
  static const String dark = 'dark';
  static const String sepia = 'sepia';

  // Sepia Theme Colors
  static const Color sepiaBackground = Color(0xFFF4F1E8);
  static const Color sepiaSurface = Color(0xFFFBF8F1);
  static const Color sepiaText = Color(0xFF3E2723);
  static const Color sepiaTextSecondary = Color(0xFF5D4037);
}

/// Animation curves and configurations
class AppAnimations {
  static const Curve easeInOut = Curves.easeInOut;
  static const Curve easeIn = Curves.easeIn;
  static const Curve easeOut = Curves.easeOut;
  static const Curve bounceIn = Curves.bounceIn;
  static const Curve bounceOut = Curves.bounceOut;
  static const Curve elastic = Curves.elasticOut;

  // Custom curves
  static const Curve spiritual = Curves.easeInOutSine;
  static const Curve gentle = Curves.easeInOutQuart;
}

/// Language-specific configurations
class LanguageConfig {
  static const Map<String, String> languageNames = {
    'en': 'English',
    'ta': 'à®¤à®®à®¿à®´à¯',
    'te': 'à°¤à±†à°²à±à°—à±',
  };

  static const Map<String, String> languageCodes = {
    'English': 'en',
    'Tamil': 'ta',
    'Telugu': 'te',
  };

  static const Map<String, String> fontFamilies = {
    'en': 'Poppins',
    'ta': 'TamilFont',
    'te': 'TeluguFont',
  };
}
//utils/helpers.dart
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

/// Utility helper functions for the Lord Ayyappa Devotional App
/// Contains common functionality used across the app
class AppHelpers {
  
  // Private constructor to prevent instantiation
  AppHelpers._();

  /// Date and Time Helpers
  static String formatDate(DateTime date, {String pattern = 'dd MMM yyyy'}) {
    try {
      return DateFormat(pattern).format(date);
    } catch (e) {
      return date.toString().split(' ')[0]; // Fallback to basic format
    }
  }

  static String formatTime(DateTime dateTime, {bool use24Hour = false}) {
    try {
      final pattern = use24Hour ? 'HH:mm' : 'hh:mm a';
      return DateFormat(pattern).format(dateTime);
    } catch (e) {
      return TimeOfDay.fromDateTime(dateTime).format(
        NavigatorService.navigatorKey.currentContext!,
      );
    }
  }

  static String getGreeting() {
    final hour = DateTime.now().hour;
    if (hour < 12) {
      return 'Good Morning';
    } else if (hour < 17) {
      return 'Good Afternoon';
    } else if (hour < 21) {
      return 'Good Evening';
    } else {
      return 'Good Night';
    }
  }

  static String getDevotionalGreeting() {
    final hour = DateTime.now().hour;
    if (hour >= 4 && hour < 12) {
      return 'Swamiye Saranam Ayyappa ðŸŒ…';
    } else if (hour >= 12 && hour < 18) {
      return 'Ayyappa Blessings ðŸ™';
    } else if (hour >= 18 && hour < 22) {
      return 'Evening Prayers ðŸ›•';
    } else {
      return 'Om Namah Shivaya ðŸŒ™';
    }
  }

  static bool isAuspiciousTime() {
    final hour = DateTime.now().hour;
    // Brahma Muhurta (4-6 AM) and Evening prayers (6-8 PM)
    return (hour >= 4 && hour < 6) || (hour >= 18 && hour < 20);
  }

  /// String Utilities
  static String capitalize(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1).toLowerCase();
  }

  static String capitalizeWords(String text) {
    return text.split(' ').map((word) => capitalize(word)).join(' ');
  }

  static String truncateText(String text, int maxLength, {String suffix = '...'}) {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength - suffix.length) + suffix;
  }

  static String removeExtraSpaces(String text) {
    return text.replaceAll(RegExp(r'\s+'), ' ').trim();
  }

  static bool isValidSearch(String query) {
    return query.trim().length >= 2;
  }

  /// Language Utilities
  static String getLanguageDisplayName(String languageCode) {
    switch (languageCode.toLowerCase()) {
      case 'tamil':
        return 'à®¤à®®à®¿à®´à¯';
      case 'telugu':
        return 'à°¤à±†à°²à±à°—à±';
      case 'english_phonetic_tamil':
        return 'Tamil (English)';
      case 'english_phonetic_telugu':
        return 'Telugu (English)';
      case 'english':
        return 'English';
      default:
        return capitalizeWords(languageCode.replaceAll('_', ' '));
    }
  }

  static bool isIndianLanguage(String languageCode) {
    return ['tamil', 'telugu', 'hindi', 'sanskrit'].contains(languageCode.toLowerCase());
  }

  static String getLanguageEmoji(String languageCode) {
    switch (languageCode.toLowerCase()) {
      case 'tamil':
        return 'ðŸ‡®ðŸ‡³';
      case 'telugu':
        return 'ðŸ‡®ðŸ‡³';
      case 'english':
      case 'english_phonetic_tamil':
      case 'english_phonetic_telugu':
        return 'ðŸ‡ºðŸ‡¸';
      default:
        return 'ðŸŒ';
    }
  }

  /// Search and Filter Helpers
  static List<T> filterList<T>(
    List<T> items,
    String query,
    List<String Function(T)> getSearchableFields,
  ) {
    if (query.trim().isEmpty) return items;
    
    final searchTerms = query.toLowerCase().split(' ').where((term) => term.isNotEmpty);
    
    return items.where((item) {
      final searchableText = getSearchableFields(item)
          .join(' ')
          .toLowerCase()
          .replaceAll(RegExp(r'[^\w\s]'), ''); // Remove special characters
      
      return searchTerms.every((term) => searchableText.contains(term));
    }).toList();
  }

  static List<T> sortList<T>(
    List<T> items,
    String Function(T) getSortKey,
    bool ascending,
  ) {
    items.sort((a, b) {
      final keyA = getSortKey(a).toLowerCase();
      final keyB = getSortKey(b).toLowerCase();
      return ascending ? keyA.compareTo(keyB) : keyB.compareTo(keyA);
    });
    return items;
  }

  /// UI Helpers
  static void showSnackBar(
    BuildContext context,
    String message, {
    Color? backgroundColor,
    Duration duration = const Duration(seconds: 3),
    SnackBarAction? action,
  }) {
    ScaffoldMessenger.of(context).hideCurrentSnackBar();
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: backgroundColor,
        duration: duration,
        action: action,
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
      ),
    );
  }

  static void showErrorSnackBar(BuildContext context, String message) {
    showSnackBar(
      context,
      message,
      backgroundColor: Colors.red.shade600,
    );
  }

  static void showSuccessSnackBar(BuildContext context, String message) {
    showSnackBar(
      context,
      message,
      backgroundColor: Colors.green.shade600,
    );
  }

  static Future<bool> showConfirmDialog(
    BuildContext context,
    String title,
    String content, {
    String confirmText = 'Confirm',
    String cancelText = 'Cancel',
  }) async {
    final result = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(title),
        content: Text(content),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(cancelText),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: Text(confirmText),
          ),
        ],
      ),
    );
    return result ?? false;
  }

  /// Validation Helpers
  static bool isValidEmail(String email) {
    return RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(email);
  }

  static bool isValidPhoneNumber(String phone) {
    return RegExp(r'^\+?[1-9]\d{1,14}$').hasMatch(phone.replaceAll(RegExp(r'[\s-()]'), ''));
  }

  /// Color Utilities
  static Color darkenColor(Color color, [double amount = 0.1]) {
    assert(amount >= 0 && amount <= 1);
    final hsl = HSLColor.fromColor(color);
    final hslDark = hsl.withLightness((hsl.lightness - amount).clamp(0.0, 1.0));
    return hslDark.toColor();
  }

  static Color lightenColor(Color color, [double amount = 0.1]) {
    assert(amount >= 0 && amount <= 1);
    final hsl = HSLColor.fromColor(color);
    final hslLight = hsl.withLightness((hsl.lightness + amount).clamp(0.0, 1.0));
    return hslLight.toColor();
  }

  static Color getContrastColor(Color backgroundColor) {
    // Calculate relative luminance
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? Colors.black : Colors.white;
  }

  /// Random Utilities
  static String getRandomDailyQuote(List<String> quotes) {
    if (quotes.isEmpty) return '';
    // Use day of year as seed for consistent daily quote
    final dayOfYear = DateTime.now().difference(DateTime(DateTime.now().year)).inDays;
    final random = Random(dayOfYear);
    return quotes[random.nextInt(quotes.length)];
  }

  static T getRandomItem<T>(List<T> items) {
    if (items.isEmpty) throw ArgumentError('List cannot be empty');
    final random = Random();
    return items[random.nextInt(items.length)];
  }

  /// File and Storage Helpers
  static String getFileExtension(String filename) {
    return filename.split('.').last.toLowerCase();
  }

  static bool isImageFile(String filename) {
    final extensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'];
    return extensions.contains(getFileExtension(filename));
  }

  static bool isAudioFile(String filename) {
    final extensions = ['mp3', 'wav', 'aac', 'ogg', 'm4a'];
    return extensions.contains(getFileExtension(filename));
  }

  static String formatFileSize(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    if (bytes < 1024 * 1024 * 1024) return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
    return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(1)} GB';
  }

  /// Performance Helpers
  static void debounce(VoidCallback callback, Duration delay) {
    Timer? timer;
    timer?.cancel();
    timer = Timer(delay, callback);
  }

  /// Navigation Helpers
  static Future<T?> pushPage<T>(BuildContext context, Widget page) {
    return Navigator.of(context).push<T>(
      MaterialPageRoute(builder: (context) => page),
    );
  }

  static Future<T?> pushReplacementPage<T, TO>(BuildContext context, Widget page) {
    return Navigator.of(context).pushReplacement<T, TO>(
      MaterialPageRoute(builder: (context) => page),
    );
  }

  static void popToRoot(BuildContext context) {
    Navigator.of(context).popUntil((route) => route.isFirst);
  }

  /// Accessibility Helpers
  static String getSemanticLabel(String text, String language) {
    // Provide semantic labels for screen readers
    switch (language.toLowerCase()) {
      case 'tamil':
        return 'Tamil text: $text';
      case 'telugu':
        return 'Telugu text: $text';
      case 'english_phonetic_tamil':
        return 'Tamil pronunciation: $text';
      case 'english_phonetic_telugu':
        return 'Telugu pronunciation: $text';
      default:
        return text;
    }
  }

  /// Animation Helpers
  static Animation<double> createFadeAnimation(
    AnimationController controller, {
    double begin = 0.0,
    double end = 1.0,
    Curve curve = Curves.easeInOut,
  }) {
    return Tween<double>(begin: begin, end: end).animate(
      CurvedAnimation(parent: controller, curve: curve),
    );
  }

  static Animation<Offset> createSlideAnimation(
    AnimationController controller, {
    Offset begin = const Offset(0.0, 1.0),
    Offset end = Offset.zero,
    Curve curve = Curves.easeInOut,
  }) {
    return Tween<Offset>(begin: begin, end: end).animate(
      CurvedAnimation(parent: controller, curve: curve),
    );
  }

  /// Device Information
  static bool isTablet(BuildContext context) {
    final mediaQuery = MediaQuery.of(context);
    return mediaQuery.size.width >= 600;
  }

  static bool isLandscape(BuildContext context) {
    return MediaQuery.of(context).orientation == Orientation.landscape;
  }

  static EdgeInsets getSafeAreaPadding(BuildContext context) {
    return MediaQuery.of(context).padding;
  }

  /// Error Handling
  static String getErrorMessage(dynamic error) {
    if (error is Exception) {
      return error.toString().replaceFirst('Exception: ', '');
    }
    return error.toString();
  }

  static void handleError(dynamic error, {VoidCallback? onError}) {
    debugPrint('Error: ${getErrorMessage(error)}');
    onError?.call();
  }

  /// Festival and Calendar Helpers
  static bool isFestivalDay(DateTime date, List<DateTime> festivalDates) {
    return festivalDates.any((festivalDate) =>
        festivalDate.year == date.year &&
        festivalDate.month == date.month &&
        festivalDate.day == date.day);
  }

  static int getDaysUntilFestival(DateTime nextFestival) {
    final now = DateTime.now();
    final difference = nextFestival.difference(DateTime(now.year, now.month, now.day));
    return difference.inDays;
  }

  /// Statistics Helpers
  static double calculatePercentage(int value, int total) {
    if (total == 0) return 0.0;
    return (value / total) * 100;
  }

  static String formatPercentage(double percentage, {int decimals = 1}) {
    return '${percentage.toStringAsFixed(decimals)}%';
  }
}

/// Global navigator service for showing dialogs and snackbars without context
class NavigatorService {
  static final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();
  
  static NavigatorState? get navigator => navigatorKey.currentState;
  static BuildContext? get context => navigatorKey.currentContext;
}

/// Extension to add utility methods to commonly used classes
extension StringExtension on String {
  String get capitalized => AppHelpers.capitalize(this);
  String get capitalizedWords => AppHelpers.capitalizeWords(this);
  String truncate(int maxLength, {String suffix = '...'}) => 
      AppHelpers.truncateText(this, maxLength, suffix: suffix);
  bool get isValidEmail => AppHelpers.isValidEmail(this);
  bool get isValidPhone => AppHelpers.isValidPhoneNumber(this);
}

extension DateTimeExtension on DateTime {
  String format([String pattern = 'dd MMM yyyy']) => AppHelpers.formatDate(this, pattern: pattern);
  String get timeFormat => AppHelpers.formatTime(this);
  bool get isToday {
    final now = DateTime.now();
    return year == now.year && month == now.month && day == now.day;
  }
  bool get isYesterday {
    final yesterday = DateTime.now().subtract(const Duration(days: 1));
    return year == yesterday.year && month == yesterday.month && day == yesterday.day;
  }
}

extension ColorExtension on Color {
  Color darken([double amount = 0.1]) => AppHelpers.darkenColor(this, amount);
  Color lighten([double amount = 0.1]) => AppHelpers.lightenColor(this, amount);
  Color get contrastColor => AppHelpers.getContrastColor(this);
}

extension ListExtension<T> on List<T> {
  T? get randomOrNull => isEmpty ? null : AppHelpers.getRandomItem(this);
  
  List<T> filter(String query, List<String Function(T)> getSearchableFields) =>
      AppHelpers.filterList(this, query, getSearchableFields);
      
  List<T> sortBy(String Function(T) getSortKey, bool ascending) =>
      AppHelpers.sortList(this, getSortKey, ascending);
}
//utils/mock_data.dart
import '../models/song_model.dart';
import '../models/ritual_model.dart';
import '../models/devotional_content.dart';
import '../models/festival_model.dart';
import '../models/user_model.dart';

/// Mock data for the Lord Ayyappa Devotional App
/// This file contains sample data for development and testing purposes
class MockData {
  
  /// Sample songs with multilingual lyrics
  static List<Song> getSongs() {
    return [
      Song(
        id: '1',
        title: 'Harivarasanam',
        singer: 'K.J. Yesudas',
        writer: 'Kambankudi Kulathur Srinivasa Iyer',
        iconType: 'god',
        isFavorite: false,
        playCount: 0,
        lyrics: {
          'tamil': _getHarivarasanamTamil(),
          'telugu': _getHarivarasanamTelugu(),
          'englishPhoneticTamil': _getHarivarasanamEnglishPhoneticTamil(),
          'englishPhoneticTelugu': _getHarivarasanamEnglishPhoneticTelugu(),
        },
        audioUrl: 'assets/audio/harivarasanam.mp3',
        duration: Duration(minutes: 8, seconds: 30),
        tags: ['devotional', 'classical', 'evening', 'prayer'],
        mood: 'peaceful',
        tempo: 'slow',
        raga: 'Madhyamavati',
        createdAt: DateTime.now().subtract(Duration(days: 30)),
        updatedAt: DateTime.now().subtract(Duration(days: 5)),
      ),
      Song(
        id: '2',
        title: 'Saranam Ayyappa',
        singer: 'M.G. Sreekumar',
        writer: 'Kavalam Narayana Panicker',
        iconType: 'music',
        isFavorite: true,
        playCount: 15,
        lyrics: {
          'tamil': _getSaranamAyyappaTamil(),
          'telugu': _getSaranamAyyappaTelugu(),
          'englishPhoneticTamil': _getSaranamAyyappaEnglishPhoneticTamil(),
          'englishPhoneticTelugu': _getSaranamAyyappaEnglishPhoneticTelugu(),
        },
        audioUrl: 'assets/audio/saranam_ayyappa.mp3',
        duration: Duration(minutes: 6, seconds: 45),
        tags: ['devotional', 'upbeat', 'pilgrimage', 'chant'],
        mood: 'energetic',
        tempo: 'medium',
        raga: 'Kalyani',
        createdAt: DateTime.now().subtract(Duration(days: 20)),
        updatedAt: DateTime.now().subtract(Duration(days: 3)),
      ),
    ];
  }

  /// Sample rituals and customs
  static List<Ritual> getRituals() {
    return [
      Ritual(
        id: '1',
        title: 'Sabarimala Pilgrimage Preparation',
        category: 'pilgrimage',
        description: 'Complete guide for preparing for the sacred Sabarimala pilgrimage',
        duration: Duration(days: 41),
        difficulty: 'advanced',
        instructions: [
          'Begin 41-day Vratham (austerity period)',
          'Daily meditation and prayers',
          'Vegetarian diet and celibacy',
          'Wear only black or blue clothes',
          'Avoid alcohol and tobacco',
          'Regular temple visits',
          'Chant Ayyappa mantras daily',
          'Carry Irumudi (sacred bundle)',
          'Maintain physical fitness for trekking',
          'Seek blessings from elders',
        ],
        materials: [
          'Black/Blue clothes',
          'Rudraksha mala',
          'Irumudi kit',
          'Coconut (for breaking)',
          'Ghee for abhishekam',
          'Sacred thread',
          'Vibhuti (sacred ash)',
          'Tulsi leaves',
          'Incense sticks',
          'Oil lamp',
        ],
        benefits: [
          'Spiritual purification',
          'Mental discipline',
          'Physical fitness',
          'Devotional growth',
          'Self-control development',
          'Community bonding',
          'Cultural connection',
          'Inner peace',
          'Divine blessings',
          'Life transformation',
        ],
        precautions: [
          'Medical checkup before pilgrimage',
          'Gradual physical preparation',
          'Proper diet planning',
          'Weather-appropriate clothing',
          'Emergency contact information',
          'Valid identification documents',
          'Booking accommodation in advance',
          'Carrying sufficient water',
          'Following queue discipline',
          'Respecting temple customs',
        ],
        images: [
          'assets/images/rituals/sabarimala_preparation.jpg',
          'assets/images/rituals/irumudi_kit.jpg',
          'assets/images/rituals/vratham_items.jpg',
        ],
        videoUrl: 'assets/videos/sabarimala_guide.mp4',
        createdAt: DateTime.now().subtract(Duration(days: 60)),
        updatedAt: DateTime.now().subtract(Duration(days: 10)),
      ),
      Ritual(
        id: '2',
        title: 'Daily Ayyappa Worship',
        category: 'daily',
        description: 'Step-by-step guide for daily Lord Ayyappa worship at home',
        duration: Duration(minutes: 30),
        difficulty: 'beginner',
        instructions: [
          'Wake up early (Brahma Muhurta)',
          'Take bath and wear clean clothes',
          'Light oil lamp and incense',
          'Offer flowers to Ayyappa idol',
          'Chant Ayyappa Ashtakam',
          'Perform Abhishekam with milk/water',
          'Offer Prasadam (coconut, banana)',
          'Sing devotional songs',
          'Meditate for 10 minutes',
          'Conclude with Aarti',
        ],
        materials: [
          'Ayyappa idol or photo',
          'Oil lamp',
          'Incense sticks',
          'Fresh flowers',
          'Coconut',
          'Bananas',
          'Milk or water',
          'Vibhuti',
          'Kumkum',
          'Camphor',
        ],
        benefits: [
          'Daily spiritual connection',
          'Mental peace',
          'Positive energy',
          'Devotional practice',
          'Family bonding',
          'Cultural preservation',
          'Discipline development',
          'Stress relief',
          'Clarity of mind',
          'Divine protection',
        ],
        precautions: [
          'Maintain cleanliness',
          'Use fresh materials daily',
          'Keep worship area sacred',
          'Avoid distractions',
          'Proper pronunciation of mantras',
          'Respectful attitude',
          'Consistent timing',
          'Sincere devotion',
          'Appropriate attire',
          'Focused mind',
        ],
        images: [
          'assets/images/rituals/daily_worship.jpg',
          'assets/images/rituals/home_altar.jpg',
          'assets/images/rituals/puja_items.jpg',
        ],
        videoUrl: 'assets/videos/daily_worship_guide.mp4',
        createdAt: DateTime.now().subtract(Duration(days: 45)),
        updatedAt: DateTime.now().subtract(Duration(days: 8)),
      ),
    ];
  }

  /// Sample devotional content
  static List<DevotionalContent> getDevotionalContent() {
    return [
      DevotionalContent(
        id: '1',
        title: 'The Birth of Lord Ayyappa',
        type: 'history',
        category: 'legends',
        content: '''
Lord Ayyappa, also known as Dharma Sastha, was born from the union of Lord Shiva and Mohini (the female avatar of Lord Vishnu). This divine birth occurred to fulfill a cosmic purpose - to destroy the demoness Mahishi who was terrorizing the three worlds.

The story begins with Mahishi, the buffalo-headed demoness, who had received a boon that she could only be killed by a child born to Shiva and Vishnu. Confident in her invincibility, she began her reign of terror across the heavens and earth.

The devas approached Lord Vishnu for help. Vishnu took the form of Mohini, the enchanting goddess, and united with Lord Shiva. From this divine union, Lord Ayyappa was born on the banks of the river Pampa.

The divine child was found by King Rajasekhara of Panthalam, who was childless. The king adopted the child and named him Manikandan, after the golden bell (mani) around his neck.

As Manikandan grew up, his divine nature became evident through various miraculous deeds. When the time came, he revealed his true identity and fulfilled his cosmic purpose by defeating Mahishi.

After completing his mission, Lord Ayyappa established himself at Sabarimala, where he promised to bless all devotees who come to him with sincere devotion and after observing the prescribed austerities.

This sacred story teaches us about the divine intervention in times of crisis and the importance of righteousness over evil.
''',
        tags: ['birth', 'legend', 'divinity', 'Sabarimala', 'Manikandan'],
        language: 'english',
        author: 'Ancient Scriptures',
        readingTime: Duration(minutes: 5),
        images: [
          'assets/images/content/ayyappa_birth.jpg',
          'assets/images/content/mohini_shiva.jpg',
          'assets/images/content/baby_manikandan.jpg',
        ],
        audioUrl: 'assets/audio/ayyappa_birth_story.mp3',
        createdAt: DateTime.now().subtract(Duration(days: 90)),
        updatedAt: DateTime.now().subtract(Duration(days: 15)),
      ),
      DevotionalContent(
        id: '2',
        title: 'The Legend of Puli Paal',
        type: 'history',
        category: 'legends',
        content: '''
One of the most famous stories from Lord Ayyappa's childhood is the legend of Puli Paal (Tiger's Milk). This miraculous event demonstrated the divine nature of young Manikandan and his supernatural powers.

The story unfolds when the queen of Panthalam, who had initially been jealous of the adopted prince Manikandan, fell seriously ill. The royal physician declared that only tiger's milk could cure her ailment.

The king was deeply worried, as obtaining tiger's milk seemed impossible. However, young Manikandan volunteered for this dangerous mission, much to everyone's amazement and concern.

Despite the court's protests about the dangers involved, Manikandan set out into the dense forests alone. The entire kingdom waited anxiously for his return.

When Manikandan returned, he was riding a magnificent tiger, followed by a procession of tigers and other wild animals. The sight was both awe-inspiring and terrifying for the people of Panthalam.

The young prince had not only obtained the tiger's milk but had also tamed the fierce beasts of the forest. This miraculous feat revealed his divine nature to all who witnessed it.

The queen was cured instantly upon drinking the tiger's milk, and she realized the divine nature of Manikandan. She sought his forgiveness for her earlier jealousy and became his devoted follower.

This legend symbolizes the triumph of good over evil, the power of divine intervention, and the importance of courage in the face of impossible challenges.

The story of Puli Paal continues to inspire devotees, reminding them that with faith and devotion, even the most difficult tasks can be accomplished.
''',
        tags: ['Puli Paal', 'tiger', 'miracle', 'Manikandan', 'Panthalam'],
        language: 'english',
        author: 'Traditional Folklore',
        readingTime: Duration(minutes: 6),
        images: [
          'assets/images/content/puli_paal.jpg',
          'assets/images/content/manikandan_tiger.jpg',
          'assets/images/content/panthalam_palace.jpg',
        ],
        audioUrl: 'assets/audio/puli_paal_story.mp3',
        createdAt: DateTime.now().subtract(Duration(days: 85)),
        updatedAt: DateTime.now().subtract(Duration(days: 12)),
      ),
    ];
  }

  /// Sample festivals
  static List<Festival> getFestivals() {
    return [
      Festival(
        id: '1',
        name: 'Mandala Pooja',
        description: 'The first 41 days of the Sabarimala pilgrimage season',
        date: DateTime(2024, 11, 16),
        endDate: DateTime(2024, 12, 26),
        category: 'major',
        significance: 'Marks the beginning of the Sabarimala pilgrimage season',
        traditions: [
          'Vratham (41-day austerity)',
          'Daily prayers and meditation',
          'Vegetarian diet',
          'Wearing sacred clothes',
          'Temple visits',
          'Community prayers',
          'Charitable activities',
          'Spiritual discussions',
        ],
        celebrations: [
          'Temple decorations',
          'Special poojas',
          'Devotional music',
          'Cultural programs',
          'Free food distribution',
          'Pilgrimage preparations',
          'Community gatherings',
          'Spiritual discourses',
        ],
        location: 'Sabarimala and worldwide',
        duration: Duration(days: 41),
        images: [
          'assets/images/festivals/mandala_pooja.jpg',
          'assets/images/festivals/sabarimala_temple.jpg',
          'assets/images/festivals/devotees_procession.jpg',
        ],
        isActive: true,
        createdAt: DateTime.now().subtract(Duration(days: 100)),
        updatedAt: DateTime.now().subtract(Duration(days: 20)),
      ),
      Festival(
        id: '2',
        name: 'Makaravilakku',
        description: 'The most sacred festival of Sabarimala',
        date: DateTime(2024, 1, 14),
        endDate: DateTime(2024, 1, 20),
        category: 'major',
        significance: 'Celebrates the divine light of Lord Ayyappa',
        traditions: [
          'Makarajyothi viewing',
          'Special abhishekam',
          'Continuous prayers',
          'Devotional singing',
          'Processions',
          'Charitable feeding',
          'Cultural performances',
          'Spiritual awakening',
        ],
        celebrations: [
          'Divine light appearance',
          'Grand celebrations',
          'Devotees gathering',
          'Special ceremonies',
          'Cultural programs',
          'Prasadam distribution',
          'Music concerts',
          'Spiritual discourses',
        ],
        location: 'Sabarimala',
        duration: Duration(days: 7),
        images: [
          'assets/images/festivals/makaravilakku.jpg',
          'assets/images/festivals/makarajyothi.jpg',
          'assets/images/festivals/devotees_celebration.jpg',
        ],
        isActive: true,
        createdAt: DateTime.now().subtract(Duration(days: 95)),
        updatedAt: DateTime.now().subtract(Duration(days: 18)),
      ),
    ];
  }

  /// Sample user data
  static UserModel getSampleUser() {
    return UserModel(
      id: 'user_123',
      name: 'Devotee User',
      email: 'devotee@example.com',
      profileImage: 'assets/images/profile/default_avatar.jpg',
      dateOfBirth: DateTime(1990, 5, 15),
      location: 'Chennai, Tamil Nadu',
      preferredLanguage: 'tamil',
      theme: 'light',
      devotionalJourney: DevotionalJourney(
        startDate: DateTime.now().subtract(Duration(days: 365)),
        totalDays: 365,
        currentStreak: 45,
        longestStreak: 120,
        songsLearned: 15,
        ritualsCompleted: 8,
        templesVisited: 12,
        pilgrimagesCompleted: 2,
      ),
      achievements: [
        Achievement(
          id: 'first_song',
          title: 'First Song Learned',
          description: 'Learned your first devotional song',
          icon: 'music_note',
          earnedDate: DateTime.now().subtract(Duration(days: 300)),
          category: 'learning',
        ),
        Achievement(
          id: 'streak_30',
          title: '30 Day Streak',
          description: 'Maintained daily devotion for 30 days',
          icon: 'streak',
          earnedDate: DateTime.now().subtract(Duration(days: 200)),
          category: 'consistency',
        ),
        Achievement(
          id: 'pilgrimage_complete',
          title: 'Sabarimala Pilgrim',
          description: 'Completed Sabarimala pilgrimage',
          icon: 'temple',
          earnedDate: DateTime.now().subtract(Duration(days: 100)),
          category: 'pilgrimage',
        ),
      ],
      settings: UserSettings(
        notifications: true,
        dailyReminders: true,
        soundEnabled: true,
        vibrationEnabled: true,
        autoPlay: false,
        downloadQuality: 'high',
        fontSize: 16.0,
        playbackSpeed: 1.0,
      ),
      favorites: [
        'song_1',
        'song_2',
        'ritual_1',
        'content_1',
        'festival_1',
      ],
      recentlyViewed: [
        RecentItem(
          id: 'song_1',
          type: 'song',
          title: 'Harivarasanam',
          viewedAt: DateTime.now().subtract(Duration(hours: 2)),
        ),
        RecentItem(
          id: 'ritual_1',
          type: 'ritual',
          title: 'Daily Ayyappa Worship',
          viewedAt: DateTime.now().subtract(Duration(hours: 5)),
        ),
      ],
      createdAt: DateTime.now().subtract(Duration(days: 365)),
      updatedAt: DateTime.now().subtract(Duration(hours: 1)),
    );
  }

  /// Daily quotes for inspiration
  static List<String> getDailyQuotes() {
    return [
      'Swamiye Saranam Ayyappa - Surrender to the Lord brings peace',
      'Devotion is the key that opens the door to divine grace',
      'In the silence of prayer, the soul finds its true voice',
      'Every step taken with faith leads to spiritual growth',
      'The light of Ayyappa shines brightest in a pure heart',
      'Patience and perseverance are the pillars of spiritual journey',
      'True pilgrimage begins within the heart',
      'Compassion is the highest form of worship',
      'In service to others, we find service to God',
      'The divine resides in every act of selfless love',
    ];
  }

  /// Weather-based greetings
  static Map<String, List<String>> getWeatherGreetings() {
    return {
      'sunny': [
        'May Lord Ayyappa bless you with a bright day!',
        'Like the sun\'s rays, may divine light illuminate your path',
        'Shine bright with Ayyappa\'s blessings',
      ],
      'rainy': [
        'May the rains wash away all sorrows',
        'Like the gentle rain, may peace flow into your heart',
        'Lord Ayyappa\'s grace falls like blessed rain',
      ],
      'cloudy': [
        'Behind every cloud, Ayyappa\'s love shines',
        'Even in clouds, find the silver lining of devotion',
        'May your faith be as constant as the eternal sky',
      ],
      'default': [
        'Swamiye Saranam Ayyappa! Have a blessed day',
        'May Lord Ayyappa guide your steps today',
        'Start your day with divine blessings',
      ],
    };
  }

  // Private methods for song lyrics

  static List<String> _getHarivarasanamTamil() {
    return [
      'à®¹à®°à®¿à®µà®°à®¾à®šà®©à®®à¯ à®µà®¿à®·à¯à®£à¯ à®®à¯‹à®¹à®©à®®à¯',
      'à®¹à®°à®¿à®¤à®¾à®¸ à®¸à¯à®µà®°à¯‚à®ªà®®à¯ à®†à®´à¯à®µà®¾à®°à¯ à®µà®¨à¯à®¤à®©à®®à¯',
      'à®…à®°à®¿à®µà®¿à®°à®°à®¾à®œ à®®à®¾à®©à®¸ à®ªà¯‚à®œà®¿à®¤à®®à¯',
      'à®…à®°à®¿à®•à®° à®¸à®®à¯à®¸à¯à®¤à¯à®¤ à®®à¯‚à®°à¯à®¤à¯à®¤à®¿ à®¨à®®à®¾à®®à®¿',
      'à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯',
      'à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯',
      'à®šà®°à®£à®•à®¿à®°à®¿ à®µà®¾à®¸ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯',
      'à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯',
      'à®¹à®°à®¿à®µà®°à®¾à®šà®©à®®à¯ à®µà®¿à®·à¯à®£à¯ à®®à¯‹à®¹à®©à®®à¯',
      'à®¹à®°à®¿à®¤à®¾à®¸ à®¸à¯à®µà®°à¯‚à®ªà®®à¯ à®†à®´à¯à®µà®¾à®°à¯ à®µà®¨à¯à®¤à®©à®®à¯',
      'à®…à®°à®¿à®¯à¯à®®à¯ à®¹à®°à®¿à®¯à¯à®®à¯ à®œà®©à¯à®®à®®à¯ à®Žà®Ÿà¯à®¤à¯à®¤à®¾à®°à¯',
      'à®…à®°à®¿à®¯ à®¸à®¾à®¸à¯à®¤à®¾à®µà®¾à®• à®…à®µà®¤à®°à®¿à®¤à¯à®¤à®¾à®°à¯',
      'à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯',
      'à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯',
      'à®šà®°à®£à®•à®¿à®°à®¿ à®µà®¾à®¸ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯',
      'à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯',
      'à®ªà¯‚à®²à¯‹à®• à®µà®¾à®¸ à®ªà®µà®© à®¨à®¿à®µà®¾à®¸',
      'à®¸à®¤à¯à®¯ à®¸à®¾à®¸à¯à®¤à¯ à®†à®¸à¯à®°à®¿à®¤ à®ªà®¾à®²à®©',
      'à®ªà¯‚à®¤à®¨à®¾à®¤ à®ªà®µà®© à®ªà¯à®£à¯à®¯ à®¤à®¾à®¸',
      'à®ªà¯‚à®¤ à®¨à®¾à®® à®ªà®µà®© à®ªà¯‚à®œà®¿à®¤ à®¸à¯à®°à¯€',
      'à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯',
      'à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯',
      'à®šà®°à®£à®•à®¿à®°à®¿ à®µà®¾à®¸ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯',
      'à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯ à®šà®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®©à¯',
      'à®¸à®¾à®¸à¯à®¤à®¾à®™à¯à®• à®¨à®®à®¸à¯à®•à®¾à®°à®®à¯ à®à®¯à®ªà¯à®ªà®¾',
      'à®¸à®°à¯à®µ à®œà®•à®¤à¯ à®ªà®°à®¿à®ªà®¾à®²à®•à®¾',
      'à®¸à®°à¯à®µ à®œà®© à®¸à¯à®• à®¤à®¾à®¯à®•à®¾',
      'à®¸à¯à®µà®¾à®®à®¿ à®¸à®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®¾',
      'à®¸à¯à®µà®¾à®®à®¿ à®¸à®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®¾',
      'à®¸à¯à®µà®¾à®®à®¿ à®¸à®°à®£à®®à¯ à®à®¯à®ªà¯à®ªà®¾',
    ];
  }

  static List<String> _getHarivarasanamTelugu() {
    return [
      'à°¹à°°à°¿à°µà°°à°¾à°¸à°¨à°‚ à°µà°¿à°·à±à°£à± à°®à±‹à°¹à°¨à°‚',
      'à°¹à°°à°¿à°¦à°¾à°¸ à°¸à±à°µà°°à±‚à°ªà°‚ à°†à°³à±à°µà°¾à°°à± à°µà°‚à°¦à°¨à°‚',
      'à°…à°°à°¿à°µà°¿à°°à°¾à°°à°¾à°œ à°®à°¾à°¨à°¸ à°ªà±‚à°œà°¿à°¤à°‚',
      'à°…à°°à°¿à°•à°° à°¸à°‚à°¸à±à°¤à±à°¤ à°®à±‚à°°à±à°¤à°¿ à°¨à°®à°¾à°®à°¿',
      'à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°¶à°°à°£à°—à°¿à°°à°¿ à°µà°¾à°¸ à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°¹à°°à°¿à°µà°°à°¾à°¸à°¨à°‚ à°µà°¿à°·à±à°£à± à°®à±‹à°¹à°¨à°‚',
      'à°¹à°°à°¿à°¦à°¾à°¸ à°¸à±à°µà°°à±‚à°ªà°‚ à°†à°³à±à°µà°¾à°°à± à°µà°‚à°¦à°¨à°‚',
      'à°…à°°à°¿à°¯à±‚ à°¹à°°à°¿à°¯à±‚ à°œà°¨à±à°®à°‚ à°Žà°¤à±à°¤à°¾à°°à±',
      'à°…à°°à°¿à°¶à°¾à°¸à±à°¤à°¾à°µà±à°—à°¾ à°…à°µà°¤à°°à°¿à°‚à°šà°¾à°°à±',
      'à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°¶à°°à°£à°—à°¿à°°à°¿ à°µà°¾à°¸ à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°­à±‚à°²à±‹à°• à°µà°¾à°¸ à°­à°µà°¨ à°¨à°¿à°µà°¾à°¸',
      'à°¸à°¤à±à°¯ à°¶à°¾à°¸à±à°¤à± à°†à°¶à±à°°à°¿à°¤ à°ªà°¾à°²à°¨',
      'à°­à±‚à°¤à°¨à°¾à°¤ à°­à°µà°¨ à°ªà±à°£à±à°¯ à°¦à°¾à°¸',
      'à°­à±‚à°¤ à°¨à°¾à°® à°­à°µà°¨ à°ªà±‚à°œà°¿à°¤ à°¶à±à°°à±€',
      'à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°¶à°°à°£à°—à°¿à°°à°¿ à°µà°¾à°¸ à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°¶à°¾à°·à±à°Ÿà°¾à°‚à°— à°¨à°®à°¸à±à°•à°¾à°°à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°¸à°°à±à°µ à°œà°—à°¤à± à°ªà°°à°¿à°ªà°¾à°²à°•à°¾',
      'à°¸à°°à±à°µ à°œà°¨ à°¸à±à°– à°¦à°¾à°¯à°•à°¾',
      'à°¸à±à°µà°¾à°®à°¿ à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°¸à±à°µà°¾à°®à°¿ à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
      'à°¸à±à°µà°¾à°®à°¿ à°¶à°°à°£à°‚ à°…à°¯à±à°¯à°ªà±à°ª',
    ];
  }

  static List<String> _getHarivarasanamEnglishPhoneticTamil() {
    return [
      'Harivarasanam Vishnu Mohanam',
      'Haridasa Swaroopam Alwar Vandanam',
      'Ariviraja Manasa Poojitam',
      'Arikara Samstuta Moorti Namami',
      'Saranam Ayyappan Saranam Ayyappan',
      'Saranam Ayyappan Saranam Ayyappan',
      'Saranagiri Vasa Saranam Ayyappan',
      'Saranam Ayyappan Saranam Ayyappan',
      'Harivarasanam Vishnu Mohanam',
      'Haridasa Swaroopam Alwar Vandanam',
      'Ariyum Hariyum Janmam Eduthaar',
      'Ariya Sastavaga Avatharithaar',
      'Saranam Ayyappan Saranam Ayyappan',
      'Saranam Ayyappan Saranam Ayyappan',
      'Saranagiri Vasa Saranam Ayyappan',
      'Saranam Ayyappan Saranam Ayyappan',
      'Bhooloka Vasa Bhavana Nivasa',
      'Satya Sast Asrita Palana',
      'Bhootanatha Bhavana Punya Dasa',
      'Bhoota Nama Bhavana Poojita Sri',
      'Saranam Ayyappan Saranam Ayyappan',
      'Saranam Ayyappan Saranam Ayyappan',
      'Saranagiri Vasa Saranam Ayyappan',
      'Saranam Ayyappan Saranam Ayyappan',
      'Sastanga Namaskaram Ayyappa',
      'Sarva Jagat Paripalaka',
      'Sarva Jana Sukha Dayaka',
      'Swami Saranam Ayyappa',
      'Swami Saranam Ayyappa',
      'Swami Saranam Ayyappa',
    ];
  }

  static List<String> _getHarivarasanamEnglishPhoneticTelugu() {
    return [
      'Harivarasanam Vishnu Mohanam',
      'Haridasa Swaroopam Alwar Vandanam',
      'Ariviraja Manasa Poojitam',
      'Arikara Samstuta Moorti Namami',
      'Saranam Ayyappa Saranam Ayyappa',
      'Saranam Ayyappa Saranam Ayyappa',
      'Saranagiri Vasa Saranam Ayyappa',
      'Saranam Ayyappa Saranam Ayyappa',
      'Harivarasanam Vishnu Mohanam',
      'Haridasa Swaroopam Alwar Vandanam',
      'Ariyoo Hariyoo Janmam Ettaru',
      'Arikhyastavuga Avatharincharu',
      'Saranam Ayyappa Saranam Ayyappa',
      'Saranam Ayyappa Saranam Ayyappa',
      'Saranagiri Vasa Saranam Ayyappa',
      'Saranam Ayyappa Saranam Ayyappa',
      'Bhooloka Vasa Bhavana Nivasa',
      'Satya Sast Asrita Palana',
      'Bhootanatha Bhavana Punya Dasa',
      'Bhoota Nama Bhavana Poojita Sri',
      'Saranam Ayyappa Saranam Ayyappa',
//utils/text_styles.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'constants.dart';

/// Custom text styles for the Lord Ayyappa Devotional App
/// Provides consistent typography across the app with spiritual aesthetics
class AppTextStyles {
  // Base font families
  static const String _defaultFontFamily = 'Roboto';
  static const String _tamilFontFamily = 'tamil_font';
  static const String _teluguFontFamily = 'telugu_font';

  // Heading Styles
  static TextStyle get heading1 => GoogleFonts.poppins(
        fontSize: 28,
        fontWeight: FontWeight.bold,
        color: AppColors.primarySaffron,
        height: 1.2,
        letterSpacing: 0.5,
      );

  static TextStyle get heading2 => GoogleFonts.poppins(
        fontSize: 24,
        fontWeight: FontWeight.w600,
        color: AppColors.deepPurple,
        height: 1.3,
        letterSpacing: 0.3,
      );

  static TextStyle get heading3 => GoogleFonts.poppins(
        fontSize: 20,
        fontWeight: FontWeight.w600,
        color: AppColors.textPrimary,
        height: 1.4,
        letterSpacing: 0.2,
      );

  static TextStyle get heading4 => GoogleFonts.poppins(
        fontSize: 18,
        fontWeight: FontWeight.w500,
        color: AppColors.textPrimary,
        height: 1.4,
      );

  // Body Text Styles
  static TextStyle get bodyLarge => GoogleFonts.inter(
        fontSize: 16,
        fontWeight: FontWeight.normal,
        color: AppColors.textPrimary,
        height: 1.5,
        letterSpacing: 0.1,
      );

  static TextStyle get bodyMedium => GoogleFonts.inter(
        fontSize: 14,
        fontWeight: FontWeight.normal,
        color: AppColors.textPrimary,
        height: 1.5,
      );

  static TextStyle get bodySmall => GoogleFonts.inter(
        fontSize: 12,
        fontWeight: FontWeight.normal,
        color: AppColors.textSecondary,
        height: 1.4,
      );

  // Specialized Text Styles
  static TextStyle get caption => GoogleFonts.inter(
        fontSize: 11,
        fontWeight: FontWeight.w400,
        color: AppColors.textSecondary,
        height: 1.3,
        letterSpacing: 0.3,
      );

  static TextStyle get overline => GoogleFonts.inter(
        fontSize: 10,
        fontWeight: FontWeight.w500,
        color: AppColors.textSecondary,
        height: 1.2,
        letterSpacing: 1.5,
      ).copyWith(textBaseline: TextBaseline.alphabetic);

  // Button Text Styles
  static TextStyle get buttonLarge => GoogleFonts.poppins(
        fontSize: 16,
        fontWeight: FontWeight.w600,
        color: Colors.white,
        letterSpacing: 0.5,
      );

  static TextStyle get buttonMedium => GoogleFonts.poppins(
        fontSize: 14,
        fontWeight: FontWeight.w600,
        color: Colors.white,
        letterSpacing: 0.3,
      );

  static TextStyle get buttonSmall => GoogleFonts.poppins(
        fontSize: 12,
        fontWeight: FontWeight.w500,
        color: Colors.white,
        letterSpacing: 0.2,
      );

  // Special Devotional Styles
  static TextStyle get devotionalTitle => GoogleFonts.cinzel(
        fontSize: 22,
        fontWeight: FontWeight.bold,
        color: AppColors.sacredGold,
        height: 1.3,
        letterSpacing: 1.0,
      );

  static TextStyle get mantraText => GoogleFonts.crimsonText(
        fontSize: 18,
        fontWeight: FontWeight.w500,
        color: AppColors.deepPurple,
        height: 1.6,
        letterSpacing: 0.5,
        fontStyle: FontStyle.italic,
      );

  static TextStyle get quoteText => GoogleFonts.playfairDisplay(
        fontSize: 16,
        fontWeight: FontWeight.w400,
        color: AppColors.textPrimary,
        height: 1.7,
        letterSpacing: 0.3,
        fontStyle: FontStyle.italic,
      );

  // Lyrics Styles (Variable Font Size)
  static TextStyle lyricsStyle({
    required double fontSize,
    required String language,
    Color? color,
    FontWeight? fontWeight,
  }) {
    // Default color and font weight
    color ??= AppColors.textPrimary;
    fontWeight ??= FontWeight.normal;

    switch (language.toLowerCase()) {
      case 'tamil':
        return TextStyle(
          fontFamily: _tamilFontFamily,
          fontSize: fontSize,
          fontWeight: fontWeight,
          color: color,
          height: 1.8,
          letterSpacing: 0.2,
        );
      case 'telugu':
        return TextStyle(
          fontFamily: _teluguFontFamily,
          fontSize: fontSize,
          fontWeight: fontWeight,
          color: color,
          height: 1.8,
          letterSpacing: 0.2,
        );
      case 'english_phonetic_tamil':
      case 'english_phonetic_telugu':
        return GoogleFonts.openSans(
          fontSize: fontSize,
          fontWeight: fontWeight,
          color: color,
          height: 1.7,
          letterSpacing: 0.3,
          fontStyle: FontStyle.italic,
        );
      default:
        return GoogleFonts.inter(
          fontSize: fontSize,
          fontWeight: fontWeight,
          color: color,
          height: 1.6,
          letterSpacing: 0.1,
        );
    }
  }

  // Navigation Styles
  static TextStyle get navigationLabel => GoogleFonts.poppins(
        fontSize: 12,
        fontWeight: FontWeight.w500,
        color: AppColors.textSecondary,
        letterSpacing: 0.3,
      );

  static TextStyle get navigationLabelActive => GoogleFonts.poppins(
        fontSize: 12,
        fontWeight: FontWeight.w600,
        color: AppColors.primarySaffron,
        letterSpacing: 0.3,
      );

  // Card Styles
  static TextStyle get cardTitle => GoogleFonts.poppins(
        fontSize: 16,
        fontWeight: FontWeight.w600,
        color: AppColors.textPrimary,
        height: 1.3,
      );

  static TextStyle get cardSubtitle => GoogleFonts.inter(
        fontSize: 14,
        fontWeight: FontWeight.w400,
        color: AppColors.textSecondary,
        height: 1.4,
      );

  // List Item Styles
  static TextStyle get listTitle => GoogleFonts.poppins(
        fontSize: 16,
        fontWeight: FontWeight.w500,
        color: AppColors.textPrimary,
        height: 1.3,
      );

  static TextStyle get listSubtitle => GoogleFonts.inter(
        fontSize: 13,
        fontWeight: FontWeight.w400,
        color: AppColors.textSecondary,
        height: 1.3,
      );

  static TextStyle get listMeta => GoogleFonts.inter(
        fontSize: 11,
        fontWeight: FontWeight.w400,
        color: AppColors.textTertiary,
        height: 1.2,
      );

  // Error and Success Styles
  static TextStyle get errorText => GoogleFonts.inter(
        fontSize: 14,
        fontWeight: FontWeight.w500,
        color: AppColors.error,
        height: 1.4,
      );

  static TextStyle get successText => GoogleFonts.inter(
        fontSize: 14,
        fontWeight: FontWeight.w500,
        color: AppColors.success,
        height: 1.4,
      );

  static TextStyle get warningText => GoogleFonts.inter(
        fontSize: 14,
        fontWeight: FontWeight.w500,
        color: AppColors.warning,
        height: 1.4,
      );

  // Search and Filter Styles
  static TextStyle get searchHint => GoogleFonts.inter(
        fontSize: 14,
        fontWeight: FontWeight.w400,
        color: AppColors.textTertiary,
        height: 1.4,
      );

  static TextStyle get filterChip => GoogleFonts.poppins(
        fontSize: 12,
        fontWeight: FontWeight.w500,
        color: AppColors.textSecondary,
        letterSpacing: 0.2,
      );

  static TextStyle get filterChipSelected => GoogleFonts.poppins(
        fontSize: 12,
        fontWeight: FontWeight.w600,
        color: Colors.white,
        letterSpacing: 0.2,
      );

  // Theme-aware text styles
  static TextStyle getThemeAwareStyle(
    TextStyle baseStyle,
    ThemeMode themeMode,
  ) {
    switch (themeMode) {
      case ThemeMode.dark:
        return baseStyle.copyWith(
          color: _adjustColorForDarkTheme(baseStyle.color),
        );
      case ThemeMode.light:
        return baseStyle;
      case ThemeMode.system:
        // Handle system theme - would need context for this
        return baseStyle;
    }
  }

  // Helper method to adjust colors for dark theme
  static Color? _adjustColorForDarkTheme(Color? originalColor) {
    if (originalColor == null) return null;
    
    // Convert dark colors to light equivalents for dark theme
    if (originalColor == AppColors.textPrimary) {
      return Colors.white;
    } else if (originalColor == AppColors.textSecondary) {
      return Colors.white70;
    } else if (originalColor == AppColors.textTertiary) {
      return Colors.white54;
    }
    
    return originalColor;
  }

  // Responsive text scaling
  static TextStyle responsive(
    TextStyle baseStyle,
    BuildContext context, {
    double minScale = 0.8,
    double maxScale = 1.2,
  }) {
    final mediaQuery = MediaQuery.of(context);
    final screenWidth = mediaQuery.size.width;
    
    // Base scale factor on screen width
    double scaleFactor = 1.0;
    if (screenWidth < 360) {
      scaleFactor = minScale;
    } else if (screenWidth > 600) {
      scaleFactor = maxScale;
    } else {
      scaleFactor = 1.0 + (screenWidth - 360) / (600 - 360) * (maxScale - 1.0);
    }
    
    return baseStyle.copyWith(
      fontSize: (baseStyle.fontSize ?? 14) * scaleFactor,
    );
  }

  // Language-specific text styles factory
  static TextStyle getLanguageStyle(
    String language, {
    double fontSize = 16,
    FontWeight fontWeight = FontWeight.normal,
    Color? color,
  }) {
    return lyricsStyle(
      fontSize: fontSize,
      language: language,
      color: color,
      fontWeight: fontWeight,
    );
  }

  // Gradient text style (for special effects)
  static TextStyle get gradientTitle => GoogleFonts.cinzel(
        fontSize: 24,
        fontWeight: FontWeight.bold,
        height: 1.2,
        letterSpacing: 0.8,
      );
}

/// Extension to easily apply theme-aware styles
extension TextStyleExtension on TextStyle {
  TextStyle themeAware(ThemeMode themeMode) {
    return AppTextStyles.getThemeAwareStyle(this, themeMode);
  }
  
  TextStyle responsive(BuildContext context) {
    return AppTextStyles.responsive(this, context);
  }
  
  TextStyle withOpacity(double opacity) {
    return copyWith(color: color?.withOpacity(opacity));
  }
}
//widgets/common/custom_app_bar.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';

class CustomAppBar extends StatefulWidget implements PreferredSizeWidget {
  final String title;
  final List<Widget>? actions;
  final Widget? leading;
  final bool centerTitle;
  final bool enableScrollEffect;
  final VoidCallback? onBackPressed;
  final Color? backgroundColor;
  final Color? foregroundColor;
  final double elevation;
  final bool showDivider;
  final Widget? bottom;
  final double? leadingWidth;
  final bool automaticallyImplyLeading;
  final PreferredSizeWidget? bottomWidget;

  const CustomAppBar({
    Key? key,
    required this.title,
    this.actions,
    this.leading,
    this.centerTitle = true,
    this.enableScrollEffect = true,
    this.onBackPressed,
    this.backgroundColor,
    this.foregroundColor,
    this.elevation = 0,
    this.showDivider = false,
    this.bottom,
    this.leadingWidth,
    this.automaticallyImplyLeading = true,
    this.bottomWidget,
  }) : super(key: key);

  @override
  State<CustomAppBar> createState() => _CustomAppBarState();

  @override
  Size get preferredSize => Size.fromHeight(
        kToolbarHeight + (bottomWidget?.preferredSize.height ?? 0),
      );
}

class _CustomAppBarState extends State<CustomAppBar>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );

    _fadeAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    ));

    _scaleAnimation = Tween<double>(
      begin: 0.95,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeOutBack,
    ));

    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return AnimatedBuilder(
      animation: _animationController,
      builder: (context, child) {
        return FadeTransition(
          opacity: _fadeAnimation,
          child: ScaleTransition(
            scale: _scaleAnimation,
            child: Container(
              decoration: BoxDecoration(
                gradient: widget.enableScrollEffect
                    ? LinearGradient(
                        begin: Alignment.topLeft,
                        end: Alignment.bottomRight,
                        colors: [
                          widget.backgroundColor ?? 
                          (isDark 
                            ? AppColors.primarySaffron.withOpacity(0.1)
                            : AppColors.primarySaffron.withOpacity(0.05)),
                          widget.backgroundColor ?? 
                          (isDark 
                            ? theme.scaffoldBackgroundColor
                            : Colors.white.withOpacity(0.95)),
                        ],
                      )
                    : null,
                color: !widget.enableScrollEffect 
                    ? (widget.backgroundColor ?? theme.appBarTheme.backgroundColor)
                    : null,
                boxShadow: widget.elevation > 0
                    ? [
                        BoxShadow(
                          color: AppColors.primarySaffron.withOpacity(0.1),
                          blurRadius: 8,
                          offset: const Offset(0, 2),
                        ),
                      ]
                    : null,
              ),
              child: AppBar(
                title: _buildTitle(),
                centerTitle: widget.centerTitle,
                leading: _buildLeading(),
                actions: _buildActions(),
                backgroundColor: Colors.transparent,
                elevation: 0,
                scrolledUnderElevation: 0,
                systemOverlayStyle: SystemUiOverlayStyle(
                  statusBarColor: Colors.transparent,
                  statusBarIconBrightness: isDark ? Brightness.light : Brightness.dark,
                  statusBarBrightness: isDark ? Brightness.dark : Brightness.light,
                ),
                foregroundColor: widget.foregroundColor ?? 
                    (isDark ? Colors.white : AppColors.primarySaffron),
                leadingWidth: widget.leadingWidth,
                automaticallyImplyLeading: widget.automaticallyImplyLeading,
                bottom: widget.bottomWidget,
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildTitle() {
    return Hero(
      tag: 'app_bar_title_${widget.title}',
      child: Material(
        color: Colors.transparent,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                AppColors.primarySaffron.withOpacity(0.1),
                AppColors.sacredGold.withOpacity(0.05),
              ],
            ),
            borderRadius: BorderRadius.circular(20),
            border: Border.all(
              color: AppColors.primarySaffron.withOpacity(0.2),
              width: 1,
            ),
          ),
          child: Text(
            widget.title,
            style: AppTextStyles.headlineSmall.copyWith(
              color: widget.foregroundColor ?? AppColors.primarySaffron,
              fontWeight: FontWeight.bold,
              fontSize: 18,
            ),
          ),
        ),
      ),
    );
  }

  Widget? _buildLeading() {
    if (widget.leading != null) {
      return widget.leading;
    }

    if (widget.automaticallyImplyLeading && Navigator.canPop(context)) {
      return Container(
        margin: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: AppColors.primarySaffron.withOpacity(0.1),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: AppColors.primarySaffron.withOpacity(0.2),
            width: 1,
          ),
        ),
        child: IconButton(
          icon: Icon(
            Icons.arrow_back_ios_new,
            color: widget.foregroundColor ?? AppColors.primarySaffron,
            size: 20,
          ),
          onPressed: widget.onBackPressed ?? () => Navigator.pop(context),
          tooltip: 'Back',
        ),
      );
    }

    return null;
  }

  List<Widget>? _buildActions() {
    if (widget.actions == null || widget.actions!.isEmpty) {
      return null;
    }

    return widget.actions!.map((action) {
      return Container(
        margin: const EdgeInsets.only(right: 8, top: 8, bottom: 8),
        decoration: BoxDecoration(
          color: AppColors.primarySaffron.withOpacity(0.1),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: AppColors.primarySaffron.withOpacity(0.2),
            width: 1,
          ),
        ),
        child: action,
      );
    }).toList();
  }
}

class ImmersiveScrollAppBar extends StatefulWidget implements PreferredSizeWidget {
  final String title;
  final List<Widget>? actions;
  final Widget? leading;
  final ScrollController? scrollController;
  final double expandedHeight;
  final Widget? flexibleSpace;
  final bool pinned;
  final bool floating;
  final bool snap;
  final VoidCallback? onBackPressed;

  const ImmersiveScrollAppBar({
    Key? key,
    required this.title,
    this.actions,
    this.leading,
    this.scrollController,
    this.expandedHeight = 200.0,
    this.flexibleSpace,
    this.pinned = true,
    this.floating = false,
    this.snap = false,
    this.onBackPressed,
  }) : super(key: key);

  @override
  State<ImmersiveScrollAppBar> createState() => _ImmersiveScrollAppBarState();

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}

class _ImmersiveScrollAppBarState extends State<ImmersiveScrollAppBar> {
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return SliverAppBar(
      expandedHeight: widget.expandedHeight,
      floating: widget.floating,
      pinned: widget.pinned,
      snap: widget.snap,
      elevation: 0,
      scrolledUnderElevation: 0,
      backgroundColor: Colors.transparent,
      leading: _buildLeading(),
      actions: _buildActions(),
      systemOverlayStyle: SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarIconBrightness: Brightness.light,
        statusBarBrightness: Brightness.dark,
      ),
      flexibleSpace: FlexibleSpaceBar(
        title: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
          decoration: BoxDecoration(
            color: Colors.black.withOpacity(0.3),
            borderRadius: BorderRadius.circular(16),
            border: Border.all(
              color: Colors.white.withOpacity(0.3),
              width: 1,
            ),
          ),
          child: Text(
            widget.title,
            style: AppTextStyles.headlineSmall.copyWith(
              color: Colors.white,
              fontWeight: FontWeight.bold,
              fontSize: 16,
              shadows: [
                Shadow(
                  color: Colors.black.withOpacity(0.5),
                  offset: const Offset(1, 1),
                  blurRadius: 3,
                ),
              ],
            ),
          ),
        ),
        centerTitle: true,
        titlePadding: const EdgeInsets.only(bottom: 16),
        background: widget.flexibleSpace ?? Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                AppColors.primarySaffron,
                AppColors.sacredGold,
                AppColors.deepPurple,
              ],
            ),
          ),
          child: Container(
            decoration: BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topCenter,
                end: Alignment.bottomCenter,
                colors: [
                  Colors.transparent,
                  Colors.black.withOpacity(0.3),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget? _buildLeading() {
    if (widget.leading != null) {
      return widget.leading;
    }

    if (Navigator.canPop(context)) {
      return Container(
        margin: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.3),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: Colors.white.withOpacity(0.3),
            width: 1,
          ),
        ),
        child: IconButton(
          icon: const Icon(
            Icons.arrow_back_ios_new,
            color: Colors.white,
            size: 20,
          ),
          onPressed: widget.onBackPressed ?? () => Navigator.pop(context),
          tooltip: 'Back',
        ),
      );
    }

    return null;
  }

  List<Widget>? _buildActions() {
    if (widget.actions == null || widget.actions!.isEmpty) {
      return null;
    }

    return widget.actions!.map((action) {
      return Container(
        margin: const EdgeInsets.only(right: 8, top: 8, bottom: 8),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.3),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: Colors.white.withOpacity(0.3),
            width: 1,
          ),
        ),
        child: action,
      );
    }).toList();
  }
}

class CollapsibleAppBar extends StatefulWidget {
  final String title;
  final String? subtitle;
  final Widget? leading;
  final List<Widget>? actions;
  final Widget body;
  final double expandedHeight;
  final Widget? background;
  final bool pinned;
  final bool floating;

  const CollapsibleAppBar({
    Key? key,
    required this.title,
    this.subtitle,
    this.leading,
    this.actions,
    required this.body,
    this.expandedHeight = 250.0,
    this.background,
    this.pinned = true,
    this.floating = false,
  }) : super(key: key);

  @override
  State<CollapsibleAppBar> createState() => _CollapsibleAppBarState();
}

class _CollapsibleAppBarState extends State<CollapsibleAppBar> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: CustomScrollView(
        slivers: [
          SliverAppBar(
            expandedHeight: widget.expandedHeight,
            floating: widget.floating,
            pinned: widget.pinned,
            elevation: 0,
            scrolledUnderElevation: 0,
            backgroundColor: Colors.transparent,
            leading: widget.leading,
            actions: widget.actions,
            flexibleSpace: FlexibleSpaceBar(
              title: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                    decoration: BoxDecoration(
                      color: Colors.black.withOpacity(0.4),
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: Text(
                      widget.title,
                      style: AppTextStyles.headlineSmall.copyWith(
                        color: Colors.white,
                        fontWeight: FontWeight.bold,
                        fontSize: 16,
                      ),
                    ),
                  ),
                  if (widget.subtitle != null) ...[
                    const SizedBox(height: 4),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                      decoration: BoxDecoration(
                        color: Colors.white.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        widget.subtitle!,
                        style: AppTextStyles.bodySmall.copyWith(
                          color: Colors.white,
                          fontSize: 12,
                        ),
                      ),
                    ),
                  ],
                ],
              ),
              centerTitle: true,
              titlePadding: const EdgeInsets.only(bottom: 16),
              background: widget.background ?? Container(
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                    colors: [
                      AppColors.primarySaffron,
                      AppColors.sacredGold,
                    ],
                  ),
                ),
                child: Container(
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      begin: Alignment.topCenter,
                      end: Alignment.bottomCenter,
                      colors: [
                        Colors.transparent,
                        Colors.black.withOpacity(0.4),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
          SliverFillRemaining(
            child: widget.body,
          ),
        ],
      ),
    );
  }
}
//widgets/common/devotional_card.dart
import 'package:flutter/material.dart';
import '../../utils/constants.dart';

/// A premium glassmorphism card widget for devotional content
/// Features blur effects, gradient borders, and elegant shadows
class DevotionalCard extends StatefulWidget {
  final Widget child;
  final EdgeInsetsGeometry? padding;
  final EdgeInsetsGeometry? margin;
  final double? width;
  final double? height;
  final VoidCallback? onTap;
  final bool showGlow;
  final Color? glowColor;
  final double borderRadius;
  final Gradient? gradient;
  final bool showBorder;
  final double elevation;
  final Color? backgroundColor;
  final bool isInteractive;

  const DevotionalCard({
    Key? key,
    required this.child,
    this.padding,
    this.margin,
    this.width,
    this.height,
    this.onTap,
    this.showGlow = false,
    this.glowColor,
    this.borderRadius = 16.0,
    this.gradient,
    this.showBorder = true,
    this.elevation = 4.0,
    this.backgroundColor,
    this.isInteractive = true,
  }) : super(key: key);

  @override
  State<DevotionalCard> createState() => _DevotionalCardState();
}

class _DevotionalCardState extends State<DevotionalCard>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;
  late Animation<double> _glowAnimation;
  bool _isPressed = false;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 1.0,
      end: 0.98,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    ));

    _glowAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    ));
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  void _handleTapDown(TapDownDetails details) {
    if (!widget.isInteractive) return;
    setState(() => _isPressed = true);
    _animationController.forward();
  }

  void _handleTapUp(TapUpDetails details) {
    if (!widget.isInteractive) return;
    setState(() => _isPressed = false);
    _animationController.reverse();
  }

  void _handleTapCancel() {
    if (!widget.isInteractive) return;
    setState(() => _isPressed = false);
    _animationController.reverse();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    
    return AnimatedBuilder(
      animation: _animationController,
      builder: (context, child) {
        return Container(
          margin: widget.margin ?? const EdgeInsets.all(8.0),
          width: widget.width,
          height: widget.height,
          child: Transform.scale(
            scale: _scaleAnimation.value,
            child: GestureDetector(
              onTapDown: _handleTapDown,
              onTapUp: _handleTapUp,
              onTapCancel: _handleTapCancel,
              onTap: widget.onTap,
              child: Container(
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(widget.borderRadius),
                  boxShadow: [
                    // Main shadow
                    BoxShadow(
                      color: (isDark ? Colors.black : AppColors.primary)
                          .withOpacity(0.1),
                      blurRadius: widget.elevation * 2,
                      offset: Offset(0, widget.elevation),
                    ),
                    // Glow effect when pressed or specified
                    if (widget.showGlow || _isPressed)
                      BoxShadow(
                        color: (widget.glowColor ?? AppColors.accent)
                            .withOpacity(0.3 * _glowAnimation.value),
                        blurRadius: 20.0,
                        spreadRadius: 2.0,
                      ),
                  ],
                ),
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(widget.borderRadius),
                  child: Stack(
                    children: [
                      // Background with glassmorphism effect
                      Container(
                        decoration: BoxDecoration(
                          gradient: widget.gradient ??
                              LinearGradient(
                                begin: Alignment.topLeft,
                                end: Alignment.bottomRight,
                                colors: isDark
                                    ? [
                                        Colors.white.withOpacity(0.1),
                                        Colors.white.withOpacity(0.05),
                                      ]
                                    : [
                                        Colors.white.withOpacity(0.9),
                                        Colors.white.withOpacity(0.7),
                                      ],
                              ),
                          color: widget.backgroundColor,
                        ),
                      ),
                      
                      // Gradient border
                      if (widget.showBorder)
                        Container(
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(widget.borderRadius),
                            border: Border.all(
                              width: 1.0,
                              color: isDark
                                  ? Colors.white.withOpacity(0.2)
                                  : AppColors.primary.withOpacity(0.3),
                            ),
                          ),
                        ),
                      
                      // Sacred geometry pattern overlay
                      Positioned.fill(
                        child: Opacity(
                          opacity: 0.03,
                          child: Container(
                            decoration: BoxDecoration(
                              borderRadius: BorderRadius.circular(widget.borderRadius),
                              image: const DecorationImage(
                                image: AssetImage('assets/images/backgrounds/sacred_pattern.png'),
                                fit: BoxFit.cover,
                                repeat: ImageRepeat.repeat,
                              ),
                            ),
                          ),
                        ),
                      ),
                      
                      // Content
                      Padding(
                        padding: widget.padding ?? const EdgeInsets.all(16.0),
                        child: widget.child,
                      ),
                      
                      // Shimmer effect on interaction
                      if (_isPressed)
                        Positioned.fill(
                          child: Container(
                            decoration: BoxDecoration(
                              borderRadius: BorderRadius.circular(widget.borderRadius),
                              gradient: LinearGradient(
                                begin: Alignment.topLeft,
                                end: Alignment.bottomRight,
                                colors: [
                                  Colors.white.withOpacity(0.1),
                                  Colors.transparent,
                                  Colors.white.withOpacity(0.1),
                                ],
                                stops: const [0.0, 0.5, 1.0],
                              ),
                            ),
                          ),
                        ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}

/// Specialized card for daily mantras with sacred styling
class DailyMantraCard extends StatelessWidget {
  final String mantra;
  final String translation;
  final String? meaning;
  final VoidCallback? onTap;

  const DailyMantraCard({
    Key? key,
    required this.mantra,
    required this.translation,
    this.meaning,
    this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return DevotionalCard(
      gradient: LinearGradient(
        begin: Alignment.topLeft,
        end: Alignment.bottomRight,
        colors: [
          AppColors.accent.withOpacity(0.1),
          AppColors.primary.withOpacity(0.05),
        ],
      ),
      showGlow: true,
      glowColor: AppColors.accent,
      onTap: onTap,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Container(
                padding: const EdgeInsets.all(8.0),
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  gradient: LinearGradient(
                    colors: [
                      AppColors.accent,
                      AppColors.accent.withOpacity(0.7),
                    ],
                  ),
                ),
                child: const Icon(
                  Icons.auto_awesome,
                  color: Colors.white,
                  size: 20,
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  'Daily Mantra',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: AppColors.primary,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          
          // Mantra text
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(8),
              color: AppColors.primary.withOpacity(0.05),
            ),
            child: Text(
              mantra,
              style: theme.textTheme.titleMedium?.copyWith(
                fontFamily: 'Sanskrit',
                fontSize: 18,
                height: 1.6,
                color: AppColors.textPrimary,
              ),
              textAlign: TextAlign.center,
            ),
          ),
          
          const SizedBox(height: 12),
          
          // Translation
          Text(
            translation,
            style: theme.textTheme.bodyMedium?.copyWith(
              fontStyle: FontStyle.italic,
              color: AppColors.textSecondary,
            ),
          ),
          
          // Meaning (if provided)
          if (meaning != null) ...[
            const SizedBox(height: 8),
            Text(
              meaning!,
              style: theme.textTheme.bodySmall?.copyWith(
                color: AppColors.textSecondary.withOpacity(0.8),
              ),
            ),
          ],
        ],
      ),
    );
  }
}

/// Card for displaying Ayyappa photos with elegant styling
class PhotoCard extends StatelessWidget {
  final String imageUrl;
  final String? title;
  final String? subtitle;
  final VoidCallback? onTap;
  final double aspectRatio;

  const PhotoCard({
    Key? key,
    required this.imageUrl,
    this.title,
    this.subtitle,
    this.onTap,
    this.aspectRatio = 1.0,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return DevotionalCard(
      padding: EdgeInsets.zero,
      onTap: onTap,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Image container
          Expanded(
            child: Container(
              decoration: BoxDecoration(
                borderRadius: const BorderRadius.vertical(
                  top: Radius.circular(16),
                ),
                image: DecorationImage(
                  image: AssetImage(imageUrl),
                  fit: BoxFit.cover,
                ),
              ),
            ),
          ),
          
          // Text content (if provided)
          if (title != null || subtitle != null)
            Padding(
              padding: const EdgeInsets.all(12),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (title != null)
                    Text(
                      title!,
                      style: theme.textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: AppColors.textPrimary,
                      ),
                    ),
                  if (subtitle != null) ...[
                    const SizedBox(height: 4),
                    Text(
                      subtitle!,
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: AppColors.textSecondary,
                      ),
                    ),
                  ],
                ],
              ),
            ),
        ],
      ),
    );
  }
}

/// Quick action card for shortcuts
class QuickActionCard extends StatelessWidget {
  final IconData icon;
  final String title;
  final String? subtitle;
  final VoidCallback onTap;
  final Color? iconColor;
  final Gradient? gradient;

  const QuickActionCard({
    Key? key,
    required this.icon,
    required this.title,
    this.subtitle,
    required this.onTap,
    this.iconColor,
    this.gradient,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return DevotionalCard(
      onTap: onTap,
      gradient: gradient,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: (iconColor ?? AppColors.accent).withOpacity(0.1),
            ),
            child: Icon(
              icon,
              size: 32,
              color: iconColor ?? AppColors.accent,
            ),
          ),
          const SizedBox(height: 12),
          Text(
            title,
            style: theme.textTheme.titleSmall?.copyWith(
              fontWeight: FontWeight.bold,
              color: AppColors.textPrimary,
            ),
            textAlign: TextAlign.center,
          ),
          if (subtitle != null) ...[
            const SizedBox(height: 4),
            Text(
              subtitle!,
              style: theme.textTheme.bodySmall?.copyWith(
                color: AppColors.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ],
      ),
    );
  }
}
//widgets/common/gradient_background.dart
import 'package:flutter/material.dart';
import '../../utils/constants.dart';

/// Custom gradient background widget with sacred patterns
class GradientBackground extends StatelessWidget {
  final Widget child;
  final String type;
  final double opacity;
  final bool hasPattern;

  const GradientBackground({
    Key? key,
    required this.child,
    this.type = 'primary',
    this.opacity = 1.0,
    this.hasPattern = false,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    
    return Container(
      decoration: BoxDecoration(
        gradient: _getGradient(type, isDark),
      ),
      child: hasPattern
          ? Stack(
              children: [
                _buildSacredPattern(context),
                child,
              ],
            )
          : child,
    );
  }

  /// Get gradient based on type and theme
  LinearGradient _getGradient(String type, bool isDark) {
    switch (type) {
      case 'primary':
        return LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: isDark
              ? [
                  AppColors.primaryOrange.withOpacity(0.2),
                  AppColors.primaryGold.withOpacity(0.1),
                  AppColors.deepPurple.withOpacity(0.3),
                ]
              : [
                  AppColors.primaryOrange.withOpacity(0.1),
                  AppColors.primaryGold.withOpacity(0.05),
                  Colors.white.withOpacity(0.8),
                ],
        );

      case 'secondary':
        return LinearGradient(
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
          colors: isDark
              ? [
                  AppColors.deepPurple.withOpacity(0.3),
                  AppColors.primaryOrange.withOpacity(0.1),
                ]
              : [
                  AppColors.lightSaffron.withOpacity(0.3),
                  Colors.white.withOpacity(0.9),
                ],
        );

      case 'devotional':
        return LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: isDark
              ? [
                  AppColors.primaryGold.withOpacity(0.2),
                  AppColors.deepPurple.withOpacity(0.4),
                  AppColors.primaryOrange.withOpacity(0.1),
                ]
              : [
                  AppColors.primaryGold.withOpacity(0.1),
                  AppColors.lightSaffron.withOpacity(0.2),
                  Colors.white.withOpacity(0.9),
                ],
        );

      case 'song':
        return LinearGradient(
          begin: Alignment.topRight,
          end: Alignment.bottomLeft,
          colors: isDark
              ? [
                  AppColors.deepPurple.withOpacity(0.4),
                  AppColors.primaryOrange.withOpacity(0.2),
                ]
              : [
                  AppColors.lightSaffron.withOpacity(0.2),
                  AppColors.primaryGold.withOpacity(0.1),
                ],
        );

      case 'library':
        return LinearGradient(
          begin: Alignment.centerLeft,
          end: Alignment.centerRight,
          colors: isDark
              ? [
                  AppColors.primaryOrange.withOpacity(0.1),
                  AppColors.deepPurple.withOpacity(0.2),
                  AppColors.primaryGold.withOpacity(0.1),
                ]
              : [
                  Colors.white.withOpacity(0.95),
                  AppColors.lightSaffron.withOpacity(0.1),
                  Colors.white.withOpacity(0.95),
                ],
        );

      case 'profile':
        return LinearGradient(
          begin: Alignment.bottomLeft,
          end: Alignment.topRight,
          colors: isDark
              ? [
                  AppColors.deepPurple.withOpacity(0.3),
                  AppColors.primaryGold.withOpacity(0.2),
                ]
              : [
                  AppColors.primaryGold.withOpacity(0.05),
                  AppColors.lightSaffron.withOpacity(0.15),
                ],
        );

      default:
        return LinearGradient(
          colors: isDark
              ? [
                  AppColors.deepPurple.withOpacity(0.2),
                  AppColors.primaryOrange.withOpacity(0.1),
                ]
              : [
                  Colors.white.withOpacity(0.9),
                  AppColors.lightSaffron.withOpacity(0.1),
                ],
        );
    }
  }

  /// Build sacred geometric pattern overlay
  Widget _buildSacredPattern(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    
    return Positioned.fill(
      child: Opacity(
        opacity: isDark ? 0.05 : 0.03,
        child: CustomPaint(
          painter: SacredPatternPainter(
            color: isDark ? AppColors.primaryGold : AppColors.primaryOrange,
          ),
        ),
      ),
    );
  }
}

/// Custom painter for sacred geometric patterns
class SacredPatternPainter extends CustomPainter {
  final Color color;

  SacredPatternPainter({required this.color});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 1.0
      ..style = PaintingStyle.stroke;

    // Draw lotus petals pattern
    _drawLotusPattern(canvas, size, paint);
    
    // Draw sacred geometry
    _drawSacredGeometry(canvas, size, paint);
  }

  void _drawLotusPattern(Canvas canvas, Size size, Paint paint) {
    final center = Offset(size.width / 2, size.height / 2);
    final petalCount = 8;
    final radius = size.width * 0.3;

    for (int i = 0; i < petalCount; i++) {
      final angle = (i * 2 * 3.14159) / petalCount;
      final petalCenter = Offset(
        center.dx + radius * 0.6 * (angle / 6.28).cos(),
        center.dy + radius * 0.6 * (angle / 6.28).sin(),
      );

      // Draw petal shape
      final path = Path();
      path.moveTo(center.dx, center.dy);
      path.quadraticBezierTo(
        petalCenter.dx,
        petalCenter.dy - radius * 0.3,
        petalCenter.dx + radius * 0.2,
        petalCenter.dy,
      );
      path.quadraticBezierTo(
        petalCenter.dx,
        petalCenter.dy + radius * 0.3,
        center.dx,
        center.dy,
      );

      canvas.drawPath(path, paint);
    }
  }

  void _drawSacredGeometry(Canvas canvas, Size size, Paint paint) {
    final step = size.width / 10;
    
    // Draw grid pattern
    for (double x = 0; x <= size.width; x += step) {
      canvas.drawLine(
        Offset(x, 0),
        Offset(x, size.height),
        paint..strokeWidth = 0.5,
      );
    }
    
    for (double y = 0; y <= size.height; y += step) {
      canvas.drawLine(
        Offset(0, y),
        Offset(size.width, y),
        paint..strokeWidth = 0.5,
      );
    }

    // Draw connecting circles at intersections
    for (double x = step; x < size.width; x += step * 2) {
      for (double y = step; y < size.height; y += step * 2) {
        canvas.drawCircle(
          Offset(x, y),
          2.0,
          paint..style = PaintingStyle.fill,
        );
      }
    }
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => false;
}

/// Animated gradient background for special occasions
class AnimatedGradientBackground extends StatefulWidget {
  final Widget child;
  final List<Color> colors;
  final Duration duration;

  const AnimatedGradientBackground({
    Key? key,
    required this.child,
    required this.colors,
    this.duration = const Duration(seconds: 3),
  }) : super(key: key);

  @override
  State<AnimatedGradientBackground> createState() =>
      _AnimatedGradientBackgroundState();
}

class _AnimatedGradientBackgroundState extends State<AnimatedGradientBackground>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: widget.duration,
      vsync: this,
    )..repeat(reverse: true);

    _animation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        return Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: widget.colors.map((color) {
                return Color.lerp(
                  color,
                  color.withOpacity(0.5),
                  _animation.value,
                )!;
              }).toList(),
            ),
          ),
          child: widget.child,
        );
      },
    );
  }
}

/// Glass morphism background effect
class GlassMorphismBackground extends StatelessWidget {
  final Widget child;
  final double blur;
  final double opacity;
  final Color? color;

  const GlassMorphismBackground({
    Key? key,
    required this.child,
    this.blur = 10.0,
    this.opacity = 0.1,
    this.color,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final effectiveColor = color ??
        (isDark ? AppColors.primaryGold : AppColors.primaryOrange);

    return Container(
      decoration: BoxDecoration(
        color: effectiveColor.withOpacity(opacity),
        borderRadius: BorderRadius.circular(AppSizes.borderRadius),
        border: Border.all(
          color: effectiveColor.withOpacity(0.2),
          width: 1.0,
        ),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(AppSizes.borderRadius),
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: blur, sigmaY: blur),
          child: Container(
            decoration: BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                colors: [
                  effectiveColor.withOpacity(0.1),
                  effectiveColor.withOpacity(0.05),
                ],
              ),
            ),
            child: child,
          ),
        ),
      ),
    );
  }
}

/// Extension for quick access to common gradient backgrounds
extension GradientBackgroundExtension on Widget {
  Widget withGradientBackground({
    String type = 'primary',
    bool hasPattern = false,
  }) {
    return GradientBackground(
      type: type,
      hasPattern: hasPattern,
      child: this,
    );
  }

  Widget withGlassMorphism({
    double blur = 10.0,
    double opacity = 0.1,
    Color? color,
  }) {
    return GlassMorphismBackground(
      blur: blur,
      opacity: opacity,
      color: color,
      child: this,
    );
  }
}
//widgets/common/language_selector.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/language_provider.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';

/// Multi-language selector dropdown with native script support
class LanguageSelector extends StatelessWidget {
  final bool showLabel;
  final bool isCompact;
  final VoidCallback? onLanguageChanged;

  const LanguageSelector({
    Key? key,
    this.showLabel = true,
    this.isCompact = false,
    this.onLanguageChanged,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Consumer<LanguageProvider>(
      builder: (context, languageProvider, child) {
        if (isCompact) {
          return _buildCompactSelector(context, languageProvider);
        }
        return _buildFullSelector(context, languageProvider);
      },
    );
  }

  Widget _buildFullSelector(BuildContext context, LanguageProvider provider) {
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppSizes.paddingMedium,
        vertical: AppSizes.paddingSmall,
      ),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(AppSizes.borderRadius),
        border: Border.all(
          color: AppColors.primaryOrange.withOpacity(0.3),
          width: 1.0,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          if (showLabel)
            Padding(
              padding: const EdgeInsets.only(bottom: AppSizes.paddingSmall),
              child: Text(
                'Language / à¤­à¤¾à¤·à¤¾ / à®®à¯Šà®´à®¿ / à°­à°¾à°·',
                style: AppTextStyles.bodyMedium.copyWith(
                  color: AppColors.primaryOrange,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          DropdownButtonHideUnderline(
            child: DropdownButton<String>(
              value: provider.currentLanguage,
              isDense: true,
              isExpanded: true,
              icon: Icon(
                Icons.keyboard_arrow_down,
                color: AppColors.primaryOrange,
              ),
              items: _buildLanguageItems(context),
              onChanged: (String? newLanguage) {
                if (newLanguage != null) {
                  provider.setLanguage(newLanguage);
                  onLanguageChanged?.call();
                }
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCompactSelector(BuildContext context, LanguageProvider provider) {
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppSizes.paddingSmall,
        vertical: AppSizes.paddingXSmall,
      ),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor.withOpacity(0.8),
        borderRadius: BorderRadius.circular(AppSizes.borderRadiusSmall),
        border: Border.all(
          color: AppColors.primaryOrange.withOpacity(0.3),
          width: 1.0,
        ),
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: provider.currentLanguage,
          isDense: true,
          icon: Icon(
            Icons.language,
            size: 16,
            color: AppColors.primaryOrange,
          ),
          items: _buildCompactLanguageItems(context),
          onChanged: (String? newLanguage) {
            if (newLanguage != null) {
              provider.setLanguage(newLanguage);
              onLanguageChanged?.call();
            }
          },
        ),
      ),
    );
  }

  List<DropdownMenuItem<String>> _buildLanguageItems(BuildContext context) {
    final languages = [
      {
        'code': 'ta',
        'name': 'Tamil',
        'nativeName': 'à®¤à®®à®¿à®´à¯',
        'flag': 'ðŸ‡®ðŸ‡³',
        'description': 'Tamil (Native Script)',
      },
      {
        'code': 'te',
        'name': 'Telugu',
        'nativeName': 'à°¤à±†à°²à±à°—à±',
        'flag': 'ðŸ‡®ðŸ‡³',
        'description': 'Telugu (Native Script)',
      },
      {
        'code': 'en-ta',
        'name': 'English Phonetic Tamil',
        'nativeName': 'Tamil Phonetic',
        'flag': 'ðŸ‡¬ðŸ‡§',
        'description': 'Tamil pronunciation in English',
      },
      {
        'code': 'en-te',
        'name': 'English Phonetic Telugu',
        'nativeName': 'Telugu Phonetic',
        'flag': 'ðŸ‡¬ðŸ‡§',
        'description': 'Telugu pronunciation in English',
      },
    ];

    return languages.map((language) {
      return DropdownMenuItem<String>(
        value: language['code'],
        child: _buildLanguageItem(
          context,
          language['flag']!,
          language['name']!,
          language['nativeName']!,
          language['description']!,
        ),
      );
    }).toList();
  }

  List<DropdownMenuItem<String>> _buildCompactLanguageItems(BuildContext context) {
    final languages = [
      {'code': 'ta', 'name': 'à®¤à®®à®¿à®´à¯'},
      {'code': 'te', 'name': 'à°¤à±†à°²à±à°—à±'},
      {'code': 'en-ta', 'name': 'TA-EN'},
      {'code': 'en-te', 'name': 'TE-EN'},
    ];

    return languages.map((language) {
      return DropdownMenuItem<String>(
        value: language['code'],
        child: Text(
          language['name']!,
          style: AppTextStyles.bodySmall,
        ),
      );
    }).toList();
  }

  Widget _buildLanguageItem(
    BuildContext context,
    String flag,
    String name,
    String nativeName,
    String description,
  ) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: AppSizes.paddingSmall),
      child: Row(
        children: [
          // Flag emoji
          Text(
            flag,
            style: const TextStyle(fontSize: 20),
          ),
          const SizedBox(width: AppSizes.paddingMedium),
          
          // Language info
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                // Main language name
                Text(
                  name,
                  style: AppTextStyles.bodyMedium.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                
                // Native script name
                Text(
                  nativeName,
                  style: AppTextStyles.bodySmall.copyWith(
                    color: AppColors.primaryOrange,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                
                // Description
                Text(
                  description,
                  style: AppTextStyles.bodySmall.copyWith(
                    color: Theme.of(context).textTheme.bodySmall?.color,
                    fontSize: 11,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

/// Language toggle buttons for quick switching
class LanguageToggleButtons extends StatelessWidget {
  final List<String> supportedLanguages;
  final bool showLabels;

  const LanguageToggleButtons({
    Key? key,
    this.supportedLanguages = const ['ta', 'te', 'en-ta', 'en-te'],
    this.showLabels = true,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Consumer<LanguageProvider>(
      builder: (context, languageProvider, child) {
        return Container(
          decoration: BoxDecoration(
            color: Theme.of(context).cardColor,
            borderRadius: BorderRadius.circular(AppSizes.borderRadius),
            border: Border.all(
              color: AppColors.primaryOrange.withOpacity(0.3),
              width: 1.0,
            ),
          ),
          child: SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: supportedLanguages.map((language) {
                final isSelected = languageProvider.currentLanguage == language;
                return _buildToggleButton(
                  context,
                  language,
                  isSelected,
                  languageProvider,
                );
              }).toList(),
            ),
          ),
        );
      },
    );
  }

  Widget _buildToggleButton(
    BuildContext context,
    String languageCode,
    bool isSelected,
    LanguageProvider provider,
  ) {
    final languageInfo = _getLanguageInfo(languageCode);
    
    return GestureDetector(
      onTap: () => provider.setLanguage(languageCode),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        margin: const EdgeInsets.all(2),
        padding: const EdgeInsets.symmetric(
          horizontal: AppSizes.paddingMedium,
          vertical: AppSizes.paddingSmall,
        ),
        decoration: BoxDecoration(
          color: isSelected
              ? AppColors.primaryOrange
              : Colors.transparent,
          borderRadius: BorderRadius.circular(AppSizes.borderRadiusSmall),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Language flag/icon
            Text(
              languageInfo['flag']!,
              style: TextStyle(
                fontSize: isSelected ? 18 : 16,
              ),
            ),
            
            if (showLabels) ...[
              const SizedBox(height: 4),
              Text(
                languageInfo['shortName']!,
                style: AppTextStyles.bodySmall.copyWith(
                  color: isSelected
                      ? Colors.white
                      : Theme.of(context).textTheme.bodyMedium?.color,
                  fontWeight: isSelected
                      ? FontWeight.w600
                      : FontWeight.w500,
                  fontSize: 10,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Map<String, String> _getLanguageInfo(String languageCode) {
    switch (languageCode) {
      case 'ta':
        return {
          'flag': 'ðŸ‡®ðŸ‡³',
          'shortName': 'à®¤à®®à®¿à®´à¯',
          'fullName': 'Tamil',
        };
      case 'te':
        return {
          'flag': 'ðŸ‡®ðŸ‡³',
          'shortName': 'à°¤à±†à°²à±à°—à±',
          'fullName': 'Telugu',
        };
      case 'en-ta':
        return {
          'flag': 'ðŸ‡¬ðŸ‡§',
          'shortName': 'TA-EN',
          'fullName': 'Tamil Phonetic',
        };
      case 'en-te':
        return {
          'flag': 'ðŸ‡¬ðŸ‡§',
          'shortName': 'TE-EN',
          'fullName': 'Telugu Phonetic',
        };
      default:
        return {
          'flag': 'ðŸŒ',
          'shortName': 'EN',
          'fullName': 'English',
        };
    }
  }
}

/// Floating language selector for overlay usage
class FloatingLanguageSelector extends StatefulWidget {
  final VoidCallback? onLanguageChanged;

  const FloatingLanguageSelector({
    Key? key,
    this.onLanguageChanged,
  }) : super(key: key);

  @override
  State<FloatingLanguageSelector> createState() =>
      _FloatingLanguageSelectorState();
}

class _FloatingLanguageSelectorState extends State<FloatingLanguageSelector>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;
  bool _isExpanded = false;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _scaleAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.elasticOut,
    );
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  void _toggleExpansion() {
    setState(() {
      _isExpanded = !_isExpanded;
      if (_isExpanded) {
        _animationController.forward();
      } else {
        _animationController.reverse();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<LanguageProvider>(
      builder: (context, languageProvider, child) {
        return Stack(
          alignment: Alignment.bottomRight,
          children: [
            // Expanded language options
            if (_isExpanded)
              ScaleTransition(
                scale: _scaleAnimation,
                child: Container(
                  margin: const EdgeInsets.only(bottom: 70),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: ['ta', 'te', 'en-ta', 'en-te']
                        .map((lang) => _buildFloatingOption(
                              context,
                              lang,
                              languageProvider,
                            ))
                        .toList(),
                  ),
                ),
              ),

            // Main floating button
            FloatingActionButton(
              mini: true,
              backgroundColor: AppColors.primaryOrange,
              foregroundColor: Colors.white,
              onPressed: _toggleExpansion,
              child: Icon(
                _isExpanded ? Icons.close : Icons.language,
                size: 20,
              ),
            ),
          ],
        );
      },
    );
  }

  Widget _buildFloatingOption(
    BuildContext context,
    String languageCode,
    LanguageProvider provider,
  ) {
    final languageInfo = _getLanguageInfo(languageCode);
    final isSelected = provider.currentLanguage == languageCode;

    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      child: FloatingActionButton(
        mini: true,
        backgroundColor: isSelected
            ? AppColors.primaryGold
            : Theme.of(context).cardColor,
        foregroundColor: isSelected
            ? Colors.white
            : Theme.of(context).textTheme.bodyMedium?.color,
        onPressed: () {
          provider.setLanguage(languageCode);
          widget.onLanguageChanged?.call();
          _toggleExpansion();
        },
        child: Text(
          languageInfo['flag']!,
          style: const TextStyle(fontSize: 16),
        ),
      ),
    );
  }

  Map<String, String> _getLanguageInfo(String languageCode) {
    switch (languageCode) {
      case 'ta':
        return {'flag': 'ðŸ‡®ðŸ‡³', 'name': 'Tamil'};
      case 'te':
        return {'flag': 'ðŸ‡®ðŸ‡³', 'name': 'Telugu'};
      case 'en-ta':
        return {'flag': 'ðŸ‡¬ðŸ‡§', 'name': 'Tamil Phonetic'};
      case 'en-te':
        return {'flag': 'ðŸ‡¬ðŸ‡§', 'name': 'Telugu Phonetic'};
      default:
        return {'flag': 'ðŸŒ', 'name': 'English'};
    }
  }
}
//widgets/common/theme_toggle.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../providers/theme_provider.dart';
import '../../../utils/constants.dart';

/// Theme toggle widget with three modes: Light, Dark, and Sepia
class ThemeToggle extends StatelessWidget {
  final bool showLabels;
  final MainAxisAlignment alignment;

  const ThemeToggle({
    Key? key,
    this.showLabels = true,
    this.alignment = MainAxisAlignment.center,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Consumer<ThemeProvider>(
      builder: (context, themeProvider, child) {
        return Container(
          padding: const EdgeInsets.all(8.0),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(25),
            color: Theme.of(context).colorScheme.surface.withOpacity(0.1),
            border: Border.all(
              color: Theme.of(context).colorScheme.outline.withOpacity(0.2),
            ),
          ),
          child: Row(
            mainAxisAlignment: alignment,
            mainAxisSize: MainAxisSize.min,
            children: [
              _buildThemeButton(
                context: context,
                themeProvider: themeProvider,
                themeMode: AppThemeMode.light,
                icon: Icons.light_mode,
                label: 'Light',
              ),
              const SizedBox(width: 8),
              _buildThemeButton(
                context: context,
                themeProvider: themeProvider,
                themeMode: AppThemeMode.dark,
                icon: Icons.dark_mode,
                label: 'Dark',
              ),
              const SizedBox(width: 8),
              _buildThemeButton(
                context: context,
                themeProvider: themeProvider,
                themeMode: AppThemeMode.sepia,
                icon: Icons.auto_stories,
                label: 'Sepia',
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildThemeButton({
    required BuildContext context,
    required ThemeProvider themeProvider,
    required AppThemeMode themeMode,
    required IconData icon,
    required String label,
  }) {
    final isSelected = themeProvider.currentTheme == themeMode;
    
    return AnimatedContainer(
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(20),
          onTap: () => themeProvider.setTheme(themeMode),
          child: Container(
            padding: EdgeInsets.symmetric(
              horizontal: showLabels ? 16 : 12,
              vertical: 8,
            ),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(20),
              color: isSelected
                  ? _getThemeColor(themeMode).withOpacity(0.2)
                  : Colors.transparent,
              border: isSelected
                  ? Border.all(
                      color: _getThemeColor(themeMode),
                      width: 2,
                    )
                  : null,
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                AnimatedContainer(
                  duration: const Duration(milliseconds: 300),
                  child: Icon(
                    icon,
                    size: 20,
                    color: isSelected
                        ? _getThemeColor(themeMode)
                        : Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
                  ),
                ),
                if (showLabels) ...[
                  const SizedBox(width: 8),
                  AnimatedDefaultTextStyle(
                    duration: const Duration(milliseconds: 300),
                    style: TextStyle(
                      fontSize: 12,
                      fontWeight: isSelected ? FontWeight.w600 : FontWeight.w400,
                      color: isSelected
                          ? _getThemeColor(themeMode)
                          : Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
                    ),
                    child: Text(label),
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }

  Color _getThemeColor(AppThemeMode themeMode) {
    switch (themeMode) {
      case AppThemeMode.light:
        return AppColors.primary;
      case AppThemeMode.dark:
        return AppColors.accent;
      case AppThemeMode.sepia:
        return const Color(0xFF8B4513); // Saddle brown
    }
  }
}

/// Compact theme toggle for app bars and small spaces
class CompactThemeToggle extends StatelessWidget {
  const CompactThemeToggle({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Consumer<ThemeProvider>(
      builder: (context, themeProvider, child) {
        return PopupMenuButton<AppThemeMode>(
          icon: Icon(
            _getCurrentThemeIcon(themeProvider.currentTheme),
            color: Theme.of(context).colorScheme.onSurface,
          ),
          tooltip: 'Change Theme',
          onSelected: (AppThemeMode theme) {
            themeProvider.setTheme(theme);
          },
          itemBuilder: (BuildContext context) => [
            _buildPopupMenuItem(
              context: context,
              themeMode: AppThemeMode.light,
              icon: Icons.light_mode,
              label: 'Light Theme',
              currentTheme: themeProvider.currentTheme,
            ),
            _buildPopupMenuItem(
              context: context,
              themeMode: AppThemeMode.dark,
              icon: Icons.dark_mode,
              label: 'Dark Theme',
              currentTheme: themeProvider.currentTheme,
            ),
            _buildPopupMenuItem(
              context: context,
              themeMode: AppThemeMode.sepia,
              icon: Icons.auto_stories,
              label: 'Sepia Theme',
              currentTheme: themeProvider.currentTheme,
            ),
          ],
        );
      },
    );
  }

  PopupMenuItem<AppThemeMode> _buildPopupMenuItem({
    required BuildContext context,
    required AppThemeMode themeMode,
    required IconData icon,
    required String label,
    required AppThemeMode currentTheme,
  }) {
    final isSelected = currentTheme == themeMode;
    
    return PopupMenuItem<AppThemeMode>(
      value: themeMode,
      child: Row(
        children: [
          Icon(
            icon,
            size: 20,
            color: isSelected
                ? Theme.of(context).colorScheme.primary
                : Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
          ),
          const SizedBox(width: 12),
          Text(
            label,
            style: TextStyle(
              fontWeight: isSelected ? FontWeight.w600 : FontWeight.w400,
              color: isSelected
                  ? Theme.of(context).colorScheme.primary
                  : Theme.of(context).colorScheme.onSurface,
            ),
          ),
          if (isSelected) ...[
            const Spacer(),
            Icon(
              Icons.check,
              size: 16,
              color: Theme.of(context).colorScheme.primary,
            ),
          ],
        ],
      ),
    );
  }

  IconData _getCurrentThemeIcon(AppThemeMode themeMode) {
    switch (themeMode) {
      case AppThemeMode.light:
        return Icons.light_mode;
      case AppThemeMode.dark:
        return Icons.dark_mode;
      case AppThemeMode.sepia:
        return Icons.auto_stories;
    }
  }
}

/// Animated theme transition widget
class ThemeTransition extends StatelessWidget {
  final Widget child;
  final Duration duration;

  const ThemeTransition({
    Key? key,
    required this.child,
    this.duration = const Duration(milliseconds: 300),
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Consumer<ThemeProvider>(
      builder: (context, themeProvider, _) {
        return AnimatedTheme(
          duration: duration,
          data: Theme.of(context),
          child: child,
        );
      },
    );
  }
}
//widgets/home/daily_mantra_card.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../providers/language_provider.dart';
import '../../../providers/favorites_provider.dart';
import '../../../models/devotional_content.dart';
import '../../../utils/constants.dart';
import '../../../utils/text_styles.dart';
import '../common/gradient_background.dart';

/// Daily mantra card widget with elegant design and multilingual support
class DailyMantraCard extends StatefulWidget {
  final DevotionalContent mantra;
  final VoidCallback? onTap;

  const DailyMantraCard({
    Key? key,
    required this.mantra,
    this.onTap,
  }) : super(key: key);

  @override
  State<DailyMantraCard> createState() => _DailyMantraCardState();
}

class _DailyMantraCardState extends State<DailyMantraCard>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 0.8,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.elasticOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    ));

    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animationController,
      builder: (context, child) {
        return Transform.scale(
          scale: _scaleAnimation.value,
          child: Opacity(
            opacity: _opacityAnimation.value,
            child: _buildCard(context),
          ),
        );
      },
    );
  }

  Widget _buildCard(BuildContext context) {
    return Consumer2<LanguageProvider, FavoritesProvider>(
      builder: (context, languageProvider, favoritesProvider, child) {
        final currentLanguage = languageProvider.currentLanguage;
        final content = _getLocalizedContent(currentLanguage);
        final isFavorite = favoritesProvider.isFavoriteContent(widget.mantra.id);

        return Container(
          margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: Material(
            elevation: 8,
            borderRadius: BorderRadius.circular(20),
            shadowColor: AppColors.primary.withOpacity(0.3),
            child: Container(
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(20),
                gradient: _buildGradient(),
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(20),
                child: Stack(
                  children: [
                    _buildBackgroundPattern(),
                    _buildContent(context, content, isFavorite, favoritesProvider),
                    _buildShimmerEffect(),
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  LinearGradient _buildGradient() {
    return const LinearGradient(
      begin: Alignment.topLeft,
      end: Alignment.bottomRight,
      colors: [
        Color(0xFFFF9933), // Saffron
        Color(0xFFFFB347), // Light orange
        Color(0xFFFFD700), // Gold
      ],
      stops: [0.0, 0.5, 1.0],
    );
  }

  Widget _buildBackgroundPattern() {
    return Positioned.fill(
      child: CustomPaint(
        painter: SacredPatternPainter(),
      ),
    );
  }

  Widget _buildShimmerEffect() {
    return Positioned.fill(
      child: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(20),
          gradient: LinearGradient(
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            colors: [
              Colors.white.withOpacity(0.1),
              Colors.transparent,
              Colors.white.withOpacity(0.05),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildContent(
    BuildContext context,
    Map<String, String> content,
    bool isFavorite,
    FavoritesProvider favoritesProvider,
  ) {
    return InkWell(
      borderRadius: BorderRadius.circular(20),
      onTap: widget.onTap,
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildHeader(context, isFavorite, favoritesProvider),
            const SizedBox(height: 16),
            _buildMantraText(context, content),
            const SizedBox(height: 16),
            _buildFooter(context),
          ],
        ),
      ),
    );
  }

  Widget _buildHeader(
    BuildContext context,
    bool isFavorite,
    FavoritesProvider favoritesProvider,
  ) {
    return Row(
      children: [
        Container(
          padding: const EdgeInsets.all(8),
          decoration: BoxDecoration(
            color: Colors.white.withOpacity(0.2),
            borderRadius: BorderRadius.circular(12),
          ),
          child: const Icon(
            Icons.auto_awesome,
            color: Colors.white,
            size: 24,
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Daily Mantra',
                style: AppTextStyles.heading3.copyWith(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                ),
              ),
              Text(
                _formatDate(DateTime.now()),
                style: AppTextStyles.caption.copyWith(
                  color: Colors.white.withOpacity(0.8),
                ),
              ),
            ],
          ),
        ),
        IconButton(
          onPressed: () {
            if (isFavorite) {
              favoritesProvider.removeFromFavorites(widget.mantra.id, 'content');
            } else {
              favoritesProvider.addToFavorites(widget.mantra.id, 'content');
            }
          },
          icon: AnimatedSwitcher(
            duration: const Duration(milliseconds: 300),
            child: Icon(
              isFavorite ? Icons.favorite : Icons.favorite_border,
              key: ValueKey(isFavorite),
              color: Colors.white,
              size: 24,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildMantraText(BuildContext context, Map<String, String> content) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.15),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Colors.white.withOpacity(0.2),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          if (content['title'] != null) ...[
            Text(
              content['title']!,
              style: AppTextStyles.heading4.copyWith(
                color: Colors.white,
                fontWeight: FontWeight.w600,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),
          ],
          Text(
            content['content'] ?? '',
            style: AppTextStyles.body1.copyWith(
              color: Colors.white,
              fontSize: 16,
              height: 1.5,
            ),
            textAlign: TextAlign.center,
          ),
          if (content['meaning'] != null) ...[
            const SizedBox(height: 12),
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: Colors.white.withOpacity(0.1),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Text(
                content['meaning']!,
                style: AppTextStyles.caption.copyWith(
                  color: Colors.white.withOpacity(0.9),
                  fontStyle: FontStyle.italic,
                ),
                textAlign: TextAlign.center,
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildFooter(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Row(
          children: [
            Icon(
              Icons.schedule,
              size: 16,
              color: Colors.white.withOpacity(0.8),
            ),
            const SizedBox(width: 4),
            Text(
              'Morning blessing',
              style: AppTextStyles.caption.copyWith(
                color: Colors.white.withOpacity(0.8),
              ),
            ),
          ],
        ),
        Row(
          children: [
            Icon(
              Icons.share,
              size: 16,
              color: Colors.white.withOpacity(0.8),
            ),
            const SizedBox(width: 8),
            Icon(
              Icons.bookmark_border,
              size: 16,
              color: Colors.white.withOpacity(0.8),
            ),
          ],
        ),
      ],
    );
  }

  Map<String, String> _getLocalizedContent(Language language) {
    switch (language) {
      case Language.tamil:
        return {
          'title': widget.mantra.titleTamil ?? widget.mantra.title,
          'content': widget.mantra.contentTamil ?? widget.mantra.content,
          'meaning': widget.mantra.meaningTamil,
        };
      case Language.telugu:
        return {
          'title': widget.mantra.titleTelugu ?? widget.mantra.title,
          'content': widget.mantra.contentTelugu ?? widget.mantra.content,
          'meaning': widget.mantra.meaningTelugu,
        };
      case Language.englishPhoneticTamil:
        return {
          'title': widget.mantra.titleEnglishPhoneticTamil ?? widget.mantra.title,
          'content': widget.mantra.contentEnglishPhoneticTamil ?? widget.mantra.content,
          'meaning': widget.mantra.meaningEnglishPhoneticTamil,
        };
      case Language.englishPhoneticTelugu:
        return {
          'title': widget.mantra.titleEnglishPhoneticTelugu ?? widget.mantra.title,
          'content': widget.mantra.contentEnglishPhoneticTelugu ?? widget.mantra.content,
          'meaning': widget.mantra.meaningEnglishPhoneticTelugu,
        };
    }
  }

  String _formatDate(DateTime date) {
    final months = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    
    return '${months[date.month - 1]} ${date.day}, ${date.year}';
  }
}

/// Custom painter for sacred geometric patterns
class SacredPatternPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.white.withOpacity(0.1)
      ..strokeWidth = 1
      ..style = PaintingStyle.stroke;

    // Draw sacred Om symbol pattern
    final center = Offset(size.width * 0.85, size.height * 0.2);
    final radius = 20.0;

    // Simple geometric pattern
    for (int i = 0; i < 6; i++) {
      final angle = (i * 60) * (3.14159 / 180);
      final start = Offset(
        center.dx + radius * 0.5 * Math.cos(angle),
        center.dy + radius * 0.5 * Math.sin(angle),
      );
      final end = Offset(
        center.dx + radius * Math.cos(angle),
        center.dy + radius * Math.sin(angle),
      );
      canvas.drawLine(start, end, paint);
    }

    // Draw subtle dots pattern
    final dotPaint = Paint()
      ..color = Colors.white.withOpacity(0.05)
      ..style = PaintingStyle.fill;

    for (int x = 0; x < size.width; x += 40) {
      for (int y = 0; y < size.height; y += 40) {
        canvas.drawCircle(Offset(x.toDouble(), y.toDouble()), 2, dotPaint);
      }
    }
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => false;
}

// Import for Math.cos and Math.sin
import 'dart:math' as Math;
//widgets/home/photo_gallery_grid.dart
import 'package:flutter/material.dart';
import 'package:flutter_staggered_grid_view/flutter_staggered_grid_view.dart';
import 'package:cached_network_image/cached_network_image.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';
import '../common/devotional_card.dart';

class PhotoGalleryGrid extends StatefulWidget {
  const PhotoGalleryGrid({super.key});

  @override
  State<PhotoGalleryGrid> createState() => _PhotoGalleryGridState();
}

class _PhotoGalleryGridState extends State<PhotoGalleryGrid>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;

  // Sample photo categories and data
  final List<PhotoCategory> _categories = [
    PhotoCategory(
      title: 'Sabarimala Temple',
      images: [
        'assets/images/ayyappa/temple_images/sabarimala_main.jpg',
        'assets/images/ayyappa/temple_images/sabarimala_steps.jpg',
        'assets/images/ayyappa/temple_images/sabarimala_sanctum.jpg',
      ],
      icon: Icons.temple_hindu,
      color: AppColors.primarySaffron,
    ),
    PhotoCategory(
      title: 'Lord Ayyappa',
      images: [
        'assets/images/ayyappa/deity_images/ayyappa_main.jpg',
        'assets/images/ayyappa/deity_images/ayyappa_meditation.jpg',
        'assets/images/ayyappa/deity_images/ayyappa_blessing.jpg',
      ],
      icon: Icons.auto_awesome,
      color: AppColors.secondaryGold,
    ),
    PhotoCategory(
      title: 'Festivals',
      images: [
        'assets/images/ayyappa/festival_images/makara_jyoti.jpg',
        'assets/images/ayyappa/festival_images/devotees_gathering.jpg',
        'assets/images/ayyappa/festival_images/procession.jpg',
      ],
      icon: Icons.celebration,
      color: AppColors.accentPurple,
    ),
    PhotoCategory(
      title: 'Devotional Moments',
      images: [
        'assets/images/ayyappa/deity_images/prayer_time.jpg',
        'assets/images/ayyappa/temple_images/evening_aarti.jpg',
        'assets/images/ayyappa/festival_images/bhajan_session.jpg',
      ],
      icon: Icons.favorite,
      color: AppColors.devotionalRed,
    ),
  ];

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 1200),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    ));
    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    
    return FadeTransition(
      opacity: _fadeAnimation,
      child: DevotionalCard(
        padding: const EdgeInsets.all(AppSizes.paddingMedium),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildHeader(context, isDark),
            const SizedBox(height: AppSizes.spacingMedium),
            _buildPhotoGrid(context),
            const SizedBox(height: AppSizes.spacingMedium),
            _buildViewAllButton(context),
          ],
        ),
      ),
    );
  }

  Widget _buildHeader(BuildContext context, bool isDark) {
    return Row(
      children: [
        Container(
          padding: const EdgeInsets.all(AppSizes.paddingSmall),
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                AppColors.primarySaffron.withOpacity(0.2),
                AppColors.secondaryGold.withOpacity(0.2),
              ],
            ),
            borderRadius: BorderRadius.circular(AppSizes.radiusSmall),
          ),
          child: Icon(
            Icons.photo_library,
            color: AppColors.primarySaffron,
            size: 20,
          ),
        ),
        const SizedBox(width: AppSizes.spacingSmall),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Sacred Gallery',
                style: AppTextStyles.headlineSmall.copyWith(
                  color: isDark ? AppColors.textLight : AppColors.textDark,
                  fontWeight: FontWeight.bold,
                ),
              ),
              Text(
                'Divine moments captured',
                style: AppTextStyles.bodyMedium.copyWith(
                  color: (isDark ? AppColors.textLight : AppColors.textDark)
                      .withOpacity(0.7),
                ),
              ),
            ],
          ),
        ),
        IconButton(
          onPressed: () => _showCategoryFilter(context),
          icon: Icon(
            Icons.filter_list,
            color: AppColors.primarySaffron,
          ),
        ),
      ],
    );
  }

  Widget _buildPhotoGrid(BuildContext context) {
    return SizedBox(
      height: 280,
      child: MasonryGridView.count(
        crossAxisCount: 2,
        mainAxisSpacing: AppSizes.spacingSmall,
        crossAxisSpacing: AppSizes.spacingSmall,
        physics: const BouncingScrollPhysics(),
        itemCount: _getDisplayImages().length,
        itemBuilder: (context, index) {
          final item = _getDisplayImages()[index];
          return _buildPhotoItem(context, item, index);
        },
      ),
    );
  }

  Widget _buildPhotoItem(BuildContext context, PhotoItem item, int index) {
    return AnimatedBuilder(
      animation: _animationController,
      builder: (context, child) {
        final slideAnimation = Tween<Offset>(
          begin: const Offset(0, 0.5),
          end: Offset.zero,
        ).animate(CurvedAnimation(
          parent: _animationController,
          curve: Interval(
            index * 0.1,
            (index * 0.1) + 0.6,
            curve: Curves.easeOutCubic,
          ),
        ));

        return SlideTransition(
          position: slideAnimation,
          child: GestureDetector(
            onTap: () => _openPhotoViewer(context, item),
            child: Hero(
              tag: 'photo_${item.imagePath}_$index',
              child: Container(
                height: index.isEven ? 120 : 160,
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(AppSizes.radiusMedium),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.1),
                      blurRadius: 8,
                      offset: const Offset(0, 4),
                    ),
                  ],
                ),
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(AppSizes.radiusMedium),
                  child: Stack(
                    fit: StackFit.expand,
                    children: [
                      // Photo placeholder with gradient
                      Container(
                        decoration: BoxDecoration(
                          gradient: LinearGradient(
                            begin: Alignment.topLeft,
                            end: Alignment.bottomRight,
                            colors: [
                              item.category.color.withOpacity(0.3),
                              item.category.color.withOpacity(0.6),
                            ],
                          ),
                        ),
                        child: Icon(
                          item.category.icon,
                          size: 40,
                          color: Colors.white.withOpacity(0.5),
                        ),
                      ),
                      // Overlay with category info
                      Positioned(
                        bottom: 0,
                        left: 0,
                        right: 0,
                        child: Container(
                          padding: const EdgeInsets.all(AppSizes.paddingSmall),
                          decoration: BoxDecoration(
                            gradient: LinearGradient(
                              begin: Alignment.bottomCenter,
                              end: Alignment.topCenter,
                              colors: [
                                Colors.black.withOpacity(0.8),
                                Colors.transparent,
                              ],
                            ),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Text(
                                item.category.title,
                                style: AppTextStyles.labelSmall.copyWith(
                                  color: Colors.white,
                                  fontWeight: FontWeight.w600,
                                ),
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                              if (item.title.isNotEmpty)
                                Text(
                                  item.title,
                                  style: AppTextStyles.labelSmall.copyWith(
                                    color: Colors.white.withOpacity(0.8),
                                    fontSize: 10,
                                  ),
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                ),
                            ],
                          ),
                        ),
                      ),
                      // Ripple effect
                      Material(
                        color: Colors.transparent,
                        child: InkWell(
                          onTap: () => _openPhotoViewer(context, item),
                          borderRadius: BorderRadius.circular(AppSizes.radiusMedium),
                          splashColor: item.category.color.withOpacity(0.3),
                          highlightColor: item.category.color.withOpacity(0.1),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildViewAllButton(BuildContext context) {
    return Center(
      child: TextButton.icon(
        onPressed: () => _navigateToFullGallery(context),
        icon: Icon(
          Icons.photo_library_outlined,
          color: AppColors.primarySaffron,
          size: 18,
        ),
        label: Text(
          'View All Photos',
          style: AppTextStyles.labelLarge.copyWith(
            color: AppColors.primarySaffron,
            fontWeight: FontWeight.w600,
          ),
        ),
        style: TextButton.styleFrom(
          padding: const EdgeInsets.symmetric(
            horizontal: AppSizes.paddingMedium,
            vertical: AppSizes.paddingSmall,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppSizes.radiusLarge),
            side: BorderSide(
              color: AppColors.primarySaffron.withOpacity(0.3),
            ),
          ),
        ),
      ),
    );
  }

  List<PhotoItem> _getDisplayImages() {
    // Return a subset of images for the home page preview
    List<PhotoItem> items = [];
    for (var category in _categories) {
      for (int i = 0; i < category.images.length && i < 2; i++) {
        items.add(PhotoItem(
          imagePath: category.images[i],
          title: 'Sacred Moment ${i + 1}',
          category: category,
        ));
      }
    }
    return items.take(6).toList();
  }

  void _openPhotoViewer(BuildContext context, PhotoItem item) {
    Navigator.of(context).push(
      PageRouteBuilder(
        pageBuilder: (context, animation, _) {
          return FadeTransition(
            opacity: animation,
            child: PhotoViewerPage(item: item),
          );
        },
        transitionDuration: const Duration(milliseconds: 300),
      ),
    );
  }

  void _showCategoryFilter(BuildContext context) {
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      builder: (context) => Container(
        decoration: BoxDecoration(
          color: Theme.of(context).scaffoldBackgroundColor,
          borderRadius: const BorderRadius.vertical(
            top: Radius.circular(AppSizes.radiusLarge),
          ),
        ),
        padding: const EdgeInsets.all(AppSizes.paddingLarge),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: Colors.grey.withOpacity(0.3),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            const SizedBox(height: AppSizes.spacingLarge),
            Text(
              'Photo Categories',
              style: AppTextStyles.headlineSmall.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: AppSizes.spacingLarge),
            ...(_categories.map((category) => ListTile(
              leading: Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: category.color.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(
                  category.icon,
                  color: category.color,
                ),
              ),
              title: Text(category.title),
              subtitle: Text('${category.images.length} photos'),
              trailing: Icon(
                Icons.arrow_forward_ios,
                size: 16,
                color: Colors.grey,
              ),
              onTap: () {
                Navigator.pop(context);
                // Navigate to category-specific gallery
              },
            ))),
          ],
        ),
      ),
    );
  }

  void _navigateToFullGallery(BuildContext context) {
    // Navigate to the Library page's photo gallery section
    Navigator.of(context).pushNamed('/library', arguments: {'tab': 'photos'});
  }
}

// Data models for photo gallery
class PhotoCategory {
  final String title;
  final List<String> images;
  final IconData icon;
  final Color color;

  PhotoCategory({
    required this.title,
    required this.images,
    required this.icon,
    required this.color,
  });
}

class PhotoItem {
  final String imagePath;
  final String title;
  final PhotoCategory category;

  PhotoItem({
    required this.imagePath,
    required this.title,
    required this.category,
  });
}

// Simple photo viewer page
class PhotoViewerPage extends StatelessWidget {
  final PhotoItem item;

  const PhotoViewerPage({super.key, required this.item});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.close, color: Colors.white),
          onPressed: () => Navigator.pop(context),
        ),
        title: Text(
          item.title,
          style: const TextStyle(color: Colors.white),
        ),
      ),
      body: Center(
        child: Hero(
          tag: 'photo_${item.imagePath}',
          child: InteractiveViewer(
            child: Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                  colors: [
                    item.category.color.withOpacity(0.3),
                    item.category.color.withOpacity(0.6),
                  ],
                ),
              ),
              child: Center(
                child: Icon(
                  item.category.icon,
                  size: 100,
                  color: Colors.white.withOpacity(0.8),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
//widgets/home/quote_of_day_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/language_provider.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';
import '../common/devotional_card.dart';

class QuoteOfDay extends StatefulWidget {
  const QuoteOfDay({Key? key}) : super(key: key);

  @override
  State<QuoteOfDay> createState() => _QuoteOfDayState();
}

class _QuoteOfDayState extends State<QuoteOfDay>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _setupAnimations();
  }

  void _setupAnimations() {
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );

    _fadeAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: const Interval(0.0, 0.8, curve: Curves.easeOut),
    ));

    _scaleAnimation = Tween<double>(
      begin: 0.8,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: const Interval(0.2, 1.0, curve: Curves.elasticOut),
    ));

    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  Map<String, Map<String, String>> _getQuotesData() {
    return {
      'en': {
        'quote': 'Surrender your ego, embrace divine love, and find peace in Lord Ayyappa\'s eternal blessing.',
        'author': 'Ayyappa Devotional Wisdom',
        'translation': '',
      },
      'ta': {
        'quote': 'à®‰à®™à¯à®•à®³à¯ à®…à®•à®™à¯à®•à®¾à®°à®¤à¯à®¤à¯ˆ à®µà®¿à®Ÿà¯à®Ÿà¯à®µà®¿à®Ÿà¯à®™à¯à®•à®³à¯, à®¤à¯†à®¯à¯à®µà¯€à®• à®…à®©à¯à®ªà¯ˆ à®à®±à¯à®±à¯à®•à¯à®•à¯Šà®³à¯à®³à¯à®™à¯à®•à®³à¯, à®…à®¯à¯à®¯à®ªà¯à®ªà®©à¯ à®¨à®¿à®¤à¯à®¤à®¿à®¯ à®†à®šà¯€à®°à¯à®µà®¾à®¤à®¤à¯à®¤à®¿à®²à¯ à®…à®®à¯ˆà®¤à®¿ à®•à®¾à®£à¯à®™à¯à®•à®³à¯.',
        'author': 'à®…à®¯à¯à®¯à®ªà¯à®ª à®ªà®•à¯à®¤à®¿ à®žà®¾à®©à®®à¯',
        'translation': 'Surrender your ego, embrace divine love, and find peace in Lord Ayyappa\'s eternal blessing.',
      },
      'te': {
        'quote': 'à°®à±€ à°…à°¹à°‚à°•à°¾à°°à°¾à°¨à±à°¨à°¿ à°µà°¦à°¿à°²à°¿à°ªà±†à°Ÿà±à°Ÿà°‚à°¡à°¿, à°¦à±ˆà°µà°¿à°• à°ªà±à°°à±‡à°®à°¨à± à°¸à±à°µà±€à°•à°°à°¿à°‚à°šà°‚à°¡à°¿, à°…à°¯à±à°¯à°ªà±à°ª à°¶à°¾à°¶à±à°µà°¤ à°†à°¶à±€à°°à±à°µà°¾à°¦à°‚à°²à±‹ à°¶à°¾à°‚à°¤à°¿à°¨à°¿ à°ªà±Šà°‚à°¦à°‚à°¡à°¿.',
        'author': 'à°…à°¯à±à°¯à°ªà±à°ª à°­à°•à±à°¤à°¿ à°œà±à°žà°¾à°¨à°‚',
        'translation': 'Surrender your ego, embrace divine love, and find peace in Lord Ayyappa\'s eternal blessing.',
      },
      'ta_en': {
        'quote': 'Ungal ahankaarathai vittuvitungal, theiviga anbaiye yetrukollungal, Ayyappan nithiya aaseervadhathil amaithi kaanungal.',
        'author': 'Ayyappa Bhakthi Gnanam',
        'translation': 'Surrender your ego, embrace divine love, and find peace in Lord Ayyappa\'s eternal blessing.',
      },
    };
  }

  Widget _buildQuoteIcon() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            AppColors.saffron.withOpacity(0.2),
            AppColors.gold.withOpacity(0.2),
          ],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
          color: AppColors.saffron.withOpacity(0.3),
          width: 1,
        ),
      ),
      child: Icon(
        Icons.format_quote,
        size: 32,
        color: AppColors.saffron,
      ),
    );
  }

  Widget _buildQuoteContent(Map<String, String> quoteData) {
    final showTranslation = quoteData['translation']?.isNotEmpty == true;
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Main quote
        Text(
          quoteData['quote'] ?? '',
          style: AppTextStyles.body.copyWith(
            fontSize: 16,
            fontStyle: FontStyle.italic,
            height: 1.6,
            color: Theme.of(context).textTheme.bodyLarge?.color,
          ),
          textAlign: TextAlign.center,
        ),
        
        if (showTranslation) ...[
          const SizedBox(height: 12),
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.surface.withOpacity(0.5),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(
                color: Theme.of(context).dividerColor.withOpacity(0.3),
              ),
            ),
            child: Text(
              quoteData['translation'] ?? '',
              style: AppTextStyles.caption.copyWith(
                fontSize: 13,
                fontStyle: FontStyle.italic,
                color: Theme.of(context).textTheme.bodyMedium?.color?.withOpacity(0.8),
              ),
              textAlign: TextAlign.center,
            ),
          ),
        ],
        
        const SizedBox(height: 16),
        
        // Author attribution
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Container(
              height: 1,
              width: 30,
              color: AppColors.saffron.withOpacity(0.5),
            ),
            const SizedBox(width: 12),
            Text(
              'â€” ${quoteData['author'] ?? ''} â€”',
              style: AppTextStyles.caption.copyWith(
                fontSize: 12,
                fontWeight: FontWeight.w500,
                color: AppColors.saffron,
                letterSpacing: 0.5,
              ),
            ),
            const SizedBox(width: 12),
            Container(
              height: 1,
              width: 30,
              color: AppColors.saffron.withOpacity(0.5),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildQuoteHeader() {
    return Row(
      children: [
        _buildQuoteIcon(),
        const SizedBox(width: 16),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Quote of the Day',
                style: AppTextStyles.subtitle.copyWith(
                  color: AppColors.saffron,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                'Divine wisdom for today',
                style: AppTextStyles.caption.copyWith(
                  color: Theme.of(context).textTheme.bodyMedium?.color?.withOpacity(0.7),
                ),
              ),
            ],
          ),
        ),
        // Refresh button
        GestureDetector(
          onTap: () {
            _animationController.reset();
            _animationController.forward();
            // In a real app, this would fetch a new quote
          },
          child: Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: AppColors.saffron.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Icon(
              Icons.refresh,
              size: 20,
              color: AppColors.saffron,
            ),
          ),
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<LanguageProvider>(
      builder: (context, languageProvider, child) {
        final quotesData = _getQuotesData();
        final currentQuote = quotesData[languageProvider.currentLanguage] ??
            quotesData['en']!;

        return AnimatedBuilder(
          animation: _animationController,
          builder: (context, child) {
            return Transform.scale(
              scale: _scaleAnimation.value,
              child: FadeTransition(
                opacity: _fadeAnimation,
                child: DevotionalCard(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      _buildQuoteHeader(),
                      const SizedBox(height: 20),
                      _buildQuoteContent(currentQuote),
                    ],
                  ),
                ),
              ),
            );
          },
        );
      },
    );
  }
}
//widgets/home/songs_carousel_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:carousel_slider/carousel_slider.dart';
import '../../models/song_model.dart';
import '../../providers/language_provider.dart';
import '../../providers/favorites_provider.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';
import '../../utils/mock_data.dart';
import '../../pages/song_view_page.dart';
import '../common/devotional_card.dart';

class SongsCarousel extends StatefulWidget {
  const SongsCarousel({Key? key}) : super(key: key);

  @override
  State<SongsCarousel> createState() => _SongsCarouselState();
}

class _SongsCarouselState extends State<SongsCarousel>
    with TickerProviderStateMixin {
  late AnimationController _slideController;
  late Animation<Offset> _slideAnimation;
  final CarouselSliderController _carouselController =
      CarouselSliderController();
  int _currentIndex = 0;

  @override
  void initState() {
    super.initState();
    _setupAnimations();
  }

  void _setupAnimations() {
    _slideController = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );

    _slideAnimation = Tween<Offset>(
      begin: const Offset(0, 1),
      end: Offset.zero,
    ).animate(CurvedAnimation(
      parent: _slideController,
      curve: Curves.easeOutCubic,
    ));

    _slideController.forward();
  }

  @override
  void dispose() {
    _slideController.dispose();
    super.dispose();
  }

  void _onSongTap(Song song) {
    Navigator.push(
      context,
      PageRouteBuilder(
        pageBuilder: (context, animation, secondaryAnimation) =>
            SongViewPage(song: song),
        transitionsBuilder: (context, animation, secondaryAnimation, child) {
          return SlideTransition(
            position: Tween<Offset>(
              begin: const Offset(1.0, 0.0),
              end: Offset.zero,
            ).animate(CurvedAnimation(
              parent: animation,
              curve: Curves.easeInOut,
            )),
            child: child,
          );
        },
        transitionDuration: const Duration(milliseconds: 300),
      ),
    );
  }

  Widget _buildSongCard(Song song, bool isActive) {
    return Consumer2<LanguageProvider, FavoritesProvider>(
      builder: (context, languageProvider, favoritesProvider, child) {
        final isFavorite = favoritesProvider.isFavorite(song.id);
        
        return GestureDetector(
          onTap: () => _onSongTap(song),
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 300),
            curve: Curves.easeInOut,
            margin: EdgeInsets.symmetric(
              horizontal: 8,
              vertical: isActive ? 0 : 12,
            ),
            child: DevotionalCard(
              elevation: isActive ? 8 : 4,
              child: Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(16),
                  gradient: isActive
                      ? LinearGradient(
                          colors: [
                            AppColors.saffron.withOpacity(0.1),
                            AppColors.gold.withOpacity(0.1),
                          ],
                          begin: Alignment.topLeft,
                          end: Alignment.bottomRight,
                        )
                      : null,
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Header with icon and favorite button
                    Row(
                      children: [
                        Container(
                          padding: const EdgeInsets.all(12),
                          decoration: BoxDecoration(
                            gradient: LinearGradient(
                              colors: [
                                AppColors.saffron.withOpacity(0.8),
                                AppColors.gold.withOpacity(0.8),
                              ],
                            ),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Icon(
                            song.iconType == 'music' ? Icons.music_note : Icons.temple_hindu,
                            color: Colors.white,
                            size: 20,
                          ),
                        ),
                        const Spacer(),
                        GestureDetector(
                          onTap: () {
                            if (isFavorite) {
                              favoritesProvider.removeFavorite(song.id);
                            } else {
                              favoritesProvider.addFavorite(song.id);
                            }
                          },
                          child: AnimatedContainer(
                            duration: const Duration(milliseconds: 200),
                            padding: const EdgeInsets.all(8),
                            decoration: BoxDecoration(
                              color: isFavorite
                                  ? AppColors.saffron.withOpacity(0.2)
                                  : Colors.transparent,
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Icon(
                              isFavorite ? Icons.favorite : Icons.favorite_border,
                              color: isFavorite ? AppColors.saffron : Colors.grey,
                              size: 20,
                            ),
                          ),
                        ),
                      ],
                    ),
                    
                    const SizedBox(height: 16),
                    
                    // Song title
                    Text(
                      song.title,
                      style: AppTextStyles.subtitle.copyWith(
                        fontWeight: FontWeight.w600,
                        color: isActive ? AppColors.saffron : null,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    
                    const SizedBox(height: 8),
                    
                    // Singer and writer info
                    if (song.singer.isNotEmpty) ...[
                      Row(
                        children: [
                          Icon(
                            Icons.person,
                            size: 14,
                            color: Theme.of(context).textTheme.bodyMedium?.color?.withOpacity(0.6),
                          ),
                          const SizedBox(width: 6),
                          Expanded(
                            child: Text(
                              song.singer,
                              style: AppTextStyles.caption.copyWith(
                                color: Theme.of(context).textTheme.bodyMedium?.color?.withOpacity(0.7),
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 4),
                    ],
                    
                    if (song.writer.isNotEmpty) ...[
                      Row(
                        children: [
                          Icon(
                            Icons.edit,
                            size: 14,
                            color: Theme.of(context).textTheme.bodyMedium?.color?.withOpacity(0.6),
                          ),
                          const SizedBox(width: 6),
                          Expanded(
                            child: Text(
                              song.writer,
                              style: AppTextStyles.caption.copyWith(
                                color: Theme.of(context).textTheme.bodyMedium?.color?.withOpacity(0.7),
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                    ],
                    
                    // Language indicator
                    Row(
                      children: [
                        Container(
                          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: AppColors.saffron.withOpacity(0.1),
                            borderRadius: BorderRadius.circular(12),
                            border: Border.all(
                              color: AppColors.saffron.withOpacity(0.3),
                            ),
                          ),
                          child: Text(
                            languageProvider.getLanguageDisplayName(),
                            style: AppTextStyles.caption.copyWith(
                              color: AppColors.saffron,
                              fontWeight: FontWeight.w500,
                              fontSize: 10,
                            ),
                          ),
                        ),
                        const Spacer(),
                        // Play button
                        Container(
                          padding: const EdgeInsets.all(6),
                          decoration: BoxDecoration(
                            color: AppColors.saffron.withOpacity(0.1),
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Icon(
                            Icons.play_arrow,
                            color: AppColors.saffron,
                            size: 16,
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildCarouselIndicators() {
    final songs = MockData.songs;
    
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: songs.asMap().entries.map((entry) {
        final index = entry.key;
        final isActive = index == _currentIndex;
        
        return AnimatedContainer(
          duration: const Duration(milliseconds: 300),
          margin: const EdgeInsets.symmetric(horizontal: 4),
          height: 6,
          width: isActive ? 20 : 6,
          decoration: BoxDecoration(
            color: isActive ? AppColors.saffron : AppColors.saffron.withOpacity(0.3),
            borderRadius: BorderRadius.circular(3),
          ),
        );
      }).toList(),
    );
  }

  Widget _buildSectionHeader() {
    return Row(
      children: [
        Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                AppColors.saffron.withOpacity(0.2),
                AppColors.gold.withOpacity(0.2),
              ],
            ),
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: AppColors.saffron.withOpacity(0.3),
            ),
          ),
          child: Icon(
            Icons.queue_music,
            color: AppColors.saffron,
            size: 24,
          ),
        ),
        const SizedBox(width: 16),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Popular Songs',
                style: AppTextStyles.heading.copyWith(
                  color: AppColors.saffron,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                'Sacred melodies for devotion',
                style: AppTextStyles.caption.copyWith(
                  color: Theme.of(context).textTheme.bodyMedium?.color?.withOpacity(0.7),
                ),
              ),
            ],
          ),
        ),
        GestureDetector(
          onTap: () {
            // Navigate to songs page
            DefaultTabController.of(context)?.animateTo(1);
          },
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            decoration: BoxDecoration(
              color: AppColors.saffron.withOpacity(0.1),
              borderRadius: BorderRadius.circular(20),
              border: Border.all(
                color: AppColors.saffron.withOpacity(0.3),
              ),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  'View All',
                  style: AppTextStyles.caption.copyWith(
                    color: AppColors.saffron,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(width: 4),
                Icon(
                  Icons.arrow_forward_ios,
                  size: 12,
                  color: AppColors.saffron,
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    final songs = MockData.songs;
    
    return SlideTransition(
      position: _slideAnimation,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 20),
            child: _buildSectionHeader(),
          ),
          
          const SizedBox(height: 20),
          
          CarouselSlider(
            carouselController: _carouselController,
            options: CarouselOptions(
              height: 220,
              aspectRatio: 16 / 9,
              viewportFraction: 0.85,
              initialPage: 0,
              enableInfiniteScroll: songs.length > 1,
              reverse: false,
              autoPlay: true,
              autoPlayInterval: const Duration(seconds: 5),
              autoPlayAnimationDuration: const Duration(milliseconds: 800),
              autoPlayCurve: Curves.fastOutSlowIn,
              enlargeCenterPage: true,
              enlargeFactor: 0.2,
              scrollDirection: Axis.horizontal,
              onPageChanged: (index, reason) {
                setState(() {
                  _currentIndex = index;
                });
              },
            ),
            items: songs.map((song) {
              final index = songs.indexOf(song);
              final isActive = index == _currentIndex;
              return _buildSongCard(song, isActive);
            }).toList(),
          ),
          
          const SizedBox(height: 16),
          
          if (songs.length > 1) _buildCarouselIndicators(),
        ],
      ),
    );
  }
}
//widgets/home/weather_greeting_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/language_provider.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';

class WeatherGreeting extends StatefulWidget {
  const WeatherGreeting({Key? key}) : super(key: key);

  @override
  State<WeatherGreeting> createState() => _WeatherGreetingState();
}

class _WeatherGreetingState extends State<WeatherGreeting> {
  String _currentWeather = 'clear';
  double _temperature = 28.0;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadWeatherData();
  }

  Future<void> _loadWeatherData() async {
    // Simulate weather API call
    await Future.delayed(const Duration(seconds: 1));
    
    // Mock weather data - in real app, integrate with weather API
    final hour = DateTime.now().hour;
    setState(() {
      _temperature = 20.0 + (hour * 0.5); // Simple temperature simulation
      _currentWeather = _getWeatherByTime(hour);
      _isLoading = false;
    });
  }

  String _getWeatherByTime(int hour) {
    if (hour >= 6 && hour < 10) return 'morning';
    if (hour >= 10 && hour < 16) return 'sunny';
    if (hour >= 16 && hour < 19) return 'evening';
    if (hour >= 19 && hour < 22) return 'night';
    return 'clear';
  }

  @override
  Widget build(BuildContext context) {
    final languageProvider = Provider.of<LanguageProvider>(context);
    final isDark = Theme.of(context).brightness == Brightness.dark;

    if (_isLoading) {
      return _buildLoadingWidget(isDark);
    }

    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        gradient: _getWeatherGradient(),
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Row(
        children: [
          // Weather Icon
          Container(
            width: 60,
            height: 60,
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.2),
              borderRadius: BorderRadius.circular(30),
            ),
            child: Icon(
              _getWeatherIcon(),
              size: 32,
              color: Colors.white,
            ),
          ),
          const SizedBox(width: 16),
          
          // Weather Info
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  _getGreetingText(languageProvider.currentLanguage),
                  style: AppTextStyles.headingMedium.copyWith(
                    color: Colors.white,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  _getWeatherDescription(languageProvider.currentLanguage),
                  style: AppTextStyles.bodyMedium.copyWith(
                    color: Colors.white.withOpacity(0.9),
                  ),
                ),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Icon(
                      Icons.thermostat,
                      size: 16,
                      color: Colors.white.withOpacity(0.8),
                    ),
                    const SizedBox(width: 4),
                    Text(
                      '${_temperature.round()}Â°C',
                      style: AppTextStyles.bodySmall.copyWith(
                        color: Colors.white.withOpacity(0.8),
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
          
          // Devotional Time Indicator
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.2),
              borderRadius: BorderRadius.circular(20),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  _getDevotionalIcon(),
                  size: 16,
                  color: Colors.white,
                ),
                const SizedBox(width: 4),
                Text(
                  _getDevotionalTime(languageProvider.currentLanguage),
                  style: AppTextStyles.bodySmall.copyWith(
                    color: Colors.white,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildLoadingWidget(bool isDark) {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: isDark ? AppColors.cardDark : AppColors.cardLight,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Row(
        children: [
          Container(
            width: 60,
            height: 60,
            decoration: BoxDecoration(
              color: Colors.grey.withOpacity(0.3),
              borderRadius: BorderRadius.circular(30),
            ),
            child: const Center(
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(AppColors.primaryOrange),
              ),
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Container(
                  height: 20,
                  width: 150,
                  decoration: BoxDecoration(
                    color: Colors.grey.withOpacity(0.3),
                    borderRadius: BorderRadius.circular(10),
                  ),
                ),
                const SizedBox(height: 8),
                Container(
                  height: 16,
                  width: 100,
                  decoration: BoxDecoration(
                    color: Colors.grey.withOpacity(0.3),
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  LinearGradient _getWeatherGradient() {
    switch (_currentWeather) {
      case 'morning':
        return const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFFFF9500), // Orange
            Color(0xFFFFB947), // Light Orange
          ],
        );
      case 'sunny':
        return const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFFFFD700), // Gold
            Color(0xFFFFA500), // Orange
          ],
        );
      case 'evening':
        return const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFFFF6B35), // Sunset Orange
            Color(0xFFD2691E), // Chocolate
          ],
        );
      case 'night':
        return const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFF191970), // Midnight Blue
            Color(0xFF483D8B), // Dark Slate Blue
          ],
        );
      default:
        return const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            AppColors.primaryOrange,
            AppColors.accentGold,
          ],
        );
    }
  }

  IconData _getWeatherIcon() {
    switch (_currentWeather) {
      case 'morning':
        return Icons.wb_sunny;
      case 'sunny':
        return Icons.wb_sunny;
      case 'evening':
        return Icons.wb_twilight;
      case 'night':
        return Icons.nightlight;
      default:
        return Icons.wb_sunny;
    }
  }

  IconData _getDevotionalIcon() {
    final hour = DateTime.now().hour;
    if (hour >= 5 && hour < 7) return Icons.self_improvement; // Morning prayer
    if (hour >= 12 && hour < 14) return Icons.lunch_dining; // Lunch prayer
    if (hour >= 18 && hour < 20) return Icons.lightbulb; // Evening prayer
    return Icons.star; // General devotional time
  }

  String _getGreetingText(String language) {
    final hour = DateTime.now().hour;
    
    switch (language) {
      case 'ta':
        if (hour >= 5 && hour < 12) return 'à®•à®¾à®²à¯ˆ à®µà®£à®•à¯à®•à®®à¯';
        if (hour >= 12 && hour < 17) return 'à®®à®¤à®¿à®¯ à®µà®£à®•à¯à®•à®®à¯';
        if (hour >= 17 && hour < 21) return 'à®®à®¾à®²à¯ˆ à®µà®£à®•à¯à®•à®®à¯';
        return 'à®‡à®°à®µà¯ à®µà®£à®•à¯à®•à®®à¯';
      
      case 'te':
        if (hour >= 5 && hour < 12) return 'à°¶à±à°­à±‹à°¦à°¯à°‚';
        if (hour >= 12 && hour < 17) return 'à°¶à±à°­ à°®à°§à±à°¯à°¾à°¹à±à°¨à°‚';
        if (hour >= 17 && hour < 21) return 'à°¶à±à°­ à°¸à°¾à°¯à°‚à°¤à±à°°à°‚';
        return 'à°¶à±à°­ à°°à°¾à°¤à±à°°à°¿';
      
      default:
        if (hour >= 5 && hour < 12) return 'Good Morning';
        if (hour >= 12 && hour < 17) return 'Good Afternoon';
        if (hour >= 17 && hour < 21) return 'Good Evening';
        return 'Good Night';
    }
  }

  String _getWeatherDescription(String language) {
    switch (language) {
      case 'ta':
        switch (_currentWeather) {
          case 'morning':
            return 'à®…à®¯à¯à®¯à®ªà¯à®ªà®©à¯ à®†à®šà¯€à®°à¯à®µà®¾à®¤à®¤à¯à®¤à¯à®Ÿà®©à¯ à®¨à®²à¯à®² à®•à®¾à®²à¯ˆ';
          case 'sunny':
            return 'à®šà¯‚à®°à®¿à®¯ à®’à®³à®¿à®¯à®¿à®²à¯ à®ªà®¿à®°à®•à®¾à®šà®¿à®•à¯à®•à¯à®®à¯ à®¨à®¾à®³à¯';
          case 'evening':
            return 'à®…à®®à¯ˆà®¤à®¿à®¯à®¾à®© à®®à®¾à®²à¯ˆ à®µà¯‡à®³à¯ˆ';
          case 'night':
            return 'à®…à®¯à¯à®¯à®ªà¯à®ªà®©à¯ à®ªà®¾à®¤à¯à®•à®¾à®ªà¯à®ªà®¿à®²à¯ à®‡à®°à®µà¯';
          default:
            return 'à®…à®¯à¯à®¯à®ªà¯à®ªà®©à¯ à®¤à¯à®£à¯ˆà®¯à¯à®Ÿà®©à¯';
        }
      
      case 'te':
        switch (_currentWeather) {
          case 'morning':
            return 'à°…à°¯à±à°¯à°ªà±à°ª à°¦à±€à°µà±†à°¨à°²à°¤à±‹ à°¶à±à°­à±‹à°¦à°¯à°‚';
          case 'sunny':
            return 'à°¸à±‚à°°à±à°¯ à°•à°¿à°°à°£à°¾à°²à°¤à±‹ à°ªà±à°°à°•à°¾à°¶à°µà°‚à°¤à°®à±ˆà°¨ à°°à±‹à°œà±';
          case 'evening':
            return 'à°ªà±à°°à°¶à°¾à°‚à°¤à°®à±ˆà°¨ à°¸à°¾à°¯à°‚à°¤à±à°°à°‚';
          case 'night':
            return 'à°…à°¯à±à°¯à°ªà±à°ª à°°à°•à±à°·à°£à°²à±‹ à°°à°¾à°¤à±à°°à°¿';
          default:
            return 'à°…à°¯à±à°¯à°ªà±à°ª à°¦à±€à°µà±†à°¨à°²à°¤à±‹';
        }
      
      default:
        switch (_currentWeather) {
          case 'morning':
            return 'Blessed morning with Ayyappa\'s grace';
          case 'sunny':
            return 'Bright day under divine light';
          case 'evening':
            return 'Peaceful evening devotion time';
          case 'night':
            return 'Protected night under Ayyappa\'s care';
          default:
            return 'With Ayyappa\'s blessings';
        }
    }
  }

  String _getDevotionalTime(String language) {
    final hour = DateTime.now().hour;
    
    switch (language) {
      case 'ta':
        if (hour >= 5 && hour < 7) return 'à®•à®¾à®²à¯ˆ à®ªà¯‚à®œà¯ˆ';
        if (hour >= 12 && hour < 14) return 'à®®à®¤à®¿à®¯ à®ªà¯‚à®œà¯ˆ';
        if (hour >= 18 && hour < 20) return 'à®®à®¾à®²à¯ˆ à®ªà¯‚à®œà¯ˆ';
        return 'à®ªà®•à¯à®¤à®¿ à®¨à¯‡à®°à®®à¯';
      
      case 'te':
        if (hour >= 5 && hour < 7) return 'à°ªà±à°°à°¾à°¤à°ƒ à°ªà±‚à°œ';
        if (hour >= 12 && hour < 14) return 'à°®à°§à±à°¯à°¾à°¹à±à°¨ à°ªà±‚à°œ';
        if (hour >= 18 && hour < 20) return 'à°¸à°¾à°¯à°‚à°¤à±à°°à°‚ à°ªà±‚à°œ';
        return 'à°­à°•à±à°¤à°¿ à°¸à°®à°¯à°‚';
      
      default:
        if (hour >= 5 && hour < 7) return 'Morning Prayer';
        if (hour >= 12 && hour < 14) return 'Noon Prayer';
        if (hour >= 18 && hour < 20) return 'Evening Prayer';
        return 'Devotion Time';
    }
  }
}
//widgets/library/festival_calendar_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../models/festival_model.dart';
import '../../providers/language_provider.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';
import '../../utils/helpers.dart';
import '../common/devotional_card.dart';

class FestivalCalendar extends StatefulWidget {
  const FestivalCalendar({super.key});

  @override
  State<FestivalCalendar> createState() => _FestivalCalendarState();
}

class _FestivalCalendarState extends State<FestivalCalendar>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  String _selectedMonth = '';
  List<Festival> _festivals = [];
  
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
    _selectedMonth = _getCurrentMonth();
    _loadFestivals();
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  String _getCurrentMonth() {
    final now = DateTime.now();
    final months = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    return months[now.month - 1];
  }

  void _loadFestivals() {
    // Mock festival data - in real app, load from database/API
    _festivals = [
      Festival(
        id: '1',
        name: 'Makaravilakku',
        date: DateTime(2025, 1, 14),
        description: 'The divine light that appears at Sabarimala during Makara Sankranti',
        significance: 'Most auspicious day for Ayyappa devotees',
        rituals: ['Early morning darshan', 'Special prayers', 'Prasadam distribution'],
        location: 'Sabarimala Temple',
        type: FestivalType.major,
        isUpcoming: true,
      ),
      Festival(
        id: '2',
        name: 'Mandala Pooja',
        date: DateTime(2024, 12, 26),
        description: '41-day period of devotional observance',
        significance: 'Preparation period for Sabarimala pilgrimage',
        rituals: ['Daily prayers', 'Fasting', 'Wearing mala', 'Celibacy'],
        location: 'All Ayyappa temples',
        type: FestivalType.observance,
        isUpcoming: false,
      ),
      Festival(
        id: '3',
        name: 'Ayyappa Jayanti',
        date: DateTime(2025, 1, 8),
        description: 'Birthday celebration of Lord Ayyappa',
        significance: 'Commemorates the divine incarnation',
        rituals: ['Special abhishekam', 'Devotional songs', 'Community feast'],
        location: 'All Ayyappa temples',
        type: FestivalType.major,
        isUpcoming: true,
      ),
    ];
  }

  List<Festival> _getFilteredFestivals(FestivalFilter filter) {
    switch (filter) {
      case FestivalFilter.upcoming:
        return _festivals.where((f) => f.isUpcoming).toList();
      case FestivalFilter.thisMonth:
        final now = DateTime.now();
        return _festivals.where((f) => 
          f.date.month == now.month && f.date.year == now.year
        ).toList();
      case FestivalFilter.all:
      default:
        return _festivals;
    }
  }

  @override
  Widget build(BuildContext context) {
    final languageProvider = Provider.of<LanguageProvider>(context);
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildHeader(context),
        const SizedBox(height: 16),
        _buildTabBar(),
        const SizedBox(height: 16),
        _buildFestivalList(),
      ],
    );
  }

  Widget _buildHeader(BuildContext context) {
    return Row(
      children: [
        Icon(
          Icons.calendar_month,
          color: AppColors.primary,
          size: 24,
        ),
        const SizedBox(width: 12),
        Text(
          'Festival Calendar',
          style: AppTextStyles.headlineSmall.copyWith(
            color: Theme.of(context).colorScheme.onSurface,
            fontWeight: FontWeight.bold,
          ),
        ),
        const Spacer(),
        IconButton(
          onPressed: () => _showCalendarView(context),
          icon: Icon(
            Icons.calendar_view_month,
            color: AppColors.primary,
          ),
          tooltip: 'Calendar View',
        ),
      ],
    );
  }

  Widget _buildTabBar() {
    return Container(
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Theme.of(context).colorScheme.outline.withOpacity(0.2),
        ),
      ),
      child: TabBar(
        controller: _tabController,
        tabs: const [
          Tab(text: 'Upcoming'),
          Tab(text: 'This Month'),
          Tab(text: 'All'),
        ],
        labelColor: AppColors.primary,
        unselectedLabelColor: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
        indicator: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          color: AppColors.primary.withOpacity(0.1),
        ),
        dividerColor: Colors.transparent,
      ),
    );
  }

  Widget _buildFestivalList() {
    return Expanded(
      child: TabBarView(
        controller: _tabController,
        children: [
          _buildFestivalGrid(FestivalFilter.upcoming),
          _buildFestivalGrid(FestivalFilter.thisMonth),
          _buildFestivalGrid(FestivalFilter.all),
        ],
      ),
    );
  }

  Widget _buildFestivalGrid(FestivalFilter filter) {
    final festivals = _getFilteredFestivals(filter);
    
    if (festivals.isEmpty) {
      return _buildEmptyState(filter);
    }

    return ListView.builder(
      padding: const EdgeInsets.only(top: 8),
      itemCount: festivals.length,
      itemBuilder: (context, index) {
        return _buildFestivalCard(festivals[index]);
      },
    );
  }

  Widget _buildFestivalCard(Festival festival) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: DevotionalCard(
        child: InkWell(
          onTap: () => _showFestivalDetails(festival),
          borderRadius: BorderRadius.circular(16),
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 12,
                        vertical: 6,
                      ),
                      decoration: BoxDecoration(
                        color: _getFestivalTypeColor(festival.type),
                        borderRadius: BorderRadius.circular(20),
                      ),
                      child: Text(
                        _getFestivalTypeText(festival.type),
                        style: AppTextStyles.labelSmall.copyWith(
                          color: Colors.white,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                    const Spacer(),
                    if (festival.isUpcoming)
                      Container(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 8,
                          vertical: 4,
                        ),
                        decoration: BoxDecoration(
                          color: Colors.green.withOpacity(0.1),
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Text(
                          'Upcoming',
                          style: AppTextStyles.labelSmall.copyWith(
                            color: Colors.green,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      ),
                  ],
                ),
                const SizedBox(height: 12),
                Text(
                  festival.name,
                  style: AppTextStyles.titleMedium.copyWith(
                    color: Theme.of(context).colorScheme.onSurface,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  Helpers.formatDate(festival.date),
                  style: AppTextStyles.bodyMedium.copyWith(
                    color: AppColors.primary,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  festival.description,
                  style: AppTextStyles.bodyMedium.copyWith(
                    color: Theme.of(context).colorScheme.onSurface.withOpacity(0.7),
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 12),
                Row(
                  children: [
                    Icon(
                      Icons.location_on,
                      size: 16,
                      color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
                    ),
                    const SizedBox(width: 4),
                    Expanded(
                      child: Text(
                        festival.location,
                        style: AppTextStyles.bodySmall.copyWith(
                          color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
                        ),
                      ),
                    ),
                    const SizedBox(width: 8),
                    Text(
                      _getDaysUntil(festival.date),
                      style: AppTextStyles.bodySmall.copyWith(
                        color: AppColors.primary,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyState(FestivalFilter filter) {
    String message;
    IconData icon;
    
    switch (filter) {
      case FestivalFilter.upcoming:
        message = 'No upcoming festivals';
        icon = Icons.event_available;
        break;
      case FestivalFilter.thisMonth:
        message = 'No festivals this month';
        icon = Icons.calendar_month;
        break;
      case FestivalFilter.all:
      default:
        message = 'No festivals found';
        icon = Icons.event_busy;
        break;
    }

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            icon,
            size: 64,
            color: Theme.of(context).colorScheme.onSurface.withOpacity(0.3),
          ),
          const SizedBox(height: 16),
          Text(
            message,
            style: AppTextStyles.bodyLarge.copyWith(
              color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
            ),
          ),
        ],
      ),
    );
  }

  Color _getFestivalTypeColor(FestivalType type) {
    switch (type) {
      case FestivalType.major:
        return AppColors.primary;
      case FestivalType.minor:
        return Colors.blue;
      case FestivalType.observance:
        return Colors.orange;
      case FestivalType.regional:
        return Colors.green;
    }
  }

  String _getFestivalTypeText(FestivalType type) {
    switch (type) {
      case FestivalType.major:
        return 'Major';
      case FestivalType.minor:
        return 'Minor';
      case FestivalType.observance:
        return 'Observance';
      case FestivalType.regional:
        return 'Regional';
    }
  }

  String _getDaysUntil(DateTime date) {
    final now = DateTime.now();
    final difference = date.difference(now).inDays;
    
    if (difference < 0) {
      return 'Past';
    } else if (difference == 0) {
      return 'Today';
    } else if (difference == 1) {
      return 'Tomorrow';
    } else {
      return '$difference days';
    }
  }

  void _showFestivalDetails(Festival festival) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => _buildFestivalDetailsSheet(festival),
    );
  }

  Widget _buildFestivalDetailsSheet(Festival festival) {
    return DraggableScrollableSheet(
      initialChildSize: 0.7,
      maxChildSize: 0.95,
      minChildSize: 0.5,
      builder: (context, scrollController) {
        return Container(
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.surface,
            borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
          ),
          child: Column(
            children: [
              Container(
                margin: const EdgeInsets.symmetric(vertical: 8),
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.onSurface.withOpacity(0.3),
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              Expanded(
                child: SingleChildScrollView(
                  controller: scrollController,
                  padding: const EdgeInsets.all(24),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        festival.name,
                        style: AppTextStyles.headlineSmall.copyWith(
                          color: Theme.of(context).colorScheme.onSurface,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        Helpers.formatDate(festival.date),
                        style: AppTextStyles.titleMedium.copyWith(
                          color: AppColors.primary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 16),
                      _buildDetailSection('Description', festival.description),
                      const SizedBox(height: 16),
                      _buildDetailSection('Significance', festival.significance),
                      const SizedBox(height: 16),
                      _buildRitualsSection(festival.rituals),
                      const SizedBox(height: 16),
                      _buildLocationSection(festival.location),
                    ],
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildDetailSection(String title, String content) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: AppTextStyles.titleMedium.copyWith(
            color: Theme.of(context).colorScheme.onSurface,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 8),
        Text(
          content,
          style: AppTextStyles.bodyMedium.copyWith(
            color: Theme.of(context).colorScheme.onSurface.withOpacity(0.8),
            height: 1.5,
          ),
        ),
      ],
    );
  }

  Widget _buildRitualsSection(List<String> rituals) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Rituals & Observances',
          style: AppTextStyles.titleMedium.copyWith(
            color: Theme.of(context).colorScheme.onSurface,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 8),
        ...rituals.map((ritual) => Padding(
          padding: const EdgeInsets.only(bottom: 4),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                margin: const EdgeInsets.only(top: 6),
                width: 4,
                height: 4,
                decoration: BoxDecoration(
                  color: AppColors.primary,
                  shape: BoxShape.circle,
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  ritual,
                  style: AppTextStyles.bodyMedium.copyWith(
                    color: Theme.of(context).colorScheme.onSurface.withOpacity(0.8),
                  ),
                ),
              ),
            ],
          ),
        )),
      ],
    );
  }

  Widget _buildLocationSection(String location) {
    return Row(
      children: [
        Icon(
          Icons.location_on,
          color: AppColors.primary,
          size: 20,
        ),
        const SizedBox(width: 8),
        Expanded(
          child: Text(
            location,
            style: AppTextStyles.bodyMedium.copyWith(
              color: Theme.of(context).colorScheme.onSurface.withOpacity(0.8),
            ),
          ),
        ),
      ],
    );
  }

  void _showCalendarView(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Calendar View'),
        content: const Text('Full calendar view coming soon!'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }
}

enum FestivalFilter {
  upcoming,
  thisMonth,
  all,
}
//widgets/library/history_section.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../models/devotional_content.dart';
import '../../providers/language_provider.dart';
import '../../providers/theme_provider.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';
import '../common/devotional_card.dart';
import '../common/gradient_background.dart';

/// Widget for displaying Ayyappa Mahatmyam and historical content
class HistorySection extends StatefulWidget {
  const HistorySection({super.key});

  @override
  State<HistorySection> createState() => _HistorySectionState();
}

class _HistorySectionState extends State<HistorySection>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;
  int _expandedIndex = -1;

  // Sample historical content
  final List<HistoricalContent> _historicalContent = [
    HistoricalContent(
      id: 'birth_story',
      titleTamil: 'à®…à®¯à¯à®¯à®ªà¯à®ªà®©à¯ à®ªà®¿à®±à®ªà¯à®ªà¯ à®•à®¤à¯ˆ',
      titleTelugu: 'à°…à°¯à±à°¯à°ªà±à°ª à°œà°¨à±à°® à°•à°¥',
      titleEnglish: 'Birth Story of Lord Ayyappa',
      contentTamil: '''à®ªà®£à¯à®Ÿà¯ˆà®¯ à®•à®¾à®²à®¤à¯à®¤à®¿à®²à¯, à®šà®¿à®µà®©à¯ à®®à®±à¯à®±à¯à®®à¯ à®µà®¿à®·à¯à®£à¯ à®†à®•à®¿à®¯ à®‡à®°à¯ à®¤à¯†à®¯à¯à®µà®™à¯à®•à®³à¯à®®à¯ à®’à®©à¯à®±à®¿à®£à¯ˆà®¨à¯à®¤à¯, à®…à®¯à¯à®¯à®ªà¯à®ªà®©à¯ à®Žà®©à¯à®± à®…à®µà®¤à®¾à®°à®®à¯ à®Žà®Ÿà¯à®¤à¯à®¤à®©à®°à¯. à®‡à®¤à¯ à®®à¯‹à®•à®¿à®©à®¿ à®…à®µà®¤à®¾à®°à®¤à¯à®¤à®¿à®©à¯ à®®à¯‚à®²à®®à¯ à®¨à®Ÿà®¨à¯à®¤à®¤à¯.

à®ªà®¨à¯à®¤à®³ à®…à®°à®šà®°à¯ à®°à®¾à®œà®šà¯‡à®•à®°à®©à¯ à®•à®¾à®Ÿà¯à®Ÿà®¿à®²à¯ à®µà¯‡à®Ÿà¯à®Ÿà¯ˆà®¯à®¾à®Ÿà®¿à®•à¯ à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®¨à¯à®¤à®ªà¯‹à®¤à¯, à®’à®°à¯ à®•à¯à®´à®¨à¯à®¤à¯ˆ à®…à®´à¯à®µà®¤à¯ˆà®•à¯ à®•à¯‡à®Ÿà¯à®Ÿà®¾à®°à¯. à®…à®¨à¯à®¤à®•à¯ à®•à¯à®´à®¨à¯à®¤à¯ˆà®¯à¯ˆà®•à¯ à®•à®£à¯à®Ÿà¯†à®Ÿà¯à®¤à¯à®¤à¯, à®…à®µà®°à¯ à®¤à®©à®¤à¯ à®…à®°à®£à¯à®®à®©à¯ˆà®•à¯à®•à¯ à®…à®´à¯ˆà®¤à¯à®¤à¯à®šà¯ à®šà¯†à®©à¯à®±à®¾à®°à¯.

à®…à®¨à¯à®¤à®•à¯ à®•à¯à®´à®¨à¯à®¤à¯ˆà®¯à®¿à®©à¯ à®•à®´à¯à®¤à¯à®¤à®¿à®²à¯ à®’à®°à¯ à®¤à®™à¯à®• à®®à®¾à®²à¯ˆ à®‡à®°à¯à®¨à¯à®¤à®¤à¯, à®…à®¤à®¿à®²à¯ "à®®à®•à®°à®®à¯ à®µà®°à¯ˆ à®‡à®µà®©à¯ˆà®ªà¯ à®ªà®¾à®¤à¯à®•à®¾à®•à¯à®•à®µà¯à®®à¯" à®Žà®©à¯à®±à¯ à®Žà®´à¯à®¤à®¿à®¯à®¿à®°à¯à®¨à¯à®¤à®¤à¯. à®…à®¤à®©à®¾à®²à¯ à®…à®µà®°à¯ à®…à®¨à¯à®¤à®•à¯ à®•à¯à®´à®¨à¯à®¤à¯ˆà®¯à¯ˆ à®®à®•à®°à®®à¯ à®Žà®©à¯à®±à¯ à®ªà¯†à®¯à®°à®¿à®Ÿà¯à®Ÿà®¾à®°à¯.''',
      contentTelugu: '''à°ªà±à°°à°¾à°¤à°¨ à°•à°¾à°²à°‚à°²à±‹, à°¶à°¿à°µà±à°¡à± à°®à°°à°¿à°¯à± à°µà°¿à°·à±à°£à±à°µà± à°…à°¨à±‡ à°°à±†à°‚à°¡à± à°¦à±‡à°µà°¤à°²à± à°•à°²à°¿à°¸à°¿, à°…à°¯à±à°¯à°ªà±à°ª à°…à°¨à±‡ à°…à°µà°¤à°¾à°°à°¾à°¨à±à°¨à°¿ à°¤à±€à°¸à±à°•à±à°¨à±à°¨à°¾à°°à±. à°‡à°¦à°¿ à°®à±‹à°¹à°¿à°¨à°¿ à°…à°µà°¤à°¾à°°à°‚ à°¦à±à°µà°¾à°°à°¾ à°œà°°à°¿à°—à°¿à°‚à°¦à°¿.

à°ªà°‚à°¤à°³ à°°à°¾à°œà± à°°à°¾à°œà°¶à±‡à°–à°°à±à°¡à± à°…à°¡à°µà°¿à°²à±‹ à°µà±‡à°Ÿà°¾à°¡à±à°¤à±‚ à°‰à°‚à°¡à°—à°¾, à°’à°• à°ªà°¿à°²à±à°²à°µà°¾à°¡à± à°à°¡à±à°¸à±à°¤à±à°¨à±à°¨ à°¶à°¬à±à°¦à°‚ à°µà°¿à°¨à°¿à°ªà°¿à°‚à°šà°¿à°‚à°¦à°¿. à°† à°ªà°¿à°²à±à°²à°µà°¾à°¡à°¿à°¨à°¿ à°•à°¨à±à°—à±Šà°¨à°¿, à°…à°¤à°¨à± à°¤à°¨ à°°à°¾à°œà°­à°µà°¨à°¾à°¨à°¿à°•à°¿ à°¤à±€à°¸à±à°•à±†à°³à±à°³à°¾à°¡à±.

à°† à°ªà°¿à°²à±à°²à°µà°¾à°¡à°¿ à°®à±†à°¡à°²à±‹ à°’à°• à°¬à°‚à°—à°¾à°°à± à°®à°¾à°² à°‰à°‚à°¦à°¿, à°…à°‚à°¦à±à°²à±‹ "à°®à°•à°°à°‚ à°µà°°à°•à± à°¦à±€à°¨à°¿à°¨à°¿ à°°à°•à±à°·à°¿à°‚à°šà°‚à°¡à°¿" à°…à°¨à°¿ à°µà±à°°à°¾à°¯à°¬à°¡à°¿ à°‰à°‚à°¦à°¿. à°…à°‚à°¦à±à°•à±‡ à°…à°¤à°¨à± à°† à°ªà°¿à°²à±à°²à°µà°¾à°¡à°¿à°•à°¿ à°®à°•à°°à°‚ à°…à°¨à°¿ à°ªà±‡à°°à± à°ªà±†à°Ÿà±à°Ÿà°¾à°¡à±.''',
      contentEnglish: '''In ancient times, Lord Shiva and Lord Vishnu united to take the form of Ayyappa through the Mohini avatar.

King Rajasekhara of Pandalam was hunting in the forest when he heard a child crying. He found the child and brought him to his palace.

The child wore a golden chain around his neck with the inscription "Protect him until Makaram". Therefore, he named the child Makaram.''',
      iconData: Icons.child_care,
      category: 'Birth Story',
    ),
    HistoricalContent(
      id: 'puli_paal',
      titleTamil: 'à®ªà¯à®²à®¿à®ªà¯à®ªà®¾à®²à¯ à®•à®¤à¯ˆ',
      titleTelugu: 'à°ªà±à°²à°¿à°ªà°¾à°² à°•à°¥',
      titleEnglish: 'The Tiger\'s Milk Legend',
      contentTamil: '''à®…à®°à®šà®¿à®¯à®¿à®©à¯ à®¤à®²à¯ˆà®µà®²à®¿à®¯à¯ˆà®•à¯ à®•à¯à®£à®ªà¯à®ªà®Ÿà¯à®¤à¯à®¤ à®ªà¯à®²à®¿à®ªà¯à®ªà®¾à®²à¯ à®¤à¯‡à®µà¯ˆ à®Žà®©à¯à®±à¯ à®µà¯ˆà®¤à¯à®¤à®¿à®¯à®°à¯ à®•à¯‚à®±à®¿à®©à®¾à®°à¯. à®…à®¯à¯à®¯à®ªà¯à®ªà®©à¯ à®•à®¾à®Ÿà¯à®Ÿà¯à®•à¯à®•à¯à®šà¯ à®šà¯†à®©à¯à®±à¯ à®ªà¯à®²à®¿à®•à®³à¯ˆ à®…à®Ÿà®•à¯à®•à®¿, à®…à®µà®±à¯à®±à®¿à®©à¯ à®ªà®¾à®²à¯ˆà®•à¯ à®•à¯Šà®£à¯à®Ÿà¯ à®µà®¨à¯à®¤à®¾à®°à¯.

à®‰à®£à¯à®®à¯ˆà®¯à®¿à®²à¯ à®‡à®¤à¯ à®…à®¯à¯à®¯à®ªà¯à®ªà®©à®¿à®©à¯ à®¤à¯†à®¯à¯à®µà¯€à®• à®šà®•à¯à®¤à®¿à®¯à¯ˆ à®¨à®¿à®°à¯‚à®ªà®¿à®ªà¯à®ªà®¤à®±à¯à®•à®¾à®• à®¨à®Ÿà®¨à¯à®¤ à®’à®°à¯ à®šà¯‹à®¤à®©à¯ˆà®¯à®¾à®•à¯à®®à¯. à®…à®µà®°à¯ à®ªà¯à®²à®¿à®•à®³à¯ˆ à®…à®Ÿà®•à¯à®•à®¿, à®…à®µà®±à¯à®±à®¿à®©à¯ à®®à¯€à®¤à¯ à®…à®®à®°à¯à®¨à¯à®¤à¯ à®µà®¨à¯à®¤à®ªà¯‹à®¤à¯ à®…à®©à¯ˆà®µà®°à¯à®®à¯ à®…à®µà®°à®¤à¯ à®¤à¯†à®¯à¯à®µà¯€à®•à®¤à¯à®¤à¯ˆ à®‰à®£à®°à¯à®¨à¯à®¤à®©à®°à¯.

à®‡à®¨à¯à®¤ à®¨à®¿à®•à®´à¯à®µà¯à®•à¯à®•à¯à®ªà¯ à®ªà®¿à®±à®•à¯, à®…à®¯à¯à®¯à®ªà¯à®ªà®©à¯ à®¤à®©à®¤à¯ à®ªà¯‚à®®à®¿à®•à¯à®•à¯à®°à®¿à®¯ à®•à®Ÿà®®à¯ˆà®•à®³à¯ˆ à®®à¯à®Ÿà®¿à®¤à¯à®¤à¯à®µà®¿à®Ÿà¯à®Ÿà¯, à®šà®ªà®°à®¿à®®à®²à¯ˆà®•à¯à®•à¯à®šà¯ à®šà¯†à®©à¯à®±à®¾à®°à¯. à®…à®™à¯à®•à¯‡ à®…à®µà®°à¯ à®¤à®µà®®à¯ à®šà¯†à®¯à¯à®¯ à®†à®°à®®à¯à®ªà®¿à®¤à¯à®¤à®¾à®°à¯.''',
      contentTelugu: '''à°°à°¾à°£à°¿ à°¤à°²à°¨à±Šà°ªà±à°ªà°¿à°¨à°¿ à°¨à°¯à°‚ à°šà±‡à°¯à°¡à°¾à°¨à°¿à°•à°¿ à°ªà±à°²à°¿à°ªà°¾à°²à± à°…à°µà°¸à°°à°‚ à°…à°¨à°¿ à°µà±ˆà°¦à±à°¯à±à°¡à± à°šà±†à°ªà±à°ªà°¾à°¡à±. à°…à°¯à±à°¯à°ªà±à°ª à°…à°¡à°µà°¿à°•à°¿ à°µà±†à°³à±à°²à°¿ à°ªà±à°²à±à°²à°¨à± à°²à±Šà°‚à°—à°¦à±€à°¸à±à°•à±à°¨à°¿, à°µà°¾à°Ÿà°¿ à°ªà°¾à°²à± à°¤à±†à°šà±à°šà°¾à°¡à±.

à°µà°¾à°¸à±à°¤à°µà°¾à°¨à°¿à°•à°¿ à°‡à°¦à°¿ à°…à°¯à±à°¯à°ªà±à°ª à°¦à±ˆà°µà°¿à°• à°¶à°•à±à°¤à°¿à°¨à°¿ à°¨à°¿à°°à±‚à°ªà°¿à°‚à°šà°¡à°¾à°¨à°¿à°•à°¿ à°œà°°à°¿à°—à°¿à°¨ à°’à°• à°ªà°°à±€à°•à±à°·. à°…à°¤à°¨à± à°ªà±à°²à±à°²à°¨à± à°²à±Šà°‚à°—à°¦à±€à°¸à±à°•à±à°¨à°¿, à°µà°¾à°Ÿà°¿ à°®à±€à°¦ à°•à±‚à°°à±à°šà±Šà°¨à°¿ à°µà°šà±à°šà°¿à°¨à°ªà±à°ªà±à°¡à± à°…à°‚à°¦à°°à±‚ à°…à°¤à°¨à°¿ à°¦à±ˆà°µà°¤à±à°µà°¾à°¨à±à°¨à°¿ à°—à±à°°à°¹à°¿à°‚à°šà°¾à°°à±.

à°ˆ à°¸à°‚à°˜à°Ÿà°¨ à°¤à°°à±à°µà°¾à°¤, à°…à°¯à±à°¯à°ªà±à°ª à°¤à°¨ à°­à±‚à°²à±‹à°• à°•à°°à±à°¤à°µà±à°¯à°¾à°²à°¨à± à°ªà±‚à°°à±à°¤à°¿ à°šà±‡à°¸à±à°•à±à°¨à°¿, à°¶à°¬à°°à°¿à°®à°²à°•à± à°µà±†à°³à±à°³à°¾à°¡à±. à°…à°•à±à°•à°¡ à°…à°¤à°¨à± à°¤à°ªà°¸à±à°¸à± à°šà±‡à°¯à°¡à°‚ à°ªà±à°°à°¾à°°à°‚à°­à°¿à°‚à°šà°¾à°¡à±.''',
      contentEnglish: '''The physician said tiger\'s milk was needed to cure the queen\'s headache. Ayyappa went to the forest, tamed the tigers, and brought their milk.

In reality, this was a test to prove Ayyappa\'s divine powers. When he came riding on the tigers after taming them, everyone realized his divinity.

After this incident, Ayyappa completed his earthly duties and went to Sabarimala, where he began his penance.''',
      iconData: Icons.pets,
      category: 'Divine Miracle',
    ),
    HistoricalContent(
      id: 'sabarimala_temple',
      titleTamil: 'à®šà®ªà®°à®¿à®®à®²à¯ˆ à®•à¯‹à®¯à®¿à®²à¯ à®µà®°à®²à®¾à®±à¯',
      titleTelugu: 'à°¶à°¬à°°à°¿à°®à°² à°¦à±‡à°µà°¾à°²à°¯ à°šà°°à°¿à°¤à±à°°',
      titleEnglish: 'Sabarimala Temple History',
      contentTamil: '''à®šà®ªà®°à®¿à®®à®²à¯ˆ à®•à¯‹à®¯à®¿à®²à¯ à®•à¯‡à®°à®³à®¾à®µà®¿à®©à¯ à®ªà®¤à¯à®¤à®©à®®à¯à®¤à®¿à®Ÿà¯à®Ÿà®¾ à®®à®¾à®µà®Ÿà¯à®Ÿà®¤à¯à®¤à®¿à®²à¯ à®…à®®à¯ˆà®¨à¯à®¤à¯à®³à¯à®³à®¤à¯. à®‡à®¤à¯ 18 à®ªà®Ÿà®¿à®•à®³à¯ˆà®•à¯ à®•à¯Šà®£à¯à®Ÿ à®ªà¯à®©à®¿à®¤ à®®à®²à¯ˆà®¯à®¾à®•à¯à®®à¯.

18 à®ªà®Ÿà®¿à®•à®³à¯ à®ªà®²à¯à®µà¯‡à®±à¯ à®µà®¿à®·à®¯à®™à¯à®•à®³à¯ˆà®•à¯ à®•à¯à®±à®¿à®•à¯à®•à®¿à®©à¯à®±à®©:
- à®®à¯à®¤à®²à¯ 5 à®ªà®Ÿà®¿à®•à®³à¯ - à®ªà®žà¯à®š à®‡à®¨à¯à®¤à®¿à®°à®¿à®¯à®™à¯à®•à®³à¯
- à®…à®Ÿà¯à®¤à¯à®¤ 8 à®ªà®Ÿà®¿à®•à®³à¯ - à®…à®·à¯à®Ÿ à®•à¯à®£à®™à¯à®•à®³à¯
- à®…à®Ÿà¯à®¤à¯à®¤ 3 à®ªà®Ÿà®¿à®•à®³à¯ - à®®à¯à®•à¯à®•à¯à®£à®™à¯à®•à®³à¯
- à®•à®Ÿà¯ˆà®šà®¿ 2 à®ªà®Ÿà®¿à®•à®³à¯ - à®…à®¹à®™à¯à®•à®¾à®°à®®à¯ à®®à®±à¯à®±à¯à®®à¯ à®®à¯‹à®•à®®à¯

à®‡à®¨à¯à®¤ 18 à®ªà®Ÿà®¿à®•à®³à¯ˆà®•à¯ à®•à®Ÿà®¨à¯à®¤à®¾à®²à¯à®¤à®¾à®©à¯ à®…à®¯à¯à®¯à®ªà¯à®ªà®©à¯ˆ à®¤à®°à®¿à®šà®¿à®•à¯à®• à®®à¯à®Ÿà®¿à®¯à¯à®®à¯. à®‡à®¤à¯ à®†à®©à¯à®®à¯€à®• à®®à¯à®©à¯à®©à¯‡à®±à¯à®±à®¤à¯à®¤à¯ˆà®•à¯ à®•à¯à®±à®¿à®•à¯à®•à®¿à®±à®¤à¯.''',
      contentTelugu: '''à°¶à°¬à°°à°¿à°®à°² à°¦à±‡à°µà°¾à°²à°¯à°‚ à°•à±‡à°°à°³à°²à±‹à°¨à°¿ à°ªà°¤à±à°¤à°¨à°‚à°¤à°¿à°Ÿà±à°Ÿ à°œà°¿à°²à±à°²à°¾à°²à±‹ à°‰à°‚à°¦à°¿. à°‡à°¦à°¿ 18 à°®à±†à°Ÿà±à°²à± à°•à°²à°¿à°—à°¿à°¨ à°ªà°µà°¿à°¤à±à°° à°ªà°°à±à°µà°¤à°‚.

18 à°®à±†à°Ÿà±à°²à± à°µà°¿à°µà°¿à°§ à°µà°¿à°·à°¯à°¾à°²à°¨à± à°¸à±‚à°šà°¿à°¸à±à°¤à°¾à°¯à°¿:
- à°®à±Šà°¦à°Ÿà°¿ 5 à°®à±†à°Ÿà±à°²à± - à°ªà°‚à°šà±‡à°‚à°¦à±à°°à°¿à°¯à°¾à°²à±
- à°¤à°°à±à°µà°¾à°¤à°¿ 8 à°®à±†à°Ÿà±à°²à± - à°…à°·à±à°Ÿ à°—à±à°£à°¾à°²à±
- à°¤à°°à±à°µà°¾à°¤à°¿ 3 à°®à±†à°Ÿà±à°²à± - à°¤à±à°°à°¿à°—à±à°£à°¾à°²à±
- à°šà°¿à°µà°°à°¿ 2 à°®à±†à°Ÿà±à°²à± - à°…à°¹à°‚à°•à°¾à°°à°‚ à°®à°°à°¿à°¯à± à°®à±‹à°¹à°‚

à°ˆ 18 à°®à±†à°Ÿà±à°²à± à°¦à°¾à°Ÿà°¿à°¤à±‡ à°®à°¾à°¤à±à°°à°®à±‡ à°…à°¯à±à°¯à°ªà±à°ªà°¨à± à°¦à°°à±à°¶à°¿à°‚à°šà°µà°šà±à°šà±. à°‡à°¦à°¿ à°†à°§à±à°¯à°¾à°¤à±à°®à°¿à°• à°ªà±à°°à±‹à°—à°¤à°¿à°¨à°¿ à°¸à±‚à°šà°¿à°¸à±à°¤à±à°‚à°¦à°¿.''',
      contentEnglish: '''Sabarimala temple is located in Pathanamthitta district of Kerala. It is a sacred mountain with 18 holy steps.

The 18 steps represent various aspects:
- First 5 steps - Five senses
- Next 8 steps - Eight virtues
- Next 3 steps - Three gunas
- Last 2 steps - Ego and desire

Only after crossing these 18 steps can one have darshan of Ayyappa. This represents spiritual progress.''',
      iconData: Icons.temple_hindu,
      category: 'Sacred Geography',
    ),
  ];

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    ));
    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<LanguageProvider, ThemeProvider>(
      builder: (context, languageProvider, themeProvider, child) {
        return FadeTransition(
          opacity: _fadeAnimation,
          child: GradientBackground(
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(AppConstants.paddingLarge),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Section Header
                  _buildSectionHeader(
                    context,
                    languageProvider.currentLanguage,
                    themeProvider.isDarkMode,
                  ),
                  const SizedBox(height: AppConstants.spacingLarge),
                  
                  // History Cards
                  ListView.separated(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemCount: _historicalContent.length,
                    separatorBuilder: (context, index) =>
                        const SizedBox(height: AppConstants.spacingMedium),
                    itemBuilder: (context, index) {
                      return _buildHistoryCard(
                        context,
                        _historicalContent[index],
                        index,
                        languageProvider.currentLanguage,
                        themeProvider.isDarkMode,
                      );
                    },
                  ),
                  
                  const SizedBox(height: AppConstants.spacingXLarge),
                  
                  // Call to Action
                  _buildCallToAction(
                    context,
                    languageProvider.currentLanguage,
                    themeProvider.isDarkMode,
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildSectionHeader(
    BuildContext context,
    String language,
    bool isDarkMode,
  ) {
    final title = _getSectionTitle(language);
    final subtitle = _getSectionSubtitle(language);

    return DevotionalCard(
      padding: const EdgeInsets.all(AppConstants.paddingLarge),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Container(
                padding: const EdgeInsets.all(AppConstants.paddingSmall),
                decoration: BoxDecoration(
                  color: AppConstants.primaryColor.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(AppConstants.borderRadius),
                ),
                child: Icon(
                  Icons.history_edu,
                  color: AppConstants.primaryColor,
                  size: 28,
                ),
              ),
              const SizedBox(width: AppConstants.spacingMedium),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: AppTextStyles.headlineMedium.copyWith(
                        color: isDarkMode ? Colors.white : Colors.black87,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: AppConstants.spacingXSmall),
                    Text(
                      subtitle,
                      style: AppTextStyles.bodyMedium.copyWith(
                        color: isDarkMode ? Colors.white70 : Colors.black54,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildHistoryCard(
    BuildContext context,
    HistoricalContent content,
    int index,
    String language,
    bool isDarkMode,
  ) {
    final isExpanded = _expandedIndex == index;
    final title = _getTitle(content, language);
    final text = _getContent(content, language);

    return AnimatedContainer(
      duration: const Duration(milliseconds: 300),
      child: DevotionalCard(
        padding: EdgeInsets.zero,
        child: Column(
          children: [
            // Header
            InkWell(
              onTap: () {
                setState(() {
                  _expandedIndex = isExpanded ? -1 : index;
                });
              },
              borderRadius: BorderRadius.circular(AppConstants.borderRadius),
              child: Padding(
                padding: const EdgeInsets.all(AppConstants.paddingLarge),
                child: Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(AppConstants.paddingMedium),
                      decoration: BoxDecoration(
                        color: AppConstants.primaryColor.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(AppConstants.borderRadius),
                      ),
                      child: Icon(
                        content.iconData,
                        color: AppConstants.primaryColor,
                        size: 24,
                      ),
                    ),
                    const SizedBox(width: AppConstants.spacingMedium),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            title,
                            style: AppTextStyles.titleMedium.copyWith(
                              color: isDarkMode ? Colors.white : Colors.black87,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          const SizedBox(height: AppConstants.spacingXSmall),
                          Text(
                            content.category,
                            style: AppTextStyles.bodySmall.copyWith(
                              color: AppConstants.primaryColor,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ],
                      ),
                    ),
                    AnimatedRotation(
                      turns: isExpanded ? 0.5 : 0.0,
                      duration: const Duration(milliseconds: 300),
                      child: Icon(
                        Icons.keyboard_arrow_down,
                        color: isDarkMode ? Colors.white70 : Colors.black54,
                      ),
                    ),
                  ],
                ),
              ),
            ),
            
            // Expandable Content
            AnimatedCrossFade(
              firstChild: const SizedBox.shrink(),
              secondChild: Container(
                width: double.infinity,
                padding: const EdgeInsets.fromLTRB(
                  AppConstants.paddingLarge,
                  0,
                  AppConstants.paddingLarge,
                  AppConstants.paddingLarge,
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Divider(
                      color: (isDarkMode ? Colors.white : Colors.black)
                          .withOpacity(0.1),
                    ),
                    const SizedBox(height: AppConstants.spacingMedium),
                    Text(
                      text,
                      style: AppTextStyles.bodyMedium.copyWith(
                        color: isDarkMode ? Colors.white : Colors.black87,
                        height: 1.6,
                        fontSize: 16,
                      ),
                      textAlign: TextAlign.justify,
                    ),
                    const SizedBox(height: AppConstants.spacingMedium),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        TextButton.icon(
                          onPressed: () => _shareContent(context, title, text),
                          icon: const Icon(Icons.share, size: 18),
                          label: Text(_getShareText(language)),
                          style: TextButton.styleFrom(
                            foregroundColor: AppConstants.primaryColor,
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              crossFadeState: isExpanded
                  ? CrossFadeState.showSecond
                  : CrossFadeState.showFirst,
              duration: const Duration(milliseconds: 300),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildCallToAction(
    BuildContext context,
    String language,
    bool isDarkMode,
  ) {
    final title = _getCallToActionTitle(language);
    final subtitle = _getCallToActionSubtitle(language);
    final buttonText = _getCallToActionButton(language);

    return DevotionalCard(
      padding: const EdgeInsets.all(AppConstants.paddingLarge),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Icon(
            Icons.auto_stories,
            color: AppConstants.primaryColor,
            size: 48,
          ),
          const SizedBox(height: AppConstants.spacingMedium),
          Text(
            title,
            style: AppTextStyles.titleLarge.copyWith(
              color: isDarkMode ? Colors.white : Colors.black87,
              fontWeight: FontWeight.bold,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: AppConstants.spacingSmall),
          Text(
            subtitle,
            style: AppTextStyles.bodyMedium.copyWith(
              color: isDarkMode ? Colors.white70 : Colors.black54,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: AppConstants.spacingLarge),
          ElevatedButton.icon(
            onPressed: () {
              // Navigate to detailed stories or external content
              _showComingSoonDialog(context, language);
            },
            icon: const Icon(Icons.book_online),
            label: Text(buttonText),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppConstants.primaryColor,
              foregroundColor: Colors.white,
              padding: const EdgeInsets.symmetric(
                horizontal: AppConstants.paddingLarge,
                vertical: AppConstants.paddingMedium,
              ),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(AppConstants.borderRadius),
              ),
            ),
          ),
        ],
      ),
    );
  }

  String _getSectionTitle(String language) {
    switch (language) {
      case 'tamil':
        return 'à®…à®¯à¯à®¯à®ªà¯à®ªà®©à¯ à®µà®°à®²à®¾à®±à¯';
      case 'telugu':
        return 'à°…à°¯à±à°¯à°ªà±à°ª à°šà°°à°¿à°¤à±à°°';
      default:
        return 'History of Lord Ayyappa';
    }
  }

  String _getSectionSubtitle(String language) {
    switch (language) {
      case 'tamil':
        return 'à®ªà¯à®©à®¿à®¤ à®•à®¤à¯ˆà®•à®³à¯ à®®à®±à¯à®±à¯à®®à¯ à®…à®±à¯à®ªà¯à®¤à®™à¯à®•à®³à¯';
      case 'telugu':
        return 'à°ªà°µà°¿à°¤à±à°° à°•à°¥à°²à± à°®à°°à°¿à°¯à± à°…à°¦à±à°­à±à°¤à°¾à°²à±';
      default:
        return 'Sacred Stories and Divine Miracles';
    }
  }

  String _getTitle(HistoricalContent content, String language) {
    switch (language) {
      case 'tamil':
        return content.titleTamil;
      case 'telugu':
        return content.titleTelugu;
      default:
        return content.titleEnglish;
    }
  }

  String _getContent(HistoricalContent content, String language) {
    switch (language) {
      case 'tamil':
        return content.contentTamil;
      case 'telugu':
        return content.contentTelugu;
      default:
        return content.contentEnglish;
    }
  }

  String _getShareText(String language) {
    switch (language) {
      case 'tamil':
        return 'à®ªà®•à®¿à®°à®µà¯à®®à¯';
      case 'telugu':
        return 'à°ªà°‚à°šà±à°•à±‹à°‚à°¡à°¿';
      default:
        return 'Share';
    }
  }

  String _getCallToActionTitle(String language) {
    switch (language) {
      case 'tamil':
        return 'à®®à¯‡à®²à¯à®®à¯ à®•à®¤à¯ˆà®•à®³à¯';
      case 'telugu':
        return 'à°®à°°à°¿à°¨à±à°¨à°¿ à°•à°¥à°²à±';
      default:
        return 'More Stories';
    }
  }

  String _getCallToActionSubtitle(String language) {
    switch (language) {
      case 'tamil':
        return 'à®…à®¯à¯à®¯à®ªà¯à®ªà®©à¯ à®®à®•à®¾à®¤à¯à®®à®¿à®¯à®®à¯ à®®à¯à®´à¯ à®•à®¤à¯ˆà®¯à¯ˆà®¯à¯à®®à¯ à®ªà®Ÿà®¿à®¯à¯à®™à¯à®•à®³à¯';
      case 'telugu':
        return 'à°…à°¯à±à°¯à°ªà±à°ª à°®à°¹à°¾à°¤à±à°®à±à°¯à°‚ à°ªà±‚à°°à±à°¤à°¿ à°•à°¥à°¨à± à°šà°¦à°µà°‚à°¡à°¿';
      default:
        return 'Read the complete Ayyappa Mahatmyam stories';
    }
  }

  String _getCallToActionButton(String language) {
    switch (language) {
      case 'tamil':
        return 'à®®à¯à®´à¯ à®•à®¤à¯ˆà®•à®³à¯';
      case 'telugu':
        return 'à°ªà±‚à°°à±à°¤à°¿ à°•à°¥à°²à±';
      default:
        return 'Full Stories';
    }
  }

  void _shareContent(BuildContext context, String title, String content) {
    // Implement share functionality
    try {
      final shareText = '$title\n\n$content\n\n- à®šà®ªà®°à®¿à®®à®²à¯ˆ à®…à®¯à¯à®¯à®ªà¯à®ªà®©à¯';
      // In a real app, you would use the share_plus package here
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Share functionality will be implemented'),
          duration: Duration(seconds: 2),
        ),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Error sharing content'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  void _showComingSoonDialog(BuildContext context, String language) {
    final title = language == 'tamil'
        ? 'à®µà®¿à®°à¯ˆà®µà®¿à®²à¯ à®µà®°à¯à®®à¯'
        : language == 'telugu'
            ? 'à°¤à±à°µà°°à°²à±‹ à°µà°¸à±à°¤à±à°‚à°¦à°¿'
            : 'Coming Soon';
    final message = language == 'tamil'
        ? 'à®®à¯à®´à¯ à®•à®¤à¯ˆà®•à®³à¯ à®µà®¿à®°à¯ˆà®µà®¿à®²à¯ à®•à®¿à®Ÿà¯ˆà®•à¯à®•à¯à®®à¯'
        : language == 'telugu'
            ? 'à°ªà±‚à°°à±à°¤à°¿ à°•à°¥à°²à± à°¤à±à°µà°°à°²à±‹ à°…à°‚à°¦à±à°¬à°¾à°Ÿà±à°²à±‹ à°‰à°‚à°Ÿà°¾à°¯à°¿'
            : 'Full stories will be available soon';

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(title),
        content: Text(message),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }
}

/// Model for historical content
class HistoricalContent {
  final String id;
  final String titleTamil;
  final String titleTelugu;
  final String titleEnglish;
  final String contentTamil;
  final String contentTelugu;
  final String contentEnglish;
  final IconData iconData;
  final String category;

  HistoricalContent({
    required this.id,
    required this.titleTamil,
    required this.titleTelugu,
    required this.titleEnglish,
    required this.contentTamil,
    required this.contentTelugu,
    required this.contentEnglish,
    required this.iconData,
    required this.category,
  });
}
//widgets/library/mantras_collection_widget.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import '../../models/devotional_content.dart';
import '../../providers/language_provider.dart';
import '../../providers/theme_provider.dart';
import '../../providers/favorites_provider.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';
import '../common/devotional_card.dart';
import '../common/gradient_background.dart';

class MantrasCollection extends StatefulWidget {
  const MantrasCollection({Key? key}) : super(key: key);

  @override
  State<MantrasCollection> createState() => _MantrasCollectionState();
}

class _MantrasCollectionState extends State<MantrasCollection>
    with TickerProviderStateMixin {
  late TabController _tabController;
  String _searchQuery = '';
  bool _isSearching = false;
  final TextEditingController _searchController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 4, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer3<LanguageProvider, ThemeProvider, FavoritesProvider>(
      builder: (context, languageProvider, themeProvider, favoritesProvider, child) {
        return Scaffold(
          backgroundColor: themeProvider.isDarkMode 
              ? AppColors.primaryDark 
              : AppColors.background,
          body: GradientBackground(
            child: Column(
              children: [
                _buildHeader(context, themeProvider),
                _buildSearchBar(context, themeProvider),
                _buildTabBar(context, themeProvider),
                Expanded(
                  child: TabBarView(
                    controller: _tabController,
                    children: [
                      _buildDailyMantras(context, languageProvider, themeProvider, favoritesProvider),
                      _buildSpecialMantras(context, languageProvider, themeProvider, favoritesProvider),
                      _buildPrayerMantras(context, languageProvider, themeProvider, favoritesProvider),
                      _buildAshtottarams(context, languageProvider, themeProvider, favoritesProvider),
                    ],
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildHeader(BuildContext context, ThemeProvider themeProvider) {
    return Container(
      padding: const EdgeInsets.all(AppSizes.paddingLarge),
      child: Row(
        children: [
          Icon(
            Icons.auto_awesome,
            color: themeProvider.isDarkMode ? AppColors.accent : AppColors.primary,
            size: 28,
          ),
          const SizedBox(width: AppSizes.spacingMedium),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Sacred Mantras',
                  style: AppTextStyles.heading2.copyWith(
                    color: themeProvider.isDarkMode 
                        ? AppColors.textLight 
                        : AppColors.textDark,
                  ),
                ),
                Text(
                  'Divine chants for spiritual growth',
                  style: AppTextStyles.body2.copyWith(
                    color: themeProvider.isDarkMode 
                        ? AppColors.textLight.withOpacity(0.8)
                        : AppColors.textDark.withOpacity(0.8),
                  ),
                ),
              ],
            ),
          ),
          IconButton(
            onPressed: () => setState(() => _isSearching = !_isSearching),
            icon: Icon(
              _isSearching ? Icons.close : Icons.search,
              color: themeProvider.isDarkMode ? AppColors.textLight : AppColors.textDark,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSearchBar(BuildContext context, ThemeProvider themeProvider) {
    if (!_isSearching) return const SizedBox.shrink();

    return Container(
      margin: const EdgeInsets.symmetric(horizontal: AppSizes.paddingLarge),
      padding: const EdgeInsets.symmetric(horizontal: AppSizes.paddingMedium),
      decoration: BoxDecoration(
        color: themeProvider.isDarkMode 
            ? AppColors.surfaceDark 
            : AppColors.surface,
        borderRadius: BorderRadius.circular(AppSizes.radiusLarge),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: TextField(
        controller: _searchController,
        onChanged: (value) => setState(() => _searchQuery = value),
        decoration: InputDecoration(
          hintText: 'Search mantras...',
          hintStyle: AppTextStyles.body2.copyWith(
            color: themeProvider.isDarkMode 
                ? AppColors.textLight.withOpacity(0.6)
                : AppColors.textDark.withOpacity(0.6),
          ),
          border: InputBorder.none,
          prefixIcon: Icon(
            Icons.search,
            color: themeProvider.isDarkMode 
                ? AppColors.textLight.withOpacity(0.6)
                : AppColors.textDark.withOpacity(0.6),
          ),
          suffixIcon: _searchQuery.isNotEmpty
              ? IconButton(
                  onPressed: () {
                    _searchController.clear();
                    setState(() => _searchQuery = '');
                  },
                  icon: Icon(
                    Icons.clear,
                    color: themeProvider.isDarkMode 
                        ? AppColors.textLight.withOpacity(0.6)
                        : AppColors.textDark.withOpacity(0.6),
                  ),
                )
              : null,
        ),
        style: AppTextStyles.body1.copyWith(
          color: themeProvider.isDarkMode 
              ? AppColors.textLight 
              : AppColors.textDark,
        ),
      ),
    );
  }

  Widget _buildTabBar(BuildContext context, ThemeProvider themeProvider) {
    return Container(
      margin: const EdgeInsets.all(AppSizes.paddingLarge),
      decoration: BoxDecoration(
        color: themeProvider.isDarkMode 
            ? AppColors.surfaceDark 
            : AppColors.surface,
        borderRadius: BorderRadius.circular(AppSizes.radiusLarge),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: TabBar(
        controller: _tabController,
        labelColor: themeProvider.isDarkMode ? AppColors.accent : AppColors.primary,
        unselectedLabelColor: themeProvider.isDarkMode 
            ? AppColors.textLight.withOpacity(0.6)
            : AppColors.textDark.withOpacity(0.6),
        indicator: BoxDecoration(
          color: themeProvider.isDarkMode 
              ? AppColors.accent.withOpacity(0.2)
              : AppColors.primary.withOpacity(0.2),
          borderRadius: BorderRadius.circular(AppSizes.radiusLarge),
        ),
        indicatorSize: TabBarIndicatorSize.tab,
        tabs: const [
          Tab(text: 'Daily'),
          Tab(text: 'Special'),
          Tab(text: 'Prayer'),
          Tab(text: '108 Names'),
        ],
      ),
    );
  }

  Widget _buildDailyMantras(
    BuildContext context,
    LanguageProvider languageProvider,
    ThemeProvider themeProvider,
    FavoritesProvider favoritesProvider,
  ) {
    final mantras = _getMockDailyMantras()
        .where((mantra) => _searchQuery.isEmpty || 
            mantra.title.toLowerCase().contains(_searchQuery.toLowerCase()) ||
            mantra.content.toLowerCase().contains(_searchQuery.toLowerCase()))
        .toList();

    return ListView.builder(
      padding: const EdgeInsets.all(AppSizes.paddingLarge),
      itemCount: mantras.length,
      itemBuilder: (context, index) {
        final mantra = mantras[index];
        return _buildMantraCard(
          context, 
          mantra, 
          themeProvider, 
          favoritesProvider,
          languageProvider,
        );
      },
    );
  }

  Widget _buildSpecialMantras(
    BuildContext context,
    LanguageProvider languageProvider,
    ThemeProvider themeProvider,
    FavoritesProvider favoritesProvider,
  ) {
    final mantras = _getMockSpecialMantras()
        .where((mantra) => _searchQuery.isEmpty || 
            mantra.title.toLowerCase().contains(_searchQuery.toLowerCase()) ||
            mantra.content.toLowerCase().contains(_searchQuery.toLowerCase()))
        .toList();

    return ListView.builder(
      padding: const EdgeInsets.all(AppSizes.paddingLarge),
      itemCount: mantras.length,
      itemBuilder: (context, index) {
        final mantra = mantras[index];
        return _buildMantraCard(
          context, 
          mantra, 
          themeProvider, 
          favoritesProvider,
          languageProvider,
        );
      },
    );
  }

  Widget _buildPrayerMantras(
    BuildContext context,
    LanguageProvider languageProvider,
    ThemeProvider themeProvider,
    FavoritesProvider favoritesProvider,
  ) {
    final mantras = _getMockPrayerMantras()
        .where((mantra) => _searchQuery.isEmpty || 
            mantra.title.toLowerCase().contains(_searchQuery.toLowerCase()) ||
            mantra.content.toLowerCase().contains(_searchQuery.toLowerCase()))
        .toList();

    return ListView.builder(
      padding: const EdgeInsets.all(AppSizes.paddingLarge),
      itemCount: mantras.length,
      itemBuilder: (context, index) {
        final mantra = mantras[index];
        return _buildMantraCard(
          context, 
          mantra, 
          themeProvider, 
          favoritesProvider,
          languageProvider,
        );
      },
    );
  }

  Widget _buildAshtottarams(
    BuildContext context,
    LanguageProvider languageProvider,
    ThemeProvider themeProvider,
    FavoritesProvider favoritesProvider,
  ) {
    final mantras = _getMockAshtottarams()
        .where((mantra) => _searchQuery.isEmpty || 
            mantra.title.toLowerCase().contains(_searchQuery.toLowerCase()) ||
            mantra.content.toLowerCase().contains(_searchQuery.toLowerCase()))
        .toList();

    return ListView.builder(
      padding: const EdgeInsets.all(AppSizes.paddingLarge),
      itemCount: mantras.length,
      itemBuilder: (context, index) {
        final mantra = mantras[index];
        return _buildMantraCard(
          context, 
          mantra, 
          themeProvider, 
          favoritesProvider,
          languageProvider,
        );
      },
    );
  }

  Widget _buildMantraCard(
    BuildContext context,
    Mantra mantra,
    ThemeProvider themeProvider,
    FavoritesProvider favoritesProvider,
    LanguageProvider languageProvider,
  ) {
    final isFavorite = favoritesProvider.isFavoriteMantra(mantra.id);

    return DevotionalCard(
      margin: const EdgeInsets.only(bottom: AppSizes.spacingMedium),
      child: ExpansionTile(
        leading: Container(
          padding: const EdgeInsets.all(AppSizes.paddingSmall),
          decoration: BoxDecoration(
            color: themeProvider.isDarkMode 
                ? AppColors.accent.withOpacity(0.2)
                : AppColors.primary.withOpacity(0.2),
            borderRadius: BorderRadius.circular(AppSizes.radiusMedium),
          ),
          child: Icon(
            Icons.auto_awesome,
            color: themeProvider.isDarkMode ? AppColors.accent : AppColors.primary,
            size: 24,
          ),
        ),
        title: Text(
          mantra.title,
          style: AppTextStyles.heading3.copyWith(
            color: themeProvider.isDarkMode 
                ? AppColors.textLight 
                : AppColors.textDark,
          ),
        ),
        subtitle: Text(
          mantra.description,
          style: AppTextStyles.body2.copyWith(
            color: themeProvider.isDarkMode 
                ? AppColors.textLight.withOpacity(0.8)
                : AppColors.textDark.withOpacity(0.8),
          ),
        ),
        trailing: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            IconButton(
              onPressed: () => _copyToClipboard(context, mantra.content),
              icon: Icon(
                Icons.copy,
                color: themeProvider.isDarkMode 
                    ? AppColors.textLight.withOpacity(0.6)
                    : AppColors.textDark.withOpacity(0.6),
              ),
            ),
            IconButton(
              onPressed: () => _toggleFavorite(mantra, favoritesProvider),
              icon: Icon(
                isFavorite ? Icons.favorite : Icons.favorite_border,
                color: isFavorite 
                    ? AppColors.error 
                    : (themeProvider.isDarkMode 
                        ? AppColors.textLight.withOpacity(0.6)
                        : AppColors.textDark.withOpacity(0.6)),
              ),
            ),
          ],
        ),
        children: [
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(AppSizes.paddingLarge),
            decoration: BoxDecoration(
              color: themeProvider.isDarkMode 
                  ? AppColors.surfaceDark.withOpacity(0.5)
                  : AppColors.surface.withOpacity(0.5),
              borderRadius: const BorderRadius.only(
                bottomLeft: Radius.circular(AppSizes.radiusMedium),
                bottomRight: Radius.circular(AppSizes.radiusMedium),
              ),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Mantra:',
                  style: AppTextStyles.heading4.copyWith(
                    color: themeProvider.isDarkMode 
                        ? AppColors.accent 
                        : AppColors.primary,
                  ),
                ),
                const SizedBox(height: AppSizes.spacingSmall),
                Text(
                  mantra.content,
                  style: AppTextStyles.body1.copyWith(
                    color: themeProvider.isDarkMode 
                        ? AppColors.textLight 
                        : AppColors.textDark,
                    height: 1.6,
                  ),
                ),
                if (mantra.benefits.isNotEmpty) ...[
                  const SizedBox(height: AppSizes.spacingMedium),
                  Text(
                    'Benefits:',
                    style: AppTextStyles.heading4.copyWith(
                      color: themeProvider.isDarkMode 
                          ? AppColors.accent 
                          : AppColors.primary,
                    ),
                  ),
                  const SizedBox(height: AppSizes.spacingSmall),
                  Text(
                    mantra.benefits,
                    style: AppTextStyles.body2.copyWith(
                      color: themeProvider.isDarkMode 
                          ? AppColors.textLight.withOpacity(0.8)
                          : AppColors.textDark.withOpacity(0.8),
                      height: 1.5,
                    ),
                  ),
                ],
                const SizedBox(height: AppSizes.spacingMedium),
                Row(
                  children: [
                    Icon(
                      Icons.schedule,
                      size: 16,
                      color: themeProvider.isDarkMode 
                          ? AppColors.textLight.withOpacity(0.6)
                          : AppColors.textDark.withOpacity(0.6),
                    ),
                    const SizedBox(width: AppSizes.spacingSmall),
                    Text(
                      'Best time: ${mantra.bestTime}',
                      style: AppTextStyles.caption.copyWith(
                        color: themeProvider.isDarkMode 
                            ? AppColors.textLight.withOpacity(0.6)
                            : AppColors.textDark.withOpacity(0.6),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  void _copyToClipboard(BuildContext context, String text) {
    Clipboard.setData(ClipboardData(text: text));
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: const Text('Mantra copied to clipboard'),
        backgroundColor: AppColors.success,
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSizes.radiusMedium),
        ),
      ),
    );
  }

  void _toggleFavorite(Mantra mantra, FavoritesProvider favoritesProvider) {
    if (favoritesProvider.isFavoriteMantra(mantra.id)) {
      favoritesProvider.removeFavoriteMantra(mantra.id);
    } else {
      favoritesProvider.addFavoriteMantra(mantra.id);
    }
  }

  // Mock data methods
  List<Mantra> _getMockDailyMantras() {
    return [
      Mantra(
        id: 'daily_1',
        title: 'Ayyappa Gayatri',
        content: 'Om Bhuthanathaya Vidmahe\nBhavanadhya Dhimahi\nTanno Shasta Prachodayat',
        description: 'Daily morning chant for divine blessings',
        benefits: 'Brings peace, removes obstacles, and grants wisdom',
        bestTime: 'Early morning (5-7 AM)',
        category: 'Daily',
      ),
      Mantra(
        id: 'daily_2',
        title: 'Saranam Mantra',
        content: 'Swamiye Saranam Ayyappa\nSwamiye Saranam Ayyappa\nSwamiye Saranam Ayyappa',
        description: 'Sacred surrender mantra',
        benefits: 'Develops devotion and surrender to divine will',
        bestTime: 'Anytime during the day',
        category: 'Daily',
      ),
      Mantra(
        id: 'daily_3',
        title: 'Evening Prayer',
        content: 'Ayyappa Swami Saranam\nHari Hara Suta Saranam\nMalikappuram Vasa Saranam',
        description: 'Evening devotional chant',
        benefits: 'Provides protection and peaceful sleep',
        bestTime: 'Evening (6-8 PM)',
        category: 'Daily',
      ),
    ];
  }

  List<Mantra> _getMockSpecialMantras() {
    return [
      Mantra(
        id: 'special_1',
        title: 'Makara Vilakku Mantra',
        content: 'Makarajyoti Darshana Mantra\nDeepam Jyothi Parabrahma\nDeepam Sarva Tamopaha',
        description: 'Special mantra for Makara Vilakku festival',
        benefits: 'Removes darkness from life, brings enlightenment',
        bestTime: 'During Makara Vilakku',
        category: 'Special',
      ),
      Mantra(
        id: 'special_2',
        title: 'Mandala Kala Mantra',
        content: 'Pandalam Rajasuta Ayyappa\nPamba Theera Vasaya Namaha\nMandalakala Dharana Mantra',
        description: 'Mantra for 41-day Mandala period',
        benefits: 'Spiritual purification and discipline',
        bestTime: 'During Mandala period',
        category: 'Special',
      ),
    ];
  }

  List<Mantra> _getMockPrayerMantras() {
    return [
      Mantra(
        id: 'prayer_1',
        title: 'Healing Prayer',
        content: 'Ayyappa Swami Raksha Mantra\nRoga Nashaya Namaha\nArogya Pradaya Namaha',
        description: 'Prayer for health and healing',
        benefits: 'Promotes physical and mental healing',
        bestTime: 'When needed',
        category: 'Prayer',
      ),
      Mantra(
        id: 'prayer_2',
        title: 'Success Prayer',
        content: 'Karya Siddhi Ayyappa Mantra\nVighna Nashaya Namaha\nSarva Karya Siddhi Pradaya Namaha',
        description: 'Prayer for success in endeavors',
        benefits: 'Removes obstacles and ensures success',
        bestTime: 'Before important tasks',
        category: 'Prayer',
      ),
    ];
  }

  List<Mantra> _getMockAshtottarams() {
    return [
      Mantra(
        id: 'ashtottara_1',
        title: 'Ayyappa Ashtottara Namavali',
        content: 'Om Bhuthanathaya Namaha\nOm Bhava Putraya Namaha\nOm Hariharaya Namaha\nOm Sharanagata Rakshakaya Namaha\n...continuing to 108 names',
        description: '108 sacred names of Lord Ayyappa',
        benefits: 'Complete spiritual transformation and divine grace',
        bestTime: 'Wednesdays and Saturdays',
        category: 'Ashtottara',
      ),
    ];
  }
}
//widgets/library/rituals_section.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../models/ritual_model.dart';
import '../../providers/language_provider.dart';
import '../../providers/theme_provider.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';
import '../common/devotional_card.dart';

/// Widget that displays ritual information and preparation guides
class RitualsSection extends StatefulWidget {
  final List<Ritual> rituals;
  final Function(Ritual)? onRitualTap;

  const RitualsSection({
    super.key,
    required this.rituals,
    this.onRitualTap,
  });

  @override
  State<RitualsSection> createState() => _RitualsSectionState();
}

class _RitualsSectionState extends State<RitualsSection>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  String _selectedCategory = 'all';

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 4, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  List<Ritual> get _filteredRituals {
    if (_selectedCategory == 'all') {
      return widget.rituals;
    }
    return widget.rituals
        .where((ritual) => ritual.category == _selectedCategory)
        .toList();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<LanguageProvider, ThemeProvider>(
      builder: (context, languageProvider, themeProvider, child) {
        final isDark = themeProvider.isDarkMode;
        
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Section Header
            Padding(
              padding: const EdgeInsets.all(AppConstants.paddingMedium),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    _getLocalizedText('rituals_guide', languageProvider.currentLanguage),
                    style: AppTextStyles.headingLarge.copyWith(
                      color: isDark ? Colors.white : AppColors.textPrimary,
                    ),
                  ),
                  IconButton(
                    onPressed: () => _showRitualInfo(context),
                    icon: Icon(
                      Icons.info_outline,
                      color: AppColors.primary,
                    ),
                  ),
                ],
              ),
            ),

            // Category Tabs
            Container(
              height: 50,
              margin: const EdgeInsets.symmetric(horizontal: AppConstants.paddingMedium),
              child: TabBar(
                controller: _tabController,
                isScrollable: true,
                indicatorColor: AppColors.primary,
                labelColor: AppColors.primary,
                unselectedLabelColor: isDark ? Colors.white70 : Colors.grey[600],
                tabs: [
                  Tab(text: _getLocalizedText('all', languageProvider.currentLanguage)),
                  Tab(text: _getLocalizedText('daily', languageProvider.currentLanguage)),
                  Tab(text: _getLocalizedText('pilgrimage', languageProvider.currentLanguage)),
                  Tab(text: _getLocalizedText('festivals', languageProvider.currentLanguage)),
                ],
                onTap: (index) {
                  setState(() {
                    switch (index) {
                      case 0:
                        _selectedCategory = 'all';
                        break;
                      case 1:
                        _selectedCategory = 'daily';
                        break;
                      case 2:
                        _selectedCategory = 'pilgrimage';
                        break;
                      case 3:
                        _selectedCategory = 'festival';
                        break;
                    }
                  });
                },
              ),
            ),

            const SizedBox(height: AppConstants.spacingMedium),

            // Rituals List
            AnimatedSwitcher(
              duration: const Duration(milliseconds: 300),
              child: _buildRitualsList(languageProvider, isDark),
            ),
          ],
        );
      },
    );
  }

  Widget _buildRitualsList(LanguageProvider languageProvider, bool isDark) {
    final filteredRituals = _filteredRituals;

    if (filteredRituals.isEmpty) {
      return Center(
        child: Column(
          children: [
            const SizedBox(height: 40),
            Icon(
              Icons.temple_hindu,
              size: 60,
              color: Colors.grey[400],
            ),
            const SizedBox(height: 16),
            Text(
              _getLocalizedText('no_rituals_found', languageProvider.currentLanguage),
              style: AppTextStyles.bodyMedium.copyWith(
                color: Colors.grey[600],
              ),
            ),
          ],
        ),
      );
    }

    return ListView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      padding: const EdgeInsets.symmetric(horizontal: AppConstants.paddingMedium),
      itemCount: filteredRituals.length,
      itemBuilder: (context, index) {
        final ritual = filteredRituals[index];
        return _buildRitualCard(ritual, languageProvider, isDark);
      },
    );
  }

  Widget _buildRitualCard(Ritual ritual, LanguageProvider languageProvider, bool isDark) {
    return DevotionalCard(
      margin: const EdgeInsets.only(bottom: AppConstants.spacingMedium),
      child: InkWell(
        onTap: () => widget.onRitualTap?.call(ritual),
        borderRadius: BorderRadius.circular(AppConstants.borderRadiusMedium),
        child: Padding(
          padding: const EdgeInsets.all(AppConstants.paddingMedium),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header Row
              Row(
                children: [
                  // Category Icon
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: AppColors.primary.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Icon(
                      _getCategoryIcon(ritual.category),
                      color: AppColors.primary,
                      size: 20,
                    ),
                  ),
                  const SizedBox(width: 12),
                  
                  // Title and Category
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          _getLocalizedRitualTitle(ritual, languageProvider.currentLanguage),
                          style: AppTextStyles.headingMedium.copyWith(
                            color: isDark ? Colors.white : AppColors.textPrimary,
                          ),
                        ),
                        const SizedBox(height: 4),
                        Container(
                          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                          decoration: BoxDecoration(
                            color: _getCategoryColor(ritual.category).withOpacity(0.2),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Text(
                            _getLocalizedText(ritual.category, languageProvider.currentLanguage),
                            style: AppTextStyles.captionSmall.copyWith(
                              color: _getCategoryColor(ritual.category),
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),

                  // Duration Badge
                  if (ritual.duration.isNotEmpty)
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      decoration: BoxDecoration(
                        color: AppColors.accent.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(
                            Icons.access_time,
                            size: 12,
                            color: AppColors.accent,
                          ),
                          const SizedBox(width: 4),
                          Text(
                            ritual.duration,
                            style: AppTextStyles.captionSmall.copyWith(
                              color: AppColors.accent,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ],
                      ),
                    ),
                ],
              ),

              const SizedBox(height: 12),

              // Description
              Text(
                _getLocalizedRitualDescription(ritual, languageProvider.currentLanguage),
                style: AppTextStyles.bodyMedium.copyWith(
                  color: isDark ? Colors.white70 : AppColors.textSecondary,
                  height: 1.4,
                ),
                maxLines: 3,
                overflow: TextOverflow.ellipsis,
              ),

              // Steps Preview
              if (ritual.steps.isNotEmpty) ...[
                const SizedBox(height: 12),
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: (isDark ? Colors.white : Colors.black).withOpacity(0.05),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Row(
                    children: [
                      Icon(
                        Icons.list_alt,
                        size: 16,
                        color: AppColors.primary,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        '${ritual.steps.length} ${_getLocalizedText('steps', languageProvider.currentLanguage)}',
                        style: AppTextStyles.bodySmall.copyWith(
                          color: AppColors.primary,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                      const Spacer(),
                      Icon(
                        Icons.arrow_forward_ios,
                        size: 12,
                        color: AppColors.primary,
                      ),
                    ],
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  IconData _getCategoryIcon(String category) {
    switch (category) {
      case 'daily':
        return Icons.wb_sunny;
      case 'pilgrimage':
        return Icons.temple_hindu;
      case 'festival':
        return Icons.celebration;
      default:
        return Icons.auto_awesome;
    }
  }

  Color _getCategoryColor(String category) {
    switch (category) {
      case 'daily':
        return Colors.orange;
      case 'pilgrimage':
        return AppColors.primary;
      case 'festival':
        return Colors.purple;
      default:
        return AppColors.accent;
    }
  }

  void _showRitualInfo(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(_getLocalizedText('about_rituals', context.read<LanguageProvider>().currentLanguage)),
        content: Text(_getLocalizedText('rituals_info_text', context.read<LanguageProvider>().currentLanguage)),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(_getLocalizedText('ok', context.read<LanguageProvider>().currentLanguage)),
          ),
        ],
      ),
    );
  }

  String _getLocalizedText(String key, String language) {
    final texts = {
      'en': {
        'rituals_guide': 'Rituals Guide',
        'all': 'All',
        'daily': 'Daily',
        'pilgrimage': 'Pilgrimage',
        'festivals': 'Festivals',
        'no_rituals_found': 'No rituals found',
        'steps': 'steps',
        'about_rituals': 'About Rituals',
        'rituals_info_text': 'These rituals are traditional practices for devotees of Lord Ayyappa. Follow them with devotion and sincerity.',
        'ok': 'OK',
      },
      'ta': {
        'rituals_guide': 'à®µà®´à®¿à®ªà®¾à®Ÿà¯à®Ÿà¯ à®®à¯à®±à¯ˆà®•à®³à¯',
        'all': 'à®…à®©à¯ˆà®¤à¯à®¤à¯à®®à¯',
        'daily': 'à®¤à®¿à®©à®šà®°à®¿',
        'pilgrimage': 'à®¯à®¾à®¤à¯à®¤à®¿à®°à¯ˆ',
        'festivals': 'à®µà®¿à®´à®¾à®•à¯à®•à®³à¯',
        'no_rituals_found': 'à®µà®´à®¿à®ªà®¾à®Ÿà¯à®Ÿà¯ à®®à¯à®±à¯ˆà®•à®³à¯ à®Žà®¤à¯à®µà¯à®®à¯ à®•à®¿à®Ÿà¯ˆà®•à¯à®•à®µà®¿à®²à¯à®²à¯ˆ',
        'steps': 'à®ªà®Ÿà®¿à®•à®³à¯',
        'about_rituals': 'à®µà®´à®¿à®ªà®¾à®Ÿà¯à®Ÿà¯ à®®à¯à®±à¯ˆà®•à®³à¯ à®ªà®±à¯à®±à®¿',
        'rituals_info_text': 'à®‡à®µà¯ˆ à®à®¯à®ªà¯à®ªà®©à¯ à®ªà®•à¯à®¤à®°à¯à®•à®³à¯à®•à¯à®•à®¾à®© à®ªà®¾à®°à®®à¯à®ªà®°à®¿à®¯ à®µà®´à®¿à®ªà®¾à®Ÿà¯à®Ÿà¯ à®®à¯à®±à¯ˆà®•à®³à¯. à®ªà®•à¯à®¤à®¿à®¯à¯à®Ÿà®©à¯ à®•à®Ÿà¯ˆà®ªà®¿à®Ÿà®¿à®•à¯à®•à®µà¯à®®à¯.',
        'ok': 'à®šà®°à®¿',
      },
      'te': {
        'rituals_guide': 'à°†à°šà°¾à°°à°¾à°² à°®à°¾à°°à±à°—à°¦à°°à±à°¶à°•à°‚',
        'all': 'à°…à°¨à±à°¨à±€',
        'daily': 'à°°à±‹à°œà±à°µà°¾à°°à±€',
        'pilgrimage': 'à°¯à°¾à°¤à±à°°',
        'festivals': 'à°ªà°‚à°¡à±à°—à°²à±',
        'no_rituals_found': 'à°†à°šà°¾à°°à°¾à°²à± à°•à°¨à±à°—à±Šà°¨à°¬à°¡à°²à±‡à°¦à±',
        'steps': 'à°¦à°¶à°²à±',
        'about_rituals': 'à°†à°šà°¾à°°à°¾à°² à°—à±à°°à°¿à°‚à°šà°¿',
        'rituals_info_text': 'à°‡à°µà°¿ à°…à°¯à±à°¯à°ªà±à°ª à°­à°•à±à°¤à±à°² à°•à±‹à°¸à°‚ à°¸à°‚à°ªà±à°°à°¦à°¾à°¯ à°†à°šà°¾à°°à°¾à°²à±. à°­à°•à±à°¤à°¿à°¤à±‹ à°ªà°¾à°Ÿà°¿à°‚à°šà°‚à°¡à°¿.',
        'ok': 'à°¸à°°à±‡',
      },
    };

    return texts[language]?[key] ?? texts['en']?[key] ?? key;
  }

  String _getLocalizedRitualTitle(Ritual ritual, String language) {
    switch (language) {
      case 'ta':
        return ritual.titleTamil;
      case 'te':
        return ritual.titleTelugu;
      default:
        return ritual.titleEnglish;
    }
  }

  String _getLocalizedRitualDescription(Ritual ritual, String language) {
    switch (language) {
      case 'ta':
        return ritual.descriptionTamil;
      case 'te':
        return ritual.descriptionTelugu;
      default:
        return ritual.descriptionEnglish;
    }
  }
}
//widgets/songs/search_filter_bar.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/language_provider.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';

class SearchFilterBar extends StatefulWidget {
  final String searchQuery;
  final Function(String) onSearchChanged;
  final VoidCallback onFilterPressed;
  final bool isFiltered;

  const SearchFilterBar({
    Key? key,
    required this.searchQuery,
    required this.onSearchChanged,
    required this.onFilterPressed,
    this.isFiltered = false,
  }) : super(key: key);

  @override
  State<SearchFilterBar> createState() => _SearchFilterBarState();
}

class _SearchFilterBarState extends State<SearchFilterBar>
    with SingleTickerProviderStateMixin {
  late TextEditingController _searchController;
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;
  bool _isSearchActive = false;

  @override
  void initState() {
    super.initState();
    _searchController = TextEditingController(text: widget.searchQuery);
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _searchController.dispose();
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final languageProvider = Provider.of<LanguageProvider>(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      padding: const EdgeInsets.all(AppConstants.paddingMedium),
      decoration: BoxDecoration(
        color: isDark ? Colors.black.withOpacity(0.3) : Colors.white.withOpacity(0.9),
        borderRadius: BorderRadius.circular(AppConstants.borderRadiusLarge),
        border: Border.all(
          color: theme.colorScheme.outline.withOpacity(0.2),
        ),
        boxShadow: [
          BoxShadow(
            color: theme.shadowColor.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Row(
        children: [
          // Search Field
          Expanded(
            child: ScaleTransition(
              scale: _scaleAnimation,
              child: Container(
                decoration: BoxDecoration(
                  color: theme.colorScheme.surface.withOpacity(0.8),
                  borderRadius: BorderRadius.circular(AppConstants.borderRadiusMedium),
                  border: Border.all(
                    color: _isSearchActive 
                        ? AppColors.primary 
                        : theme.colorScheme.outline.withOpacity(0.3),
                    width: _isSearchActive ? 2 : 1,
                  ),
                ),
                child: TextField(
                  controller: _searchController,
                  onChanged: (value) {
                    widget.onSearchChanged(value);
                    setState(() {
                      _isSearchActive = value.isNotEmpty;
                    });
                  },
                  onTap: () {
                    setState(() {
                      _isSearchActive = true;
                    });
                    _animationController.forward();
                  },
                  onEditingComplete: () {
                    FocusScope.of(context).unfocus();
                    setState(() {
                      _isSearchActive = false;
                    });
                    _animationController.reverse();
                  },
                  style: AppTextStyles.body1.copyWith(
                    color: theme.colorScheme.onSurface,
                  ),
                  decoration: InputDecoration(
                    hintText: _getSearchHint(languageProvider.currentLanguage),
                    hintStyle: AppTextStyles.body2.copyWith(
                      color: theme.colorScheme.onSurface.withOpacity(0.6),
                    ),
                    prefixIcon: AnimatedContainer(
                      duration: const Duration(milliseconds: 200),
                      child: Icon(
                        Icons.search,
                        color: _isSearchActive 
                            ? AppColors.primary 
                            : theme.colorScheme.onSurface.withOpacity(0.6),
                        size: 20,
                      ),
                    ),
                    suffixIcon: widget.searchQuery.isNotEmpty
                        ? IconButton(
                            icon: Icon(
                              Icons.clear,
                              color: theme.colorScheme.onSurface.withOpacity(0.6),
                              size: 20,
                            ),
                            onPressed: () {
                              _searchController.clear();
                              widget.onSearchChanged('');
                              setState(() {
                                _isSearchActive = false;
                              });
                            },
                          )
                        : null,
                    border: InputBorder.none,
                    contentPadding: const EdgeInsets.symmetric(
                      horizontal: AppConstants.paddingSmall,
                      vertical: AppConstants.paddingSmall,
                    ),
                  ),
                ),
              ),
            ),
          ),
          
          const SizedBox(width: AppConstants.spacingSmall),
          
          // Filter Button
          AnimatedContainer(
            duration: const Duration(milliseconds: 200),
            decoration: BoxDecoration(
              color: widget.isFiltered 
                  ? AppColors.primary 
                  : theme.colorScheme.surface.withOpacity(0.8),
              borderRadius: BorderRadius.circular(AppConstants.borderRadiusMedium),
              border: Border.all(
                color: widget.isFiltered 
                    ? AppColors.primary 
                    : theme.colorScheme.outline.withOpacity(0.3),
                width: widget.isFiltered ? 2 : 1,
              ),
              boxShadow: widget.isFiltered
                  ? [
                      BoxShadow(
                        color: AppColors.primary.withOpacity(0.3),
                        blurRadius: 8,
                        offset: const Offset(0, 2),
                      ),
                    ]
                  : null,
            ),
            child: Material(
              color: Colors.transparent,
              child: InkWell(
                onTap: widget.onFilterPressed,
                borderRadius: BorderRadius.circular(AppConstants.borderRadiusMedium),
                child: Container(
                  padding: const EdgeInsets.all(AppConstants.paddingSmall),
                  child: Stack(
                    children: [
                      Icon(
                        Icons.filter_list,
                        color: widget.isFiltered 
                            ? Colors.white 
                            : theme.colorScheme.onSurface.withOpacity(0.7),
                        size: 20,
                      ),
                      if (widget.isFiltered)
                        Positioned(
                          right: -2,
                          top: -2,
                          child: Container(
                            width: 8,
                            height: 8,
                            decoration: const BoxDecoration(
                              color: AppColors.accent,
                              shape: BoxShape.circle,
                            ),
                          ),
                        ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  String _getSearchHint(String language) {
    switch (language) {
      case 'ta':
        return 'à®ªà®¾à®Ÿà®²à¯à®•à®³à¯, à®ªà®¾à®Ÿà®•à®°à¯, à®Žà®´à¯à®¤à¯à®¤à®¾à®³à®°à¯ à®¤à¯‡à®Ÿà¯à®™à¯à®•à®³à¯...';
      case 'te':
        return 'à°ªà°¾à°Ÿà°²à±, à°—à°¾à°¯à°•à±à°¡à±, à°°à°šà°¯à°¿à°¤ à°µà±†à°¤à°•à°‚à°¡à°¿...';
      case 'en':
      default:
        return 'Search songs, singer, writer...';
    }
  }
}

// Search Suggestions Widget
class SearchSuggestions extends StatelessWidget {
  final List<String> suggestions;
  final Function(String) onSuggestionTapped;

  const SearchSuggestions({
    Key? key,
    required this.suggestions,
    required this.onSuggestionTapped,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    if (suggestions.isEmpty) return const SizedBox.shrink();

    return Container(
      margin: const EdgeInsets.symmetric(horizontal: AppConstants.paddingMedium),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(AppConstants.borderRadiusMedium),
        boxShadow: [
          BoxShadow(
            color: theme.shadowColor.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: ListView.separated(
        shrinkWrap: true,
        physics: const NeverScrollableScrollPhysics(),
        itemCount: suggestions.length > 5 ? 5 : suggestions.length,
        separatorBuilder: (context, index) => Divider(
          height: 1,
          color: theme.colorScheme.outline.withOpacity(0.2),
        ),
        itemBuilder: (context, index) {
          final suggestion = suggestions[index];
          return ListTile(
            dense: true,
            leading: Icon(
              Icons.search,
              size: 16,
              color: theme.colorScheme.onSurface.withOpacity(0.6),
            ),
            title: Text(
              suggestion,
              style: AppTextStyles.body2.copyWith(
                color: theme.colorScheme.onSurface,
              ),
            ),
            onTap: () => onSuggestionTapped(suggestion),
          );
        },
      ),
    );
  }
}

// Quick Filter Chips
class QuickFilterChips extends StatelessWidget {
  final List<String> selectedFilters;
  final Function(String) onFilterToggle;

  const QuickFilterChips({
    Key? key,
    required this.selectedFilters,
    required this.onFilterToggle,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final languageProvider = Provider.of<LanguageProvider>(context);
    
    final filterOptions = _getFilterOptions(languageProvider.currentLanguage);

    return Container(
      height: 50,
      padding: const EdgeInsets.symmetric(horizontal: AppConstants.paddingMedium),
      child: ListView.separated(
        scrollDirection: Axis.horizontal,
        itemCount: filterOptions.length,
        separatorBuilder: (context, index) => 
            const SizedBox(width: AppConstants.spacingSmall),
        itemBuilder: (context, index) {
          final filter = filterOptions[index];
          final isSelected = selectedFilters.contains(filter['key']);
          
          return FilterChip(
            label: Text(
              filter['label'],
              style: AppTextStyles.caption.copyWith(
                color: isSelected 
                    ? Colors.white 
                    : theme.colorScheme.onSurface,
                fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
              ),
            ),
            selected: isSelected,
            onSelected: (selected) => onFilterToggle(filter['key']),
            backgroundColor: theme.colorScheme.surface,
            selectedColor: AppColors.primary,
            checkmarkColor: Colors.white,
            side: BorderSide(
              color: isSelected 
                  ? AppColors.primary 
                  : theme.colorScheme.outline.withOpacity(0.3),
            ),
          );
        },
      ),
    );
  }

  List<Map<String, String>> _getFilterOptions(String language) {
    switch (language) {
      case 'ta':
        return [
          {'key': 'popular', 'label': 'à®ªà®¿à®°à®ªà®²à®®à®¾à®©'},
          {'key': 'devotional', 'label': 'à®ªà®•à¯à®¤à®¿'},
          {'key': 'festival', 'label': 'à®¤à®¿à®°à¯à®µà®¿à®´à®¾'},
          {'key': 'mantra', 'label': 'à®®à®¨à¯à®¤à®¿à®°à®®à¯'},
          {'key': 'recent', 'label': 'à®šà®®à¯€à®ªà®¤à¯à®¤à®¿à®¯'},
        ];
      case 'te':
        return [
          {'key': 'popular', 'label': 'à°ªà±à°°à°®à±à°–'},
          {'key': 'devotional', 'label': 'à°­à°•à±à°¤à°¿'},
          {'key': 'festival', 'label': 'à°ªà°‚à°¡à±à°—'},
          {'key': 'mantra', 'label': 'à°®à°‚à°¤à±à°°à°‚'},
          {'key': 'recent', 'label': 'à°‡à°Ÿà±€à°µà°²à°¿'},
        ];
      case 'en':
      default:
        return [
          {'key': 'popular', 'label': 'Popular'},
          {'key': 'devotional', 'label': 'Devotional'},
          {'key': 'festival', 'label': 'Festival'},
          {'key': 'mantra', 'label': 'Mantra'},
          {'key': 'recent', 'label': 'Recent'},
        ];
    }
  }
}
//widgets/songs/song_list_item_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../models/song_model.dart';
import '../../providers/favorites_provider.dart';
import '../../providers/language_provider.dart';
import '../../pages/song_view_page.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';

class SongListItem extends StatefulWidget {
  final Song song;
  final bool showDivider;
  final bool isCompact;
  final VoidCallback? onTap;

  const SongListItem({
    Key? key,
    required this.song,
    this.showDivider = true,
    this.isCompact = false,
    this.onTap,
  }) : super(key: key);

  @override
  State<SongListItem> createState() => _SongListItemState();
}

class _SongListItemState extends State<SongListItem>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;
  late Animation<double> _favoriteAnimation;
  bool _isPressed = false;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 1.0,
      end: 0.95,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    ));

    _favoriteAnimation = Tween<double>(
      begin: 1.0,
      end: 1.2,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.elasticOut,
    ));
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  void _handleTapDown(TapDownDetails details) {
    setState(() => _isPressed = true);
    _animationController.forward();
  }

  void _handleTapUp(TapUpDetails details) {
    setState(() => _isPressed = false);
    _animationController.reverse();
  }

  void _handleTapCancel() {
    setState(() => _isPressed = false);
    _animationController.reverse();
  }

  void _navigateToSongView() {
    if (widget.onTap != null) {
      widget.onTap!();
    } else {
      Navigator.push(
        context,
        PageRouteBuilder(
          pageBuilder: (context, animation, secondaryAnimation) =>
              SongViewPage(song: widget.song),
          transitionsBuilder: (context, animation, secondaryAnimation, child) {
            return FadeTransition(opacity: animation, child: child);
          },
          transitionDuration: const Duration(milliseconds: 300),
        ),
      );
    }
  }

  void _toggleFavorite() {
    final favoritesProvider = Provider.of<FavoritesProvider>(context, listen: false);
    favoritesProvider.toggleFavorite(widget.song.id);
    
    // Animate favorite button
    _animationController.forward().then((_) {
      _animationController.reverse();
    });

    // Show snackbar
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(
          favoritesProvider.isFavorite(widget.song.id)
              ? 'Added to favorites'
              : 'Removed from favorites',
        ),
        duration: const Duration(seconds: 1),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final languageProvider = Provider.of<LanguageProvider>(context);
    final favoritesProvider = Provider.of<FavoritesProvider>(context);
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final isFavorite = favoritesProvider.isFavorite(widget.song.id);

    return AnimatedBuilder(
      animation: _scaleAnimation,
      builder: (context, child) {
        return Transform.scale(
          scale: _scaleAnimation.value,
          child: Container(
            margin: EdgeInsets.symmetric(
              horizontal: widget.isCompact ? 8 : 16,
              vertical: widget.isCompact ? 4 : 8,
            ),
            decoration: BoxDecoration(
              color: _isPressed
                  ? (isDark ? AppColors.cardDark.withOpacity(0.8) : AppColors.cardLight.withOpacity(0.8))
                  : (isDark ? AppColors.cardDark : AppColors.cardLight),
              borderRadius: BorderRadius.circular(widget.isCompact ? 8 : 12),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(isDark ? 0.3 : 0.1),
                  blurRadius: _isPressed ? 4 : 8,
                  offset: Offset(0, _isPressed ? 1 : 2),
                ),
              ],
            ),
            child: Material(
              color: Colors.transparent,
              child: InkWell(
                onTap: _navigateToSongView,
                onTapDown: _handleTapDown,
                onTapUp: _handleTapUp,
                onTapCancel: _handleTapCancel,
                borderRadius: BorderRadius.circular(widget.isCompact ? 8 : 12),
                child: Padding(
                  padding: EdgeInsets.all(widget.isCompact ? 12 : 16),
                  child: widget.isCompact ? _buildCompactLayout(languageProvider, isFavorite, isDark) : _buildFullLayout(languageProvider, isFavorite, isDark),
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildFullLayout(LanguageProvider languageProvider, bool isFavorite, bool isDark) {
    return Row(
      children: [
        // Song Icon
        Container(
          width: 56,
          height: 56,
          decoration: BoxDecoration(
            gradient: widget.song.iconType == 'music'
                ? const LinearGradient(
                    colors: [AppColors.primaryOrange, AppColors.accentGold],
                  )
                : const LinearGradient(
                    colors: [AppColors.deepPurple, AppColors.primaryOrange],
                  ),
            borderRadius: BorderRadius.circular(28),
            boxShadow: [
              BoxShadow(
                color: AppColors.primaryOrange.withOpacity(0.3),
                blurRadius: 8,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Icon(
            widget.song.iconType == 'music' ? Icons.music_note : Icons.temple_hindu,
            color: Colors.white,
            size: 28,
          ),
        ),
        
        const SizedBox(width: 16),
        
        // Song Details
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Title
              Text(
                _getLocalizedTitle(languageProvider.currentLanguage),
                style: AppTextStyles.headingSmall.copyWith(
                  color: isDark ? Colors.white : AppColors.textPrimary,
                  fontWeight: FontWeight.w600,
                ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
              
              const SizedBox(height: 4),
              
              // Singer
              if (widget.song.singer.isNotEmpty)
                Text(
                  'By ${widget.song.singer}',
                  style: AppTextStyles.bodySmall.copyWith(
                    color: isDark ? Colors.white70 : AppColors.textSecondary,
                    fontWeight: FontWeight.w500,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
              
              const SizedBox(height: 2),
              
              // Writer
              if (widget.song.writer.isNotEmpty)
                Text(
                  'Written by ${widget.song.writer}',
                  style: AppTextStyles.bodySmall.copyWith(
                    color: isDark ? Colors.white60 : AppColors.textTertiary,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
              
              const SizedBox(height: 8),
              
              // Language indicators
              Row(
                children: [
                  _buildLanguageChip('TA', isDark),
                  const SizedBox(width: 4),
                  _buildLanguageChip('TE', isDark),
                  const SizedBox(width: 4),
                  _buildLanguageChip('EN', isDark),
                  const Spacer(),
                  
                  // Lines count
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                    decoration: BoxDecoration(
                      color: AppColors.primaryOrange.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      '${_getLineCount()} lines',
                      style: AppTextStyles.bodySmall.copyWith(
                        color: AppColors.primaryOrange,
                        fontSize: 10,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
        
        const SizedBox(width: 12),
        
        // Favorite Button
        AnimatedBuilder(
          animation: _favoriteAnimation,
          builder: (context, child) {
            return Transform.scale(
              scale: _favoriteAnimation.value,
              child: IconButton(
                onPressed: _toggleFavorite,
                icon: Icon(
                  isFavorite ? Icons.favorite : Icons.favorite_border,
                  color: isFavorite ? Colors.red : (isDark ? Colors.white54 : AppColors.textSecondary),
                  size: 24,
                ),
                splashRadius: 20,
                tooltip: isFavorite ? 'Remove from favorites' : 'Add to favorites',
              ),
            );
          },
        ),
      ],
    );
  }

  Widget _buildCompactLayout(LanguageProvider languageProvider, bool isFavorite, bool isDark) {
    return Row(
      children: [
        // Compact Icon
        Container(
          width: 40,
          height: 40,
          decoration: BoxDecoration(
            gradient: widget.song.iconType == 'music'
                ? const LinearGradient(
                    colors: [AppColors.primaryOrange, AppColors.accentGold],
                  )
                : const LinearGradient(
                    colors: [AppColors.deepPurple, AppColors.primaryOrange],
                  ),
            borderRadius: BorderRadius.circular(20),
          ),
          child: Icon(
            widget.song.iconType == 'music' ? Icons.music_note : Icons.temple_hindu,
            color: Colors.white,
            size: 20,
          ),
        ),
        
        const SizedBox(width: 12),
        
        // Compact Details
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                _getLocalizedTitle(languageProvider.currentLanguage),
                style: AppTextStyles.bodyMedium.copyWith(
                  color: isDark ? Colors.white : AppColors.textPrimary,
                  fontWeight: FontWeight.w600,
                ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
              if (widget.song.singer.isNotEmpty)
                Text(
                  widget.song.singer,
                  style: AppTextStyles.bodySmall.copyWith(
                    color: isDark ? Colors.white70 : AppColors.textSecondary,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
            ],
          ),
        ),
        
        // Compact Favorite
        IconButton(
          onPressed: _toggleFavorite,
          icon: Icon(
            isFavorite ? Icons.favorite : Icons.favorite_border,
            color: isFavorite ? Colors.red : (isDark ? Colors.white54 : AppColors.textSecondary),
            size: 20,
          ),
          constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
          splashRadius: 16,
        ),
      ],
    );
  }

  Widget _buildLanguageChip(String language, bool isDark) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: isDark ? Colors.white.withOpacity(0.1) : Colors.black.withOpacity(0.05),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: isDark ? Colors.white.withOpacity(0.2) : Colors.black.withOpacity(0.1),
          width: 0.5,
        ),
      ),
      child: Text(
        language,
        style: AppTextStyles.bodySmall.copyWith(
          color: isDark ? Colors.white70 : AppColors.textSecondary,
          fontSize: 9,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }

  String _getLocalizedTitle(String language) {
    switch (language) {
      case 'ta':
        return widget.song.titleTamil.isNotEmpty ? widget.song.titleTamil : widget.song.title;
      case 'te':
        return widget.song.titleTelugu.isNotEmpty ? widget.song.titleTelugu : widget.song.title;
      default:
        return widget.song.title;
    }
  }

  int _getLineCount() {
    // Count lines from the current language lyrics
    final languageProvider = Provider.of<LanguageProvider>(context, listen: false);
    String lyrics = '';
    
    switch (languageProvider.currentLanguage) {
      case 'ta':
        lyrics = widget.song.lyricsTamil;
        break;
      case 'te':
        lyrics = widget.song.lyricsTelugu;
        break;
      case 'en_ta':
        lyrics = widget.song.lyricsEnglishTamil;
        break;
      case 'en_te':
        lyrics = widget.song.lyricsEnglishTelugu;
        break;
      default:
        lyrics = widget.song.lyricsTamil;
    }
    
    return lyrics.split('\n').where((line) => line.trim().isNotEmpty).length;
  }
}
//widgets/songs/sort_options.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/language_provider.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';

enum SortField { title, singer, writer, dateAdded, popularity }
enum SortOrder { ascending, descending }

class SortOptions extends StatefulWidget {
  final SortField currentSortField;
  final SortOrder currentSortOrder;
  final Function(SortField, SortOrder) onSortChanged;

  const SortOptions({
    Key? key,
    required this.currentSortField,
    required this.currentSortOrder,
    required this.onSortChanged,
  }) : super(key: key);

  @override
  State<SortOptions> createState() => _SortOptionsState();
}

class _SortOptionsState extends State<SortOptions>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;
  late Animation<Offset> _slideAnimation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeOut),
    );
    _slideAnimation = Tween<Offset>(
      begin: const Offset(0, -0.5),
      end: Offset.zero,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeOutBack,
    ));
    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final languageProvider = Provider.of<LanguageProvider>(context);

    return SlideTransition(
      position: _slideAnimation,
      child: FadeTransition(
        opacity: _fadeAnimation,
        child: Container(
          margin: const EdgeInsets.all(AppConstants.paddingMedium),
          decoration: BoxDecoration(
            color: theme.colorScheme.surface,
            borderRadius: BorderRadius.circular(AppConstants.borderRadiusLarge),
            boxShadow: [
              BoxShadow(
                color: theme.shadowColor.withOpacity(0.15),
                blurRadius: 20,
                offset: const Offset(0, 8),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Header
              Container(
                padding: const EdgeInsets.all(AppConstants.paddingMedium),
                decoration: BoxDecoration(
                  color: AppColors.primary.withOpacity(0.1),
                  borderRadius: const BorderRadius.only(
                    topLeft: Radius.circular(AppConstants.borderRadiusLarge),
                    topRight: Radius.circular(AppConstants.borderRadiusLarge),
                  ),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.sort,
                      color: AppColors.primary,
                      size: 24,
                    ),
                    const SizedBox(width: AppConstants.spacingSmall),
                    Text(
                      _getSortTitle(languageProvider.currentLanguage),
                      style: AppTextStyles.h3.copyWith(
                        color: AppColors.primary,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const Spacer(),
                    IconButton(
                      onPressed: () => Navigator.of(context).pop(),
                      icon: Icon(
                        Icons.close,
                        color: theme.colorScheme.onSurface.withOpacity(0.6),
                      ),
                    ),
                  ],
                ),
              ),

              // Sort Field Options
              Padding(
                padding: const EdgeInsets.all(AppConstants.paddingMedium),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      _getSortByTitle(languageProvider.currentLanguage),
                      style: AppTextStyles.h4.copyWith(
                        color: theme.colorScheme.onSurface,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: AppConstants.spacingMedium),
                    ...SortField.values.map((field) => _buildSortFieldOption(
                      context,
                      field,
                      languageProvider.currentLanguage,
                    )),
                  ],
                ),
              ),

              // Sort Order Toggle
              Container(
                margin: const EdgeInsets.symmetric(
                  horizontal: AppConstants.paddingMedium,
                ),
                padding: const EdgeInsets.all(AppConstants.paddingSmall),
                decoration: BoxDecoration(
                  color: theme.colorScheme.surface,
                  borderRadius: BorderRadius.circular(AppConstants.borderRadiusMedium),
                  border: Border.all(
                    color: theme.colorScheme.outline.withOpacity(0.2),
                  ),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.swap_vert,
                      color: theme.colorScheme.onSurface.withOpacity(0.7),
                      size: 20,
                    ),
                    const SizedBox(width: AppConstants.spacingSmall),
                    Text(
                      _getSortOrderTitle(languageProvider.currentLanguage),
                      style: AppTextStyles.body2.copyWith(
                        color: theme.colorScheme.onSurface,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                    const Spacer(),
                    _buildSortOrderToggle(context, languageProvider.currentLanguage),
                  ],
                ),
              ),

              const SizedBox(height: AppConstants.paddingMedium),

              // Apply Button
              Container(
                width: double.infinity,
                margin: const EdgeInsets.symmetric(
                  horizontal: AppConstants.paddingMedium,
                ),
                child: ElevatedButton(
                  onPressed: () => Navigator.of(context).pop(),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppColors.primary,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(
                      vertical: AppConstants.paddingMedium,
                    ),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(AppConstants.borderRadiusMedium),
                    ),
                    elevation: 2,
                  ),
                  child: Text(
                    _getApplyButtonTitle(languageProvider.currentLanguage),
                    style: AppTextStyles.button.copyWith(
                      color: Colors.white,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ),

              const SizedBox(height: AppConstants.paddingMedium),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSortFieldOption(BuildContext context, SortField field, String language) {
    final theme = Theme.of(context);
    final isSelected = widget.currentSortField == field;

    return Container(
      margin: const EdgeInsets.only(bottom: AppConstants.spacingSmall),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: () {
            widget.onSortChanged(field, widget.currentSortOrder);
          },
          borderRadius: BorderRadius.circular(AppConstants.borderRadiusMedium),
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 200),
            padding: const EdgeInsets.symmetric(
              horizontal: AppConstants.paddingMedium,
              vertical: AppConstants.paddingSmall,
            ),
            decoration: BoxDecoration(
              color: isSelected 
                  ? AppColors.primary.withOpacity(0.1) 
                  : Colors.transparent,
              borderRadius: BorderRadius.circular(AppConstants.borderRadiusMedium),
              border: Border.all(
                color: isSelected 
                    ? AppColors.primary 
                    : Colors.transparent,
                width: 2,
              ),
            ),
            child: Row(
              children: [
                AnimatedContainer(
                  duration: const Duration(milliseconds: 200),
                  width: 20,
                  height: 20,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    color: isSelected ? AppColors.primary : Colors.transparent,
                    border: Border.all(
                      color: isSelected 
                          ? AppColors.primary 
                          : theme.colorScheme.outline.withOpacity(0.5),
                      width: 2,
                    ),
                  ),
                  child: isSelected
                      ? const Icon(
                          Icons.check,
                          size: 12,
                          color: Colors.white,
                        )
                      : null,
                ),
                const SizedBox(width: AppConstants.spacingMedium),
                Icon(
                  _getSortFieldIcon(field),
                  color: isSelected 
                      ? AppColors.primary 
                      : theme.colorScheme.onSurface.withOpacity(0.6),
                  size: 20,
                ),
                const SizedBox(width: AppConstants.spacingSmall),
                Text(
                  _getSortFieldTitle(field, language),
                  style: AppTextStyles.body1.copyWith(
                    color: isSelected 
                        ? AppColors.primary 
                        : theme.colorScheme.onSurface,
                    fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildSortOrderToggle(BuildContext context, String language) {
    final theme = Theme.of(context);

    return Container(
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(AppConstants.borderRadiusSmall),
        border: Border.all(
          color: theme.colorScheme.outline.withOpacity(0.3),
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildOrderOption(
            context,
            SortOrder.ascending,
            Icons.arrow_upward,
            _getAscendingTitle(language),
            language,
          ),
          _buildOrderOption(
            context,
            SortOrder.descending,
            Icons.arrow_downward,
            _getDescendingTitle(language),
            language,
          ),
        ],
      ),
    );
  }

  Widget _buildOrderOption(BuildContext context, SortOrder order, IconData icon, 
      String title, String language) {
    final theme = Theme.of(context);
    final isSelected = widget.currentSortOrder == order;

    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: () {
          widget.onSortChanged(widget.currentSortField, order);
        },
        borderRadius: BorderRadius.circular(AppConstants.borderRadiusSmall),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          padding: const EdgeInsets.symmetric(
            horizontal: AppConstants.paddingSmall,
            vertical: AppConstants.paddingXS,
          ),
          decoration: BoxDecoration(
            color: isSelected ? AppColors.primary : Colors.transparent,
            borderRadius: BorderRadius.circular(AppConstants.borderRadiusSmall),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                icon,
                size: 16,
                color: isSelected 
                    ? Colors.white 
                    : theme.colorScheme.onSurface.withOpacity(0.6),
              ),
              const SizedBox(width: 4),
              Text(
                title,
                style: AppTextStyles.caption.copyWith(
                  color: isSelected 
                      ? Colors.white 
                      : theme.colorScheme.onSurface,
                  fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  IconData _getSortFieldIcon(SortField field) {
    switch (field) {
      case SortField.title:
        return Icons.title;
      case SortField.singer:
        return Icons.person;
      case SortField.writer:
        return Icons.edit;
      case SortField.dateAdded:
        return Icons.access_time;
      case SortField.popularity:
        return Icons.trending_up;
    }
  }

  String _getSortTitle(String language) {
    switch (language) {
      case 'ta':
        return 'à®µà®°à®¿à®šà¯ˆà®ªà¯à®ªà®Ÿà¯à®¤à¯à®¤à¯';
      case 'te':
        return 'à°•à±à°°à°®à°¬à°¦à±à°§à±€à°•à°°à°¿à°‚à°šà±';
      case 'en':
      default:
        return 'Sort Options';
    }
  }

  String _getSortByTitle(String language) {
    switch (language) {
      case 'ta':
        return 'à®‡à®¤à®©à¯ à®…à®Ÿà®¿à®ªà¯à®ªà®Ÿà¯ˆà®¯à®¿à®²à¯ à®µà®°à®¿à®šà¯ˆà®ªà¯à®ªà®Ÿà¯à®¤à¯à®¤à¯:';
      case 'te':
        return 'à°¦à±€à°¨à°¿ à°†à°§à°¾à°°à°‚à°—à°¾ à°•à±à°°à°®à°¬à°¦à±à°§à±€à°•à°°à°¿à°‚à°šà±:';
      case 'en':
      default:
        return 'Sort by:';
    }
  }

  String _getSortOrderTitle(String language) {
    switch (language) {
      case 'ta':
        return 'à®µà®°à®¿à®šà¯ˆ:';
      case 'te':
        return 'à°•à±à°°à°®à°‚:';
      case 'en':
      default:
        return 'Order:';
    }
  }

  String _getApplyButtonTitle(String language) {
    switch (language) {
      case 'ta':
        return 'à®ªà®¯à®©à¯à®ªà®Ÿà¯à®¤à¯à®¤à¯';
      case 'te':
        return 'à°µà°°à±à°¤à°¿à°‚à°šà±';
      case 'en':
      default:
        return 'Apply';
    }
  }

  String _getSortFieldTitle(SortField field, String language) {
    switch (language) {
      case 'ta':
        switch (field) {
          case SortField.title:
            return 'à®¤à®²à¯ˆà®ªà¯à®ªà¯';
          case SortField.singer:
            return 'à®ªà®¾à®Ÿà®•à®°à¯';
          case SortField.writer:
            return 'à®Žà®´à¯à®¤à¯à®¤à®¾à®³à®°à¯';
          case SortField.dateAdded:
            return 'à®šà¯‡à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿ à®¤à¯‡à®¤à®¿';
          case SortField.popularity:
            return 'à®ªà®¿à®°à®ªà®²à®®à¯';
        }
      case 'te':
        switch (field) {
          case SortField.title:
            return 'à°¶à±€à°°à±à°·à°¿à°•';
          case SortField.singer:
            return 'à°—à°¾à°¯à°•à±à°¡à±';
          case SortField.writer:
            return 'à°°à°šà°¯à°¿à°¤';
          case SortField.dateAdded:
            return 'à°œà±‹à°¡à°¿à°‚à°šà°¿à°¨ à°¤à±‡à°¦à±€';
          case SortField.popularity:
            return 'à°ªà±à°°à°¾à°šà±à°°à±à°¯à°‚';
        }
      case 'en':
      default:
        switch (field) {
          case SortField.title:
            return 'Title';
          case SortField.singer:
            return 'Singer';
          case SortField.writer:
            return 'Writer';
          case SortField.dateAdded:
            return 'Date Added';
          case SortField.popularity:
            return 'Popularity';
        }
    }
  }

  String _getAscendingTitle(String language) {
    switch (language) {
      case 'ta':
        return 'à®à®±à¯';
      case 'te':
        return 'à°†à°°à±‹à°¹à°£';
      case 'en':
      default:
        return 'A-Z';
    }
  }

  String _getDescendingTitle(String language) {
    switch (language) {
      case 'ta':
        return 'à®‡à®±à®™à¯à®•à¯';
      case 'te':
        return 'à°…à°µà°°à±‹à°¹à°£';
      case 'en':
      default:
        return 'Z-A';
    }
  }
}

// Sort Button Widget for triggering the sort modal
class SortButton extends StatelessWidget {
  final SortField currentSortField;
  final SortOrder currentSortOrder;
  final VoidCallback onPressed;

  const SortButton({
    Key? key,
    required this.currentSortField,
    required this.currentSortOrder,
    required this.onPressed,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final languageProvider = Provider.of<LanguageProvider>(context);

    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onPressed,
        borderRadius: BorderRadius.circular(AppConstants.borderRadiusMedium),
        child: Container(
          padding: const EdgeInsets.symmetric(
            horizontal: AppConstants.paddingSmall,
            vertical: AppConstants.paddingXS,
          ),
          decoration: BoxDecoration(
            color: theme.colorScheme.surface.withOpacity(0.8),
            borderRadius: BorderRadius.circular(AppConstants.borderRadiusMedium),
            border: Border.all(
              color: theme.colorScheme.outline.withOpacity(0.3),
            ),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                currentSortOrder == SortOrder.ascending 
                    ? Icons.arrow_upward 
                    : Icons.arrow_downward,
                size: 16,
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
              const SizedBox(width: 4),
              Text(
                _getSortFieldAbbreviation(currentSortField, languageProvider.currentLanguage),
                style: AppTextStyles.caption.copyWith(
                  color: theme.colorScheme.onSurface,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _getSortFieldAbbreviation(SortField field, String language) {
    switch (language) {
      case 'ta':
        switch (field) {
          case SortField.title:
            return 'à®¤à®²à¯ˆ';
          case SortField.singer:
            return 'à®ªà®¾à®Ÿà®•à®°à¯';
          case SortField.writer:
            return 'à®Žà®´à¯à®¤à¯à®¤à¯';
          case SortField.dateAdded:
            return 'à®¤à¯‡à®¤à®¿';
          case SortField.popularity:
            return 'à®ªà®¿à®°à®ªà®²à®®à¯';
        }
      case 'te':
        switch (field) {
          case SortField.title:
            return 'à°¶à±€à°°à±à°·à°¿à°•';
          case SortField.singer:
            return 'à°—à°¾à°¯à°•à±à°¡à±';
          case SortField.writer:
            return 'à°°à°šà°¯à°¿à°¤';
          case SortField.dateAdded:
            return 'à°¤à±‡à°¦à±€';
          case SortField.popularity:
            return 'à°ªà±à°°à°¾à°šà±à°°à±à°¯à°‚';
        }
      case 'en':
      default:
        switch (field) {
          case SortField.title:
            return 'Title';
          case SortField.singer:
            return 'Singer';
          case SortField.writer:
            return 'Writer';
          case SortField.dateAdded:
            return 'Date';
          case SortField.popularity:
            return 'Popular';
        }
    }
  }
}
//widgets/song_view/audio_player_widget.dart
import 'package:flutter/material.dart';
import 'package:audioplayers/audioplayers.dart';
import '../../../utils/constants.dart';
import '../../../utils/text_styles.dart';
import '../../../models/song_model.dart';

class AudioPlayerWidget extends StatefulWidget {
  final Song song;
  final VoidCallback? onFavoriteToggle;
  final bool isFavorite;

  const AudioPlayerWidget({
    Key? key,
    required this.song,
    this.onFavoriteToggle,
    this.isFavorite = false,
  }) : super(key: key);

  @override
  State<AudioPlayerWidget> createState() => _AudioPlayerWidgetState();
}

class _AudioPlayerWidgetState extends State<AudioPlayerWidget>
    with TickerProviderStateMixin {
  late AudioPlayer _audioPlayer;
  bool _isPlaying = false;
  bool _isLoading = false;
  Duration _duration = Duration.zero;
  Duration _position = Duration.zero;
  
  late AnimationController _playButtonController;
  late AnimationController _waveformController;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _audioPlayer = AudioPlayer();
    _initializeAnimations();
    _setupAudioPlayer();
  }

  void _initializeAnimations() {
    _playButtonController = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );
    
    _waveformController = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );
    
    _scaleAnimation = Tween<double>(
      begin: 1.0,
      end: 1.1,
    ).animate(CurvedAnimation(
      parent: _playButtonController,
      curve: Curves.easeInOut,
    ));

    if (_isPlaying) {
      _waveformController.repeat();
    }
  }

  void _setupAudioPlayer() {
    _audioPlayer.onDurationChanged.listen((duration) {
      if (mounted) {
        setState(() {
          _duration = duration;
        });
      }
    });

    _audioPlayer.onPositionChanged.listen((position) {
      if (mounted) {
        setState(() {
          _position = position;
        });
      }
    });

    _audioPlayer.onPlayerStateChanged.listen((state) {
      if (mounted) {
        setState(() {
          _isPlaying = state == PlayerState.playing;
          _isLoading = state == PlayerState.stopped && _position == Duration.zero;
        });
        
        if (_isPlaying) {
          _waveformController.repeat();
          _playButtonController.forward();
        } else {
          _waveformController.stop();
          _playButtonController.reverse();
        }
      }
    });
  }

  @override
  void dispose() {
    _audioPlayer.dispose();
    _playButtonController.dispose();
    _waveformController.dispose();
    super.dispose();
  }

  Future<void> _togglePlayPause() async {
    try {
      if (_isPlaying) {
        await _audioPlayer.pause();
      } else {
        // For demo purposes, we'll simulate audio playback
        // In real implementation, use: await _audioPlayer.play(UrlSource(widget.song.audioUrl));
        await _simulateAudioPlayback();
      }
    } catch (e) {
      _showError('Failed to play audio');
    }
  }

  Future<void> _simulateAudioPlayback() async {
    // Simulate audio playback for demo
    setState(() {
      _isPlaying = true;
      _duration = const Duration(minutes: 4, seconds: 30); // Demo duration
    });
    
    // Simulate position updates
    _startPositionTimer();
  }

  void _startPositionTimer() {
    Future.delayed(const Duration(seconds: 1), () {
      if (_isPlaying && mounted) {
        setState(() {
          _position = Duration(seconds: _position.inSeconds + 1);
          if (_position >= _duration) {
            _position = Duration.zero;
            _isPlaying = false;
          }
        });
        if (_isPlaying) _startPositionTimer();
      }
    });
  }

  void _showError(String message) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(message),
          backgroundColor: AppColors.error,
        ),
      );
    }
  }

  void _seek(double value) {
    final position = Duration(seconds: (value * _duration.inSeconds).round());
    _audioPlayer.seek(position);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      margin: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: isDark
              ? [
                  AppColors.surfaceDark.withOpacity(0.9),
                  AppColors.surfaceDark.withOpacity(0.7),
                ]
              : [
                  AppColors.surface.withOpacity(0.9),
                  AppColors.surface.withOpacity(0.7),
                ],
        ),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
          color: AppColors.primary.withOpacity(0.2),
          width: 1,
        ),
        boxShadow: [
          BoxShadow(
            color: AppColors.shadow.withOpacity(0.1),
            blurRadius: 20,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildSongInfo(),
            const SizedBox(height: 20),
            _buildWaveform(),
            const SizedBox(height: 16),
            _buildProgressBar(),
            const SizedBox(height: 20),
            _buildControls(),
          ],
        ),
      ),
    );
  }

  Widget _buildSongInfo() {
    return Row(
      children: [
        Container(
          width: 60,
          height: 60,
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [AppColors.primary, AppColors.secondary],
            ),
            borderRadius: BorderRadius.circular(12),
          ),
          child: Icon(
            widget.song.iconType == 'music' ? Icons.music_note : Icons.temple_hindu,
            color: Colors.white,
            size: 28,
          ),
        ),
        const SizedBox(width: 16),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                widget.song.title,
                style: AppTextStyles.headingMedium,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
              const SizedBox(height: 4),
              Text(
                'Singer: ${widget.song.singer}',
                style: AppTextStyles.bodyMedium.copyWith(
                  color: AppColors.textSecondary,
                ),
              ),
              if (widget.song.writer.isNotEmpty) ...[
                Text(
                  'Writer: ${widget.song.writer}',
                  style: AppTextStyles.bodySmall.copyWith(
                    color: AppColors.textSecondary,
                  ),
                ),
              ],
            ],
          ),
        ),
        IconButton(
          onPressed: widget.onFavoriteToggle,
          icon: AnimatedSwitcher(
            duration: const Duration(milliseconds: 200),
            child: Icon(
              widget.isFavorite ? Icons.favorite : Icons.favorite_border,
              key: ValueKey(widget.isFavorite),
              color: widget.isFavorite ? AppColors.error : AppColors.textSecondary,
              size: 24,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildWaveform() {
    return Container(
      height: 60,
      decoration: BoxDecoration(
        color: AppColors.primary.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: List.generate(30, (index) {
          return AnimatedBuilder(
            animation: _waveformController,
            builder: (context, child) {
              final height = _isPlaying
                  ? 20 + (30 * (0.5 + 0.5 * 
                    (1 + (index * 0.1 + _waveformController.value * 2 * 3.14159).sin()) / 2))
                  : 20.0;
              
              return Container(
                width: 3,
                height: height,
                decoration: BoxDecoration(
                  color: AppColors.primary.withOpacity(
                    _isPlaying ? 0.8 : 0.4,
                  ),
                  borderRadius: BorderRadius.circular(2),
                ),
              );
            },
          );
        }),
      ),
    );
  }

  Widget _buildProgressBar() {
    return Column(
      children: [
        SliderTheme(
          data: SliderTheme.of(context).copyWith(
            trackHeight: 4,
            thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 8),
            overlayShape: const RoundSliderOverlayShape(overlayRadius: 16),
            activeTrackColor: AppColors.primary,
            inactiveTrackColor: AppColors.primary.withOpacity(0.2),
            thumbColor: AppColors.primary,
            overlayColor: AppColors.primary.withOpacity(0.2),
          ),
          child: Slider(
            value: _duration.inSeconds > 0
                ? _position.inSeconds / _duration.inSeconds
                : 0.0,
            onChanged: _seek,
          ),
        ),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                _formatDuration(_position),
                style: AppTextStyles.bodySmall.copyWith(
                  color: AppColors.textSecondary,
                ),
              ),
              Text(
                _formatDuration(_duration),
                style: AppTextStyles.bodySmall.copyWith(
                  color: AppColors.textSecondary,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildControls() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        IconButton(
          onPressed: () {
            _seek(0.0);
          },
          icon: const Icon(Icons.replay_10),
          iconSize: 32,
          color: AppColors.primary,
        ),
        const SizedBox(width: 20),
        ScaleTransition(
          scale: _scaleAnimation,
          child: Container(
            width: 64,
            height: 64,
            decoration: BoxDecoration(
              gradient: LinearGradient(
                colors: [AppColors.primary, AppColors.secondary],
              ),
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(
                  color: AppColors.primary.withOpacity(0.3),
                  blurRadius: 12,
                  offset: const Offset(0, 4),
                ),
              ],
            ),
            child: IconButton(
              onPressed: _isLoading ? null : _togglePlayPause,
              icon: _isLoading
                  ? const SizedBox(
                      width: 24,
                      height: 24,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                      ),
                    )
                  : Icon(
                      _isPlaying ? Icons.pause : Icons.play_arrow,
                      color: Colors.white,
                      size: 32,
                    ),
            ),
          ),
        ),
        const SizedBox(width: 20),
        IconButton(
          onPressed: () {
            final newPosition = _position + const Duration(seconds: 10);
            if (newPosition <= _duration) {
              _seek(newPosition.inSeconds / _duration.inSeconds);
            }
          },
          icon: const Icon(Icons.forward_10),
          iconSize: 32,
          color: AppColors.primary,
        ),
      ],
    );
  }

  String _formatDuration(Duration duration) {
    String twoDigits(int n) => n.toString().padLeft(2, '0');
    final minutes = twoDigits(duration.inMinutes.remainder(60));
    final seconds = twoDigits(duration.inSeconds.remainder(60));
    return '$minutes:$seconds';
  }
}

class MiniAudioPlayer extends StatelessWidget {
  final Song song;
  final bool isPlaying;
  final VoidCallback onPlayPause;
  final VoidCallback onTap;

  const MiniAudioPlayer({
    Key? key,
    required this.song,
    required this.isPlaying,
    required this.onPlayPause,
    required this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return GestureDetector(
      onTap: onTap,
      child: Container(
        height: 70,
        margin: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: isDark 
              ? AppColors.surfaceDark.withOpacity(0.9)
              : AppColors.surface.withOpacity(0.9),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: AppColors.primary.withOpacity(0.2),
            width: 1,
          ),
          boxShadow: [
            BoxShadow(
              color: AppColors.shadow.withOpacity(0.1),
              blurRadius: 8,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Row(
          children: [
            Container(
              width: 50,
              height: 50,
              margin: const EdgeInsets.all(10),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  colors: [AppColors.primary, AppColors.secondary],
                ),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Icon(
                song.iconType == 'music' ? Icons.music_note : Icons.temple_hindu,
                color: Colors.white,
                size: 20,
              ),
            ),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(
                    song.title,
                    style: AppTextStyles.bodyMedium.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  Text(
                    song.singer,
                    style: AppTextStyles.bodySmall.copyWith(
                      color: AppColors.textSecondary,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
            IconButton(
              onPressed: onPlayPause,
              icon: Icon(
                isPlaying ? Icons.pause : Icons.play_arrow,
                color: AppColors.primary,
                size: 28,
              ),
            ),
            const SizedBox(width: 8),
          ],
        ),
      ),
    );
  }
}
//widgets/song_view/font_size_controls.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/theme_provider.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';

class FontSizeControls extends StatefulWidget {
  final double fontSize;
  final ValueChanged<double> onFontSizeChanged;
  final double minFontSize;
  final double maxFontSize;

  const FontSizeControls({
    Key? key,
    required this.fontSize,
    required this.onFontSizeChanged,
    this.minFontSize = 12.0,
    this.maxFontSize = 24.0,
  }) : super(key: key);

  @override
  State<FontSizeControls> createState() => _FontSizeControlsState();
}

class _FontSizeControlsState extends State<FontSizeControls>
    with TickerProviderStateMixin {
  late AnimationController _scaleController;
  late Animation<double> _scaleAnimation;
  bool _isVisible = true;

  @override
  void initState() {
    super.initState();
    _scaleController = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _scaleController,
      curve: Curves.elasticOut,
    ));
    _scaleController.forward();
  }

  void _increaseFontSize() {
    if (widget.fontSize < widget.maxFontSize) {
      final newSize = (widget.fontSize + 1.0).clamp(
        widget.minFontSize,
        widget.maxFontSize,
      );
      widget.onFontSizeChanged(newSize);
      _animateButton();
    }
  }

  void _decreaseFontSize() {
    if (widget.fontSize > widget.minFontSize) {
      final newSize = (widget.fontSize - 1.0).clamp(
        widget.minFontSize,
        widget.maxFontSize,
      );
      widget.onFontSizeChanged(newSize);
      _animateButton();
    }
  }

  void _resetFontSize() {
    const defaultSize = 16.0;
    widget.onFontSizeChanged(defaultSize);
    _animateButton();
  }

  void _animateButton() {
    _scaleController.reset();
    _scaleController.forward();
  }

  void toggleVisibility() {
    setState(() {
      _isVisible = !_isVisible;
    });
  }

  Widget _buildControlButton({
    required IconData icon,
    required VoidCallback onPressed,
    required bool enabled,
    String? tooltip,
  }) {
    final themeProvider = context.watch<ThemeProvider>();
    
    return ScaleTransition(
      scale: _scaleAnimation,
      child: Tooltip(
        message: tooltip ?? '',
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: enabled ? onPressed : null,
            borderRadius: BorderRadius.circular(12),
            child: Container(
              width: 48,
              height: 48,
              decoration: BoxDecoration(
                color: enabled 
                    ? AppColors.accent.withOpacity(0.1)
                    : Colors.grey.withOpacity(0.1),
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                  color: enabled 
                      ? AppColors.accent.withOpacity(0.3)
                      : Colors.grey.withOpacity(0.3),
                  width: 1.5,
                ),
                boxShadow: enabled ? [
                  BoxShadow(
                    color: AppColors.accent.withOpacity(0.1),
                    blurRadius: 8,
                    offset: const Offset(0, 2),
                  ),
                ] : null,
              ),
              child: Icon(
                icon,
                size: 20,
                color: enabled 
                    ? AppColors.accent
                    : Colors.grey,
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildFontSizeSlider() {
    return Container(
      width: 200,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: AppColors.surface.withOpacity(0.9),
        borderRadius: BorderRadius.circular(20),
        boxShadow: [
          BoxShadow(
            color: AppColors.shadow.withOpacity(0.1),
            blurRadius: 12,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            'Font Size',
            style: AppTextStyles.bodySmall.copyWith(
              color: AppColors.textSecondary,
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 8),
          Row(
            children: [
              Text(
                'A',
                style: TextStyle(
                  fontSize: 12,
                  color: AppColors.textSecondary,
                  fontWeight: FontWeight.bold,
                ),
              ),
              Expanded(
                child: SliderTheme(
                  data: SliderTheme.of(context).copyWith(
                    activeTrackColor: AppColors.accent,
                    inactiveTrackColor: AppColors.accent.withOpacity(0.3),
                    thumbColor: AppColors.accent,
                    overlayColor: AppColors.accent.withOpacity(0.2),
                    thumbShape: const RoundSliderThumbShape(
                      enabledThumbRadius: 8,
                    ),
                    trackHeight: 3,
                  ),
                  child: Slider(
                    value: widget.fontSize,
                    min: widget.minFontSize,
                    max: widget.maxFontSize,
                    divisions: (widget.maxFontSize - widget.minFontSize).toInt(),
                    onChanged: widget.onFontSizeChanged,
                  ),
                ),
              ),
              Text(
                'A',
                style: TextStyle(
                  fontSize: 20,
                  color: AppColors.textSecondary,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          Text(
            '${widget.fontSize.toInt()}px',
            style: AppTextStyles.bodySmall.copyWith(
              color: AppColors.accent,
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedSwitcher(
      duration: const Duration(milliseconds: 300),
      child: _isVisible
          ? Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: AppColors.surface.withOpacity(0.95),
                borderRadius: BorderRadius.circular(16),
                border: Border.all(
                  color: AppColors.accent.withOpacity(0.2),
                ),
                boxShadow: [
                  BoxShadow(
                    color: AppColors.shadow.withOpacity(0.15),
                    blurRadius: 16,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  // Control buttons row
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      _buildControlButton(
                        icon: Icons.text_decrease,
                        onPressed: _decreaseFontSize,
                        enabled: widget.fontSize > widget.minFontSize,
                        tooltip: 'Decrease font size',
                      ),
                      const SizedBox(width: 12),
                      _buildControlButton(
                        icon: Icons.refresh,
                        onPressed: _resetFontSize,
                        enabled: widget.fontSize != 16.0,
                        tooltip: 'Reset to default',
                      ),
                      const SizedBox(width: 12),
                      _buildControlButton(
                        icon: Icons.text_increase,
                        onPressed: _increaseFontSize,
                        enabled: widget.fontSize < widget.maxFontSize,
                        tooltip: 'Increase font size',
                      ),
                    ],
                  ),
                  
                  const SizedBox(height: 12),
                  
                  // Font size slider
                  _buildFontSizeSlider(),
                  
                  const SizedBox(height: 8),
                  
                  // Font size preview
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: AppColors.accent.withOpacity(0.05),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Text(
                      'à¥ à¤¸à¥à¤µà¤¾à¤®à¥€ à¤¶à¤°à¤£à¤®à¥ à¤…à¤¯à¥à¤¯à¤ªà¥à¤ªà¤¾',
                      style: TextStyle(
                        fontSize: widget.fontSize,
                        color: AppColors.accent,
                        fontWeight: FontWeight.w500,
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ),
                  
                  const SizedBox(height: 8),
                  
                  // Hide button
                  TextButton.icon(
                    onPressed: toggleVisibility,
                    icon: Icon(
                      Icons.keyboard_arrow_up,
                      size: 16,
                      color: AppColors.textSecondary,
                    ),
                    label: Text(
                      'Hide',
                      style: AppTextStyles.bodySmall.copyWith(
                        color: AppColors.textSecondary,
                      ),
                    ),
                    style: TextButton.styleFrom(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 8,
                        vertical: 4,
                      ),
                      minimumSize: Size.zero,
                      tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    ),
                  ),
                ],
              ),
            )
          : FloatingActionButton.small(
              onPressed: toggleVisibility,
              backgroundColor: AppColors.accent,
              child: const Icon(
                Icons.text_fields,
                color: Colors.white,
                size: 20,
              ),
            ),
    );
  }

  @override
  void dispose() {
    _scaleController.dispose();
    super.dispose();
  }
}
//widgets/song_view/language_tabs_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../providers/language_provider.dart';
import '../../../utils/constants.dart';
import '../../../utils/text_styles.dart';

class LanguageTabs extends StatelessWidget {
  final String selectedLanguage;
  final ValueChanged<String> onLanguageChanged;
  final bool showPhoneticOptions;

  const LanguageTabs({
    Key? key,
    required this.selectedLanguage,
    required this.onLanguageChanged,
    this.showPhoneticOptions = true,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final languageProvider = Provider.of<LanguageProvider>(context);
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: isDark 
            ? AppColors.surfaceDark.withOpacity(0.3)
            : AppColors.surface.withOpacity(0.8),
        borderRadius: BorderRadius.circular(25),
        border: Border.all(
          color: AppColors.primary.withOpacity(0.2),
          width: 1,
        ),
        boxShadow: [
          BoxShadow(
            color: AppColors.shadow.withOpacity(0.1),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: SingleChildScrollView(
        scrollDirection: Axis.horizontal,
        child: Row(
          children: _buildLanguageTabs(context, isDark),
        ),
      ),
    );
  }

  List<Widget> _buildLanguageTabs(BuildContext context, bool isDark) {
    final languages = [
      {'key': 'ta', 'label': 'à®¤à®®à®¿à®´à¯', 'icon': Icons.language},
      {'key': 'te', 'label': 'à°¤à±†à°²à±à°—à±', 'icon': Icons.translate},
      if (showPhoneticOptions) ...[
        {'key': 'en_ta', 'label': 'Tamil (EN)', 'icon': Icons.abc},
        {'key': 'en_te', 'label': 'Telugu (EN)', 'icon': Icons.spellcheck},
      ],
    ];

    return languages.map((lang) {
      final isSelected = selectedLanguage == lang['key'];
      return _buildLanguageTab(
        context,
        lang['key'] as String,
        lang['label'] as String,
        lang['icon'] as IconData,
        isSelected,
        isDark,
      );
    }).toList();
  }

  Widget _buildLanguageTab(
    BuildContext context,
    String languageKey,
    String label,
    IconData icon,
    bool isSelected,
    bool isDark,
  ) {
    return GestureDetector(
      onTap: () => onLanguageChanged(languageKey),
      child: AnimatedContainer(
        duration: AppConstants.animationDuration,
        curve: Curves.easeInOut,
        margin: const EdgeInsets.all(4),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
        decoration: BoxDecoration(
          color: isSelected
              ? AppColors.primary
              : Colors.transparent,
          borderRadius: BorderRadius.circular(20),
          boxShadow: isSelected
              ? [
                  BoxShadow(
                    color: AppColors.primary.withOpacity(0.3),
                    blurRadius: 8,
                    offset: const Offset(0, 2),
                  ),
                ]
              : null,
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              icon,
              size: 16,
              color: isSelected
                  ? Colors.white
                  : isDark
                      ? AppColors.textSecondaryDark
                      : AppColors.textSecondary,
            ),
            const SizedBox(width: 6),
            Text(
              label,
              style: AppTextStyles.bodyMedium.copyWith(
                color: isSelected
                    ? Colors.white
                    : isDark
                        ? AppColors.textSecondaryDark
                        : AppColors.textSecondary,
                fontWeight: isSelected ? FontWeight.w600 : FontWeight.w500,
                fontSize: 13,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class LanguageTabsHorizontal extends StatelessWidget {
  final String selectedLanguage;
  final ValueChanged<String> onLanguageChanged;
  final List<String> availableLanguages;

  const LanguageTabsHorizontal({
    Key? key,
    required this.selectedLanguage,
    required this.onLanguageChanged,
    this.availableLanguages = const ['ta', 'te', 'en_ta', 'en_te'],
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      height: 45,
      margin: const EdgeInsets.symmetric(horizontal: 16),
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        itemCount: availableLanguages.length,
        itemBuilder: (context, index) {
          final languageKey = availableLanguages[index];
          final isSelected = selectedLanguage == languageKey;
          
          return _buildCompactTab(
            context,
            languageKey,
            _getLanguageDisplayName(languageKey),
            isSelected,
            isDark,
          );
        },
      ),
    );
  }

  Widget _buildCompactTab(
    BuildContext context,
    String languageKey,
    String displayName,
    bool isSelected,
    bool isDark,
  ) {
    return GestureDetector(
      onTap: () => onLanguageChanged(languageKey),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        margin: const EdgeInsets.only(right: 8),
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: isSelected
              ? AppColors.primary
              : isDark
                  ? AppColors.surfaceDark.withOpacity(0.5)
                  : AppColors.surface.withOpacity(0.8),
          borderRadius: BorderRadius.circular(20),
          border: Border.all(
            color: isSelected
                ? AppColors.primary
                : AppColors.primary.withOpacity(0.2),
            width: 1,
          ),
        ),
        child: Center(
          child: Text(
            displayName,
            style: AppTextStyles.bodySmall.copyWith(
              color: isSelected
                  ? Colors.white
                  : AppColors.primary,
              fontWeight: isSelected ? FontWeight.w600 : FontWeight.w500,
            ),
          ),
        ),
      ),
    );
  }

  String _getLanguageDisplayName(String languageKey) {
    switch (languageKey) {
      case 'ta':
        return 'à®¤à®®à®¿à®´à¯';
      case 'te':
        return 'à°¤à±†à°²à±à°—à±';
      case 'en_ta':
        return 'Tamil';
      case 'en_te':
        return 'Telugu';
      default:
        return languageKey.toUpperCase();
    }
  }
}

class LanguageTabsBottom extends StatelessWidget {
  final String selectedLanguage;
  final ValueChanged<String> onLanguageChanged;
  final bool showLabels;

  const LanguageTabsBottom({
    Key? key,
    required this.selectedLanguage,
    required this.onLanguageChanged,
    this.showLabels = true,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      decoration: BoxDecoration(
        color: isDark 
            ? AppColors.surfaceDark.withOpacity(0.95)
            : AppColors.surface.withOpacity(0.95),
        border: Border(
          top: BorderSide(
            color: AppColors.primary.withOpacity(0.1),
            width: 1,
          ),
        ),
      ),
      child: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _buildBottomTab('ta', 'à®¤à®®à®¿à®´à¯', Icons.language, isDark),
              _buildBottomTab('te', 'à°¤à±†à°²à±à°—à±', Icons.translate, isDark),
              _buildBottomTab('en_ta', 'Tamil', Icons.abc, isDark),
              _buildBottomTab('en_te', 'Telugu', Icons.spellcheck, isDark),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildBottomTab(
    String languageKey,
    String label,
    IconData icon,
    bool isDark,
  ) {
    final isSelected = selectedLanguage == languageKey;
    
    return GestureDetector(
      onTap: () => onLanguageChanged(languageKey),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: isSelected
              ? AppColors.primary.withOpacity(0.1)
              : Colors.transparent,
          borderRadius: BorderRadius.circular(12),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              icon,
              size: 20,
              color: isSelected
                  ? AppColors.primary
                  : isDark
                      ? AppColors.textSecondaryDark
                      : AppColors.textSecondary,
            ),
            if (showLabels) ...[
              const SizedBox(height: 2),
              Text(
                label,
                style: AppTextStyles.bodySmall.copyWith(
                  color: isSelected
                      ? AppColors.primary
                      : isDark
                          ? AppColors.textSecondaryDark
                          : AppColors.textSecondary,
                  fontSize: 10,
                  fontWeight: isSelected ? FontWeight.w600 : FontWeight.w400,
                ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ],
        ),
      ),
    );
  }
}
//widgets/song_view/lyrics_display.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../models/song_model.dart';
import '../../providers/language_provider.dart';
import '../../providers/theme_provider.dart';
import '../../utils/constants.dart';
import '../../utils/text_styles.dart';

class LyricsDisplay extends StatefulWidget {
  final Song song;
  final double fontSize;
  final bool isKaraokeMode;
  final int currentLine;

  const LyricsDisplay({
    Key? key,
    required this.song,
    required this.fontSize,
    this.isKaraokeMode = false,
    this.currentLine = -1,
  }) : super(key: key);

  @override
  State<LyricsDisplay> createState() => _LyricsDisplayState();
}

class _LyricsDisplayState extends State<LyricsDisplay>
    with TickerProviderStateMixin {
  late ScrollController _scrollController;
  late AnimationController _highlightController;
  late Animation<Color?> _highlightAnimation;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();
    _highlightController = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );
    _setupHighlightAnimation();
  }

  void _setupHighlightAnimation() {
    _highlightAnimation = ColorTween(
      begin: AppColors.accent.withOpacity(0.0),
      end: AppColors.accent.withOpacity(0.3),
    ).animate(CurvedAnimation(
      parent: _highlightController,
      curve: Curves.easeInOut,
    ));
  }

  @override
  void didUpdateWidget(LyricsDisplay oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.isKaraokeMode && 
        widget.currentLine != oldWidget.currentLine &&
        widget.currentLine >= 0) {
      _scrollToCurrentLine();
      _highlightController.forward().then((_) {
        _highlightController.reverse();
      });
    }
  }

  void _scrollToCurrentLine() {
    if (widget.currentLine >= 0) {
      final position = widget.currentLine * (widget.fontSize + 16);
      _scrollController.animateTo(
        position,
        duration: const Duration(milliseconds: 500),
        curve: Curves.easeInOut,
      );
    }
  }

  String _getCurrentLyrics() {
    final languageProvider = context.watch<LanguageProvider>();
    switch (languageProvider.selectedLanguage) {
      case 'ta':
        return widget.song.tamilLyrics;
      case 'te':
        return widget.song.teluguLyrics;
      case 'en-ta':
        return widget.song.englishPhoneticTamil;
      case 'en-te':
        return widget.song.englishPhoneticTelugu;
      default:
        return widget.song.tamilLyrics;
    }
  }

  TextStyle _getLyricsTextStyle() {
    final themeProvider = context.watch<ThemeProvider>();
    final languageProvider = context.watch<LanguageProvider>();
    
    Color textColor;
    switch (themeProvider.themeMode) {
      case ThemeMode.dark:
        textColor = AppColors.textDark;
        break;
      case ThemeMode.light:
        textColor = AppColors.textLight;
        break;
      default:
        textColor = AppColors.sepia;
    }

    // Use appropriate font family based on language
    String? fontFamily;
    if (languageProvider.selectedLanguage == 'ta') {
      fontFamily = 'Tamil';
    } else if (languageProvider.selectedLanguage == 'te') {
      fontFamily = 'Telugu';
    }

    return TextStyle(
      fontSize: widget.fontSize,
      height: 1.8,
      color: textColor,
      fontFamily: fontFamily,
      fontWeight: FontWeight.w400,
      letterSpacing: 0.5,
    );
  }

  Widget _buildLyricsLine(String line, int index) {
    final isCurrentLine = widget.isKaraokeMode && widget.currentLine == index;
    
    return AnimatedBuilder(
      animation: _highlightAnimation,
      builder: (context, child) {
        return Container(
          margin: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
          padding: const EdgeInsets.symmetric(vertical: 12.0, horizontal: 16.0),
          decoration: BoxDecoration(
            color: isCurrentLine ? _highlightAnimation.value : Colors.transparent,
            borderRadius: BorderRadius.circular(12),
            border: isCurrentLine 
                ? Border.all(color: AppColors.accent.withOpacity(0.5), width: 1)
                : null,
          ),
          child: Text(
            line.trim(),
            style: _getLyricsTextStyle().copyWith(
              fontWeight: isCurrentLine ? FontWeight.w600 : FontWeight.w400,
              color: isCurrentLine 
                  ? AppColors.accent 
                  : _getLyricsTextStyle().color,
            ),
            textAlign: TextAlign.center,
          ),
        );
      },
    );
  }

  Widget _buildScrollIndicator() {
    return Positioned(
      right: 8,
      top: 0,
      bottom: 0,
      child: Container(
        width: 4,
        decoration: BoxDecoration(
          color: AppColors.accent.withOpacity(0.3),
          borderRadius: BorderRadius.circular(2),
        ),
        child: LayoutBuilder(
          builder: (context, constraints) {
            return AnimatedBuilder(
              animation: _scrollController,
              builder: (context, child) {
                if (!_scrollController.hasClients) return const SizedBox();
                
                final scrollExtent = _scrollController.position.maxScrollExtent;
                final currentScroll = _scrollController.offset;
                final indicatorHeight = constraints.maxHeight * 0.1;
                final indicatorPosition = scrollExtent > 0 
                    ? (currentScroll / scrollExtent) * (constraints.maxHeight - indicatorHeight)
                    : 0.0;

                return Positioned(
                  top: indicatorPosition,
                  child: Container(
                    width: 4,
                    height: indicatorHeight,
                    decoration: BoxDecoration(
                      color: AppColors.accent,
                      borderRadius: BorderRadius.circular(2),
                    ),
                  ),
                );
              },
            );
          },
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final lyrics = _getCurrentLyrics();
    final lines = lyrics.split('\n').where((line) => line.trim().isNotEmpty).toList();

    return Stack(
      children: [
        // Lyrics scroll view
        Scrollbar(
          controller: _scrollController,
          thumbVisibility: true,
          radius: const Radius.circular(8),
          child: SingleChildScrollView(
            controller: _scrollController,
            physics: const BouncingScrollPhysics(),
            padding: const EdgeInsets.only(
              top: 24,
              bottom: 100,
              left: 8,
              right: 24,
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // Song title
                Container(
                  margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                  padding: const EdgeInsets.all(20),
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        AppColors.accent.withOpacity(0.1),
                        AppColors.secondary.withOpacity(0.1),
                      ],
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                    ),
                    borderRadius: BorderRadius.circular(16),
                    border: Border.all(
                      color: AppColors.accent.withOpacity(0.2),
                    ),
                  ),
                  child: Column(
                    children: [
                      Text(
                        widget.song.title,
                        style: AppTextStyles.headingLarge.copyWith(
                          color: AppColors.accent,
                          fontWeight: FontWeight.bold,
                        ),
                        textAlign: TextAlign.center,
                      ),
                      if (widget.song.singer.isNotEmpty) ...[
                        const SizedBox(height: 8),
                        Text(
                          'Singer: ${widget.song.singer}',
                          style: AppTextStyles.bodyMedium.copyWith(
                            color: AppColors.textSecondary,
                            fontStyle: FontStyle.italic,
                          ),
                          textAlign: TextAlign.center,
                        ),
                      ],
                      if (widget.song.writer.isNotEmpty) ...[
                        const SizedBox(height: 4),
                        Text(
                          'Writer: ${widget.song.writer}',
                          style: AppTextStyles.bodyMedium.copyWith(
                            color: AppColors.textSecondary,
                            fontStyle: FontStyle.italic,
                          ),
                          textAlign: TextAlign.center,
                        ),
                      ],
                    ],
                  ),
                ),
                
                // Lyrics lines
                ...lines.asMap().entries.map((entry) {
                  return _buildLyricsLine(entry.value, entry.key);
                }),
                
                // Devotional blessing at the end
                Container(
                  margin: const EdgeInsets.all(16),
                  padding: const EdgeInsets.all(20),
                  decoration: BoxDecoration(
                    color: AppColors.accent.withOpacity(0.05),
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(
                      color: AppColors.accent.withOpacity(0.1),
                    ),
                  ),
                  child: Column(
                    children: [
                      Icon(
                        Icons.auto_awesome,
                        color: AppColors.accent,
                        size: 24,
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Swamiye Saranam Ayyappa',
                        style: AppTextStyles.bodyLarge.copyWith(
                          color: AppColors.accent,
                          fontWeight: FontWeight.w600,
                          fontStyle: FontStyle.italic,
                        ),
                        textAlign: TextAlign.center,
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
        
        // Custom scroll indicator
        if (widget.isKaraokeMode) _buildScrollIndicator(),
      ],
    );
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _highlightController.dispose();
    super.dispose();
  }
}
